<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>downfall</title>
    <link href="/2024/12/21/downfall/"/>
    <url>/2024/12/21/downfall/</url>
    
    <content type="html"><![CDATA[<h1 id="downfall"><a href="#downfall" class="headerlink" title="downfall"></a>downfall</h1><link rel="stylesheet" href="/css/downfall.css"><h2 id="gather-指令"><a href="#gather-指令" class="headerlink" title="gather 指令"></a>gather 指令</h2><p>gather 指令可以高效访问<span class="just_red">非连续内存数据</span></p><p>访问的所有内存地址来源于 base 寄存器和 index 寄存器，根据 Mask 选取有效的内存数据，拼接到 Result 宽寄存器中</p><img src="/img/downfall/001.png" alt="" height="550px"><ul>    <li>对于掩码为 0 的数据，不进行读取</li>    <li>读取后会在 cache 中存储一份，方便同一条 gather 指令中的重复读取</li>    <li>并行、推测地读取全部内存数据，它们必须同时成功或失败</li>    <li>开辟中间变量保存已经读取的部分，避免中断导致全部重新读取</li></ul><p>当 gather 指令中间发生中断时，CPU 会利用临时 buffer 存储已经读取的数据(从 DRAM 或 cache 中保存)，方便中断结束后 gather 指令直接从中间重新运行。当 gather 指令错误的结束时，CPU 将抛弃这些值。</p><p>gather 指令格式<br><code>vpgatherdd displacement(base, index, scale), dst&#123;mask&#125;</code><br>displacement 是一个偏移量，base 是基址寄存器，index 是索引寄存器，scale 是倍数因子，dst 是写入寄存器，mask 是掩码寄存器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs asm">// Step (i): Increase the transient window<br>lea addresses_normal, %rdi ;                (1) 加载普通地址到 %rdi<br>clflush (%rdi) ;                            (2) 清除缓存中 %rdi 指向的内存<br>mov (%rdi), %rax ;                          (3) 从 %rdi 指向的内存加载数据到 %rax<br><br>// Step (ii): Gather uncacheable memory<br>lea addresses_uncacheable, %rsi ;           (4) 加载不可缓存地址到 %rsi<br>mov \$0b1, %rdi ;                           (5) 设置寄存器值<br>kmovq %rdi, %k1 ;                           (6) 将 %rdi 的值加载到 k1 寄存器<br>vpxord %zmm1, %zmm1, %zmm1 ;                (7) 清零 zmm1 寄存器<br>vpgatherdd 0(%rsi, %zmm1, 1), %zmm5&#123;%k1&#125; ;  (8) 执行 gather 指令并存入 %zmm5<br><br>// Step (iii): Encode (transient) data to cache<br>movq %xmm5, %rax ;                          (9) 将 xmm5 中的数据移动到 %rax<br>encode_eax ;                                (10) 编码数据到缓存<br><br>// Step (iv): Scan the cache<br>scan_flush_reload ;                         (11) 扫描缓存，使用 Flush + Reload 技术<br></code></pre></td></tr></table></figure><h3 id="Step-i-Increase-the-transient-window"><a href="#Step-i-Increase-the-transient-window" class="headerlink" title="Step (i): Increase the transient window"></a>Step (i): Increase the transient window</h3><p>Transient window 是 CPU 内部进行的预测性操作的一段时间窗口。在这一段时间内，CPU会执行一些指令，假设这些指令的操作是正确的，即使在实际执行时，可能由于某些分支预测失败或数据依赖错误，这些操作的结果不会最终提交给程序。</p><p>在预测执行期间，CPU 执行的指令可能会影响系统状态（如缓存），而这些影响可能会被利用以获取未授权的数据，即使这些数据最终没有影响程序的最终结果。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-comment">// 清除缓存中 address_normal 指向的内存，保证指令访问该地址时，触发缓存未命中</span><br>lea addresses_normal, %rdi ;<br>clflush (%rdi) ; <br><br><span class="hljs-comment">// 访问地址 address_normal</span><br>mov (%rdi), %rax ; 从 %rdi 指向的内存加载数据到 %rax<br></code></pre></td></tr></table></figure><h3 id="Step-ii-Gather-uncacheable-memory"><a href="#Step-ii-Gather-uncacheable-memory" class="headerlink" title="Step (ii): Gather uncacheable memory"></a>Step (ii): Gather uncacheable memory</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-comment">// 目标非法地址 addresses_uncacheable</span><br>lea addresses_uncacheable, %rsi ;<br><br><span class="hljs-comment">// 将 1 加载到掩码寄存器中</span><br>mov $0b1, %rdi ;<br>kmovq %rdi, %k1 ;<br><br><span class="hljs-comment">// 使寄存器 %znm1 置零</span><br>vpxord %zmm1, %zmm1, %zmm1 ;<br><br><span class="hljs-comment">// 访问起始地址为 addresses_uncacheable，掩码为 1</span><br>vpgatherdd <span class="hljs-number">0</span>(%rsi, %zmm1, <span class="hljs-number">1</span>), %zmm5&#123;%k1&#125; ;<br></code></pre></td></tr></table></figure><h3 id="Step-iii-Encode-transient-data-to-cache"><a href="#Step-iii-Encode-transient-data-to-cache" class="headerlink" title="Step (iii): Encode (transient) data to cache"></a>Step (iii): Encode (transient) data to cache</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">// 将 gather 指令的结果加载到 %rax 中并进行编码</span><br>movq <span class="hljs-meta">%</span>xm<span class="hljs-name">m5</span>, <span class="hljs-meta">%</span>rax<br>e<span class="hljs-symbol">ncode_eax</span><br></code></pre></td></tr></table></figure><h3 id="Step-iv-Scan-the-cache"><a href="#Step-iv-Scan-the-cache" class="headerlink" title="Step (iv): Scan the cache"></a>Step (iv): Scan the cache</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span> flush 把特定内存地址的数据从缓存中删除<br><span class="hljs-string">//</span> <span class="hljs-keyword">reload</span> 通过对比加载数据的时间，推测数据是否在缓存当中，进而推测之前指令获取的数据<br>scan_flush_<span class="hljs-keyword">reload</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库八股文——规范化理论</title>
    <link href="/2024/12/20/DataBase4/"/>
    <url>/2024/12/20/DataBase4/</url>
    
    <content type="html"><![CDATA[<h1 id="规范化理论"><a href="#规范化理论" class="headerlink" title="规范化理论"></a>规范化理论</h1><link rel="stylesheet" href="/css/DataBase_RelationModel.css"><script type="text/javascript" async  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script><h2 id="规范化理论的目的"><a href="#规范化理论的目的" class="headerlink" title="规范化理论的目的"></a>规范化理论的目的</h2><h3 id="不恰当的关系设计"><a href="#不恰当的关系设计" class="headerlink" title="不恰当的关系设计"></a>不恰当的关系设计</h3><p>有这样一个关系：in_dep (ID, name, salary, dept_name, building, budget)，其中 ID 为主码。</p><img src="/img/044.png" alt="" style="height: 300px;"><p>现在有以下四个问题：</p><ul>    <li>重复性：属性 building 和 budget 出现了大量重复的值</li>    <li>更新：如果我仅仅更新了一个 building 的 budget，理论上所有对应的 budget 都应该被修改</li>    <li>插入：如果我仅仅插入一个新的 building 信息，则对于 instructor 部分只能取 NULL</li>    <li>删除：如果我删除了 instructor 的信息，building 相关信息也会消失</li></ul><p>为什么会出现这些问题？</p><p><span class="sub_title">因为关系中出现了毫无关系的属性，也即 instructor 和 building 没有关联，却出现在了同一张表格中。</span></p><p>如何解决这些问题？</p><p><span class="sub_title">使用规范化理论约束关系的设计。</span></p><img src="/img/045.png" alt=""><h3 id="有损分解"><a href="#有损分解" class="headerlink" title="有损分解"></a>有损分解</h3><p>上述例子通过拆分关系达到了约束效果，但实际上拆分不是随意的，例如下面这个例子：</p><img src="/img/046.png" alt="" style="height: 500px;"><p>我们发现，拆分之后的表格重新组合后会多出一些不该存在的元组。我们称：如果一个分解不能组合成原来的样子(多元组&#x2F;少元组)，则该分解称为<span class="just_red">有损分解</span>。</p><p>规范化的分解要求：</p><ul>    <li>无损连接，分解后的关系可以拼接会原来的关系</li>    <li>依赖保持，通过规定分解后关系的约束，支持在分解前关系上存在的约束</li></ul><h2 id="规范化规则"><a href="#规范化规则" class="headerlink" title="规范化规则"></a>规范化规则</h2><h3 id="函数依赖-Functional-Dependencies"><a href="#函数依赖-Functional-Dependencies" class="headerlink" title="函数依赖 Functional Dependencies"></a>函数依赖 Functional Dependencies</h3><p>函数依赖反映了一个关系中属性或者属性组之间相互依存、相互制约的关系，即两个列或者列组之间的约束。</p><p>函数依赖起到检测冗余是否存在的作用，通过冗余的检测，就能很容易判断出这个关系是不是存在相应的插入，删除，更新异常。基于函数依赖理论，可以将一个关系分解为几个更小的关系，使之满足规范化程度更高的关系表。</p><p>设关系 R(U) 是一个在 U 属性集上定义的关系，X, Y 为 U 的两个子集：</p><p>若对于 R(U) 的任意一个可能的关系 r，r 中不可能存在两个元组在 X 上的属性值相等， 而在 Y 上的属性值不等。</p><p>则称：<span class="just_red">X → Y</span>，X 称为这个函数依赖的决定属性集(Determinant)</p><img src="/img/047.png" alt="" style="height: 300px;"><p>对于上图的关系，要求是属性 学号 → 姓名，也即只要知道了学号，就能推得姓名。上图中的黄色部分违反了这一规则人，因为相同的学号推得了不同的姓名，说明不能称 学号 → 姓名。</p><h4 id="函数依赖和属性的关系"><a href="#函数依赖和属性的关系" class="headerlink" title="函数依赖和属性的关系"></a>函数依赖和属性的关系</h4><p>对于属性集 X 和 Y，他们的基数约束规则决定了他们之间可能的函数依赖。</p><ul>    <li>一对一，则存在函数依赖 X → Y 和 Y → X</li>    <li>一对多，则存在函数依赖 Y → X</li>    <li>多对多，则不存在依赖</li></ul><h4 id="平凡函数依赖-非平凡函数依赖"><a href="#平凡函数依赖-非平凡函数依赖" class="headerlink" title="平凡函数依赖&#x2F;非平凡函数依赖"></a>平凡函数依赖&#x2F;非平凡函数依赖</h4><p>如果 X → Y 并且 Y ⊆ X，则称 X → Y 是平凡的函数依赖，否则则称非平凡的函数依赖。</p><p>很明显，平凡的函数依赖是一句废话，所以我们一般研究的都是非平凡的函数依赖。</p><h4 id="完全函数依赖-部分函数依赖"><a href="#完全函数依赖-部分函数依赖" class="headerlink" title="完全函数依赖&#x2F;部分函数依赖"></a>完全函数依赖&#x2F;部分函数依赖</h4><p>如果 X → Y，并且对于 X 的任何一个真子集 X’，都有X’ ⇏ Y，则称 Y 完全函数依赖于 X，记作 <span class="just_red">X →f Y</span>，否则称 Y 部分依赖于 X，记作 <span class="just_red">X →P Y</span>。</p><h4 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h4><p>如果 X → Y，Y → Z，且 Y 不包含于 X，Y ⇏ X，则称Z传递函数依赖于 X，记作 <span class="just_red">X →T Z</span><br>如果 Y → X， 即 X ←→ Y (X Y 相互依赖)，则 Z 直接依赖于 X </p><h4 id="连接依赖"><a href="#连接依赖" class="headerlink" title="连接依赖"></a>连接依赖</h4><p>关系 R 的每个合法实例 r，都具有一个无损联结分解。也即任何的关系实例，都存在一组属性集上覆盖，使得其求投影后自然连接完全等价于原关系实例。</p><h3 id="规范化设计与范式"><a href="#规范化设计与范式" class="headerlink" title="规范化设计与范式"></a>规范化设计与范式</h3><p>在关系模式中存在函数依赖时就有可能存在数据冗余，进而可能导致数据操作异常。因此，关系表的规范化设计就是要尽可能地减少关系表中列或者列组之间的依赖关系，进而得到简洁独立的关系表。</p><p>关系表的规范程度状态为<span class="just_red">范式(nommalomm,NF)</span>，范式可以用于确保数据库模式中没有各种类型的异常和不一致，不同的规范化范式要求可以设计出几余程度不同的数据库。</p><p><span class="just_red">规范化</span>，就是指一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式集合。</p><img src="/img/048.png" alt=""><h4 id="第一范式-——-属性是不可再分的原子"><a href="#第一范式-——-属性是不可再分的原子" class="headerlink" title="第一范式 —— 属性是不可再分的原子"></a>第一范式 —— 属性是不可再分的原子</h4><p>第一范式(1NF)是指关系 R 的每一属性都是不可再分的基本数据项，同一属性中不能有多个值，即关系表中的某个属性不能有多个值或者不能有重复的属性。</p><p>在关系数据库中，满足最低要求的范式是第一范式，不满足第一范式的不是关系数据库。如果出现重复的属性，则根据第一范式，需要将该属性进行细分。</p><p>将不属于第一范式的关系规范化的方法：</p><ul>    <li>在含有重复数据的那些行的空白列上输入合适的数据，也就是在需要填充的位置复制非重复的数据（对表的平板化处理）</li>    <li>将重复数据单独移动到一个新的关系中，同时也将原来关系中的关键属性（组）复制到这个新的关系中。如果有多个重复组或者重复组里又有重复组，反复使用这种方法，直到不再有重复组为止</li></ul><h4 id="第二范式-——-非主属性完全函数依赖于候选码"><a href="#第二范式-——-非主属性完全函数依赖于候选码" class="headerlink" title="第二范式 —— 非主属性完全函数依赖于候选码"></a>第二范式 —— 非主属性完全函数依赖于候选码</h4><p>每一行数据仅可以被候选码唯一区分</p><img src="/img/050.png" alt=""><p>左侧关系中，候选码为 (Sno, Cno)，有 (Sno, Cno) → Sdept, Sno → Sdept<br>不难发现 Sdept 部分依赖于候选码，该关系不属于第二范式</p><h4 id="第三范式-——-不存在传递依赖"><a href="#第三范式-——-不存在传递依赖" class="headerlink" title="第三范式 —— 不存在传递依赖"></a>第三范式 —— 不存在传递依赖</h4><p>在 2NF 基础上，消除依赖传递，任何非主属性不依赖与其他非主属性。即每个属性都和候选码有直接关系，不存在非主属性间的相互依赖。</p><p>在一个表中，如果一个非主属性依赖于另一个非主属性，那么当更新其中一个属性时，另一个属性可能会出现错误。<br>这可能会导致查询结果出现错误，也可能会使得对数据库的修改出现问题。我们需要保证只有更新候选码的时候才需要大规模的改动其他非主属性。</p><img src="/img/051.png" alt=""><p>例如上图左侧的关系，存在函数依赖 Sno → Sdept, Sdept → Sloc, 故存在传递依赖 Sdept → Sloc，该关系不属于 3NF，但是并没有部分依赖于候选码的情况，故属于 2NF。</p><h4 id="巴斯-科德范式-BCNF-——-依赖关系式左侧必定包含候选码"><a href="#巴斯-科德范式-BCNF-——-依赖关系式左侧必定包含候选码" class="headerlink" title="巴斯-科德范式 BCNF —— 依赖关系式左侧必定包含候选码"></a>巴斯-科德范式 BCNF —— 依赖关系式左侧必定包含候选码</h4><p>对于一个关系的函数依赖集合，BCNF 要求所有左侧的属性集都包含任意一个候选码。</p><img src="/img/052.png" alt=""><p>例如上图左侧的关系，假设每位教师只教一门课程，每门课程可以有若干教师讲授，那么每位学生选修某门课程就对应一位教师。存在函数依赖 Tno → Cno, (Sno, Cno) → Tno, (Sno, Tno) → Cno，候选码是 (Sno, Cno), (Sno, Tno)，不存在非平凡的函数依赖，满足 3NF，但是 Tno 不包含任何一个候选码，不属于 BCNF。</p><ul>    <li>满足 BCNF，一定满足 3NF</li>    <li>满足 3NF 并且只有一个候选码，一定满足 BCNF</li></ul><ul>    <li>所有非主属性都完全函数依赖于每个候选键</li>    <li>所有主属性都完全函数依赖于每个不包含它的候选键</li>    <li>没有任何属性完全函数依赖于非候选键的任何一组属性</li></ul><h2 id="数据依赖的公理系统-Armstrong-System"><a href="#数据依赖的公理系统-Armstrong-System" class="headerlink" title="数据依赖的公理系统 Armstrong System"></a>数据依赖的公理系统 Armstrong System</h2><h3 id="逻辑蕴含定理"><a href="#逻辑蕴含定理" class="headerlink" title="逻辑蕴含定理"></a>逻辑蕴含定理</h3><ul>    <li>如果 Y 包含于 X，则 X → Y</li>    <li>如果 X → Y，则 XZ → YZ</li>    <li>如果 X → Y 并且 Y → X，则 X → Z</li>    <li>如果 X → Y 并且 X → Z，则 X → Z</li>    <li>如果 X → Y 并且 Z 属于 Y，则 X → Z</li>    <li>如果 X → Y 并且 YW → Z，则 XW → Z</li></ul><p>例如依赖集合 {𝑈1 → 𝑈2𝑈3, 𝑈3𝑈4 → 𝑈5𝑈6}，判断 𝑈1𝑈4 → 𝑈6是否正确<br>① 𝑈1 → 𝑈2𝑈3 &#x3D;&gt; 𝑈1 → 𝑈3<br>② 𝑈1 → 𝑈3, 𝑈3𝑈4 → 𝑈5𝑈6 &#x3D;&gt; 𝑈1𝑈4 → 𝑈5𝑈6<br>③ 𝑈1𝑈4 → 𝑈5𝑈6 &#x3D;&gt; 𝑈1𝑈4 → 𝑈6</p><h3 id="属性依赖闭包"><a href="#属性依赖闭包" class="headerlink" title="属性依赖闭包"></a>属性依赖闭包</h3><p>U &#x3D; {A<sub>1</sub>, A<sub>2</sub>, ⋯, A<sub>n</sub>} 是关系模式 R 中所有属性的集合，F 是 U 上的一组函数依赖(即 R 的函数依赖集)，X ⊆ U，Y ⊆ U,<br>X<sub>F</sub><sup>+</sup> &#x3D; {A<sub>i</sub> | X → A<sub>i</sub>}，称为该属性的依赖闭包。</p><img src="/img/053.png" alt=""><img src="/img/054.png" alt=""><p>① 加入 A<sub>1</sub>, A<sub>5</sub><br>② 找到左侧是 A<sub>1</sub>, A<sub>5</sub> 的子集的函数依赖<br>③ 加入 A<sub>3</sub>, A<sub>4</sub><br>④ 找到左侧是 A<sub>1</sub>, A<sub>3</sub>, A<sub>4</sub>, A<sub>5</sub> 的子集的函数依赖<br>⑤ 加入 A<sub>6</sub><br>⑥ 找到左侧是 A<sub>1</sub>, A<sub>3</sub>, A<sub>4</sub>, A<sub>5</sub>, A<sub>6</sub> 的子集的函数依赖<br>⑦ 没有变化，退出循环。结果为 {A<sub>1</sub>, A<sub>3</sub>, A<sub>4</sub>, A<sub>5</sub>, A<sub>6</sub>}</p><h3 id="函数依赖闭包"><a href="#函数依赖闭包" class="headerlink" title="函数依赖闭包"></a>函数依赖闭包</h3><p>在检验范式时，仅考虑给定的函数依赖集是不充分的，还需要考虑在给定的模式上成立的所有函数依赖关系。函数依赖集合 F，称 F<sup>+</sup> 为 F 所能推得的全部函数依赖的集合，一般 F<sup>+</sup> 中会有大量的重复函数依赖规则。</p><p>F &#x3D; {A → B, B → C}, 求 F<sup>+</sup></p><p>① 构造二维表</p><img src="/img/055.png" alt="" style="height: 300px;"><p>② 计算所有属性组合的属性集闭包，将表格中包括在对应属性闭包里的属性都勾选出来</p><img src="/img/056.png" alt="" style="height: 300px;"><p>表格中任何一个 √ 都是一个函数依赖。</p><h3 id="求解关系的候选键"><a href="#求解关系的候选键" class="headerlink" title="求解关系的候选键"></a>求解关系的候选键</h3><ul>    <li><strong>L 类属性：</strong>只在 F 中某个函数依赖的左部出现。</li>    <li><strong>R 类属性：</strong>只在 F 中某个函数依赖的右部出现。</li>    <li><strong>LR 类属性：</strong>在 F 中某个函数依赖的左部和右部均出现。</li>    <li><strong>N 类属性：</strong>在 F 中每个函数依赖左部和右部均不出现。</li></ul><p>求解候选键的核心思路：</p><ul>    <li>求解 L 和 N 类属性</li>    <li>若 (L, N)<sup>+</sup> = U，则 (L, N) 为唯一候选键</li>    <li>若 (L, N)<sup>+</sup> ≠ U，则找 LR 类</li>    <li>若 (L, N, LR)<sup>+</sup> = U，则 (L, N, LR) 为候选键</li></ul><img src="/img/057.png" alt=""><p>① L &#x3D; {A<sub>1</sub>}, N &#x3D; {}, LR &#x3D; {A<sub>2</sub>, A<sub>3</sub>, A<sub>4</sub>}<br>② 令 X &#x3D; L, Y &#x3D; LR<br>③ 计算 X 的闭包: X<sub>F</sub><sup>+</sup> &#x3D; {A<sub>1</sub>} ≠ U<br>④ 遍历 Y 中的单一属性，并与 X 构成属性组，后计算闭包</p><ul>    <li>XA<sub>2</sub><sup>F</sup> = (A1A2)<sup>F</sup> &rarr; A<sub>1</sub>A<sub>2</sub>A<sub>3</sub>A<sub>4</sub>A<sub>5</sub>A<sub>6</sub>，因此 {A<sub>1</sub>, A<sub>2</sub>} 是候选键</li>    <li>XA<sub>3</sub><sup>F</sup> = (A1A3)<sup>F</sup> &rarr; A<sub>1</sub>A<sub>2</sub>A<sub>3</sub>A<sub>4</sub>A<sub>5</sub>A<sub>6</sub>，因此 {A<sub>1</sub>, A<sub>3</sub>} 是候选键</li>    <li>XA<sub>4</sub><sup>F</sup> = (A1A4)<sup>F</sup> &rarr; A<sub>1</sub>A<sub>2</sub>A<sub>3</sub>A<sub>4</sub>A<sub>5</sub>A<sub>6</sub>，因此 {A<sub>1</sub>, A<sub>4</sub>} 是候选键</li></ul><h2 id="关系模式分解"><a href="#关系模式分解" class="headerlink" title="关系模式分解"></a>关系模式分解</h2><h3 id="最小函数依赖集"><a href="#最小函数依赖集" class="headerlink" title="最小函数依赖集"></a>最小函数依赖集</h3><ul>    <li>函数依赖的右侧只有单个属性</li>    <li>没有多余的函数依赖</li>    <li>函数依赖左侧没有多余的属性</li></ul><p>计算最小函数依赖集</p><ul>    <li>右部属性拆开：A → BC => A → B, A → C</li>    <li>左侧属性拆开：如果其他规则可以推得左侧属性集中的属性，删掉</li>    <li>如果有冗余规则，删掉</li></ul><h3 id="关系模式分解的定义"><a href="#关系模式分解的定义" class="headerlink" title="关系模式分解的定义"></a>关系模式分解的定义</h3><ul>    <li>关系不丢失</li>    <li>模式不冗余</li>    <li>依赖不丢失</li></ul><p>数据等价：分解具有无损连接性(lossless join)，无损连接是指分解后的关系通过自然连接可以恢复分解前的关系，即通过自然连接得到的关系与分解前的关系相比，既不多出信息、又不丢失信息。</p><p>语义等价：分解要保持函数依赖(preserve functional dependency)。因此关系模式等价分解既要保持函数依赖，又要具有无损连接性。</p><p>无损的模式分解要求分解后关系<strong>自然连接</strong>的结果完全等同于原关系</p><h3 id="无损分解"><a href="#无损分解" class="headerlink" title="无损分解"></a>无损分解</h3><ul>    <li>构建二维表格，纵向为关系，横向为属性</li>    <li>一行一行看，分解后关系所在行，将包含的属性置为 1，其余为 0</li>    <li>遍历全部函数依赖，对于依赖 A → B，如果 A 所属列全部为 1，则将 B 所属列全部置为 1</li>    <li>如果最后有任意一行全部为 1，说明是无损分解</li></ul><img src="/img/058.png" alt=""><img src="/img/059.png" alt=""><img src="/img/060.png" alt=""><h3 id="函数依赖保持"><a href="#函数依赖保持" class="headerlink" title="函数依赖保持"></a>函数依赖保持</h3><img src="/img/061.png" alt=""><ul>    <li>若一个分解具有无损连接性，则它能够保证不丢失信息</li>    <li>若一个分解保持了函数依赖，则它可以减轻或者解决各种异常情况</li>    <li>然而，无损分解和保持函数依赖的分解是两个相互独立的标准</li>    <li>具有无损连接性的分解不一定能够保持函数依赖</li>    <li>保持函数依赖的分解也不一定是无损分解</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>DataBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库八股文——E-R模型</title>
    <link href="/2024/12/18/DataBase3/"/>
    <url>/2024/12/18/DataBase3/</url>
    
    <content type="html"><![CDATA[<h1 id="E-R-模型"><a href="#E-R-模型" class="headerlink" title="E-R 模型"></a>E-R 模型</h1><link rel="stylesheet" href="/css/DataBase_RelationModel.css"><h2 id="数据模型概述"><a href="#数据模型概述" class="headerlink" title="数据模型概述"></a>数据模型概述</h2><p>数据库结构的基础是数据模型，它是描述数据(数据结构)、数据之间的联系，<span class="just_red">数据语义</span>即<span class="just_red">数据操作</span>，以及一致性(完整性)约束的概念和工具的集合。</p><img src="/img/040.png" alt="" style="height: 260px; margin-bottom: 20px;"><table>    <tr>        <th>概念数据模型</th>        <th>逻辑数据模型</th>        <th>物理数据模型</th>    </tr>    <tr>        <td>实体(Entity)</td>        <td>实体(Entity)</td>        <td>表(table)</td>    </tr>    <tr>        <td>--</td>        <td>属性(Attribute)</td>        <td>列(Column)</td>    </tr>    <tr>        <td>--</td>        <td>标识符(Primary/Foreign Identifier)</td>        <td>键(Primary/Foreign Key)</td>    </tr>    <tr>        <td>关系</td>        <td>关系(Relation)</td>        <td>参照完整性约束(Reference)</td>    </tr></table><h2 id="E-R-模型的基本元素"><a href="#E-R-模型的基本元素" class="headerlink" title="E-R 模型的基本元素"></a>E-R 模型的基本元素</h2><h3 id="实体-Entity"><a href="#实体-Entity" class="headerlink" title="实体(Entity)"></a>实体(Entity)</h3><p>一个实体(Entity)可以表示对于组织机构的业务非常重要的事物及其相关的信息集合，实体一般用集合名词或名词词组来表示，因此，实体也被称为实体集(Entity Set)。</p><h3 id="实体实例-Entity-Instance"><a href="#实体实例-Entity-Instance" class="headerlink" title="实体实例(Entity Instance)"></a>实体实例(Entity Instance)</h3><p>实体实例是实体的一个具体出现，或者说是实体的一个具体的记录值。</p><div class="just_red">实体对应类，实体示例对应对象。</div><h3 id="属性-Attribute"><a href="#属性-Attribute" class="headerlink" title="属性(Attribute)"></a>属性(Attribute)</h3><p>一个实体的所有实体实例，都具有相同的性质特征。使用属性来描述实体的性质特征，就像类内的属性一样。实体具有哪些属性，是根据用户对信息的需求来决定的。</p><h4 id="实体的标识符"><a href="#实体的标识符" class="headerlink" title="实体的标识符"></a>实体的标识符</h4><p>在描述实体的属性中，存在一组属性(可以是单个属性，也可以是多个属性)，使用这组属性的特征，可以唯一地标识客观世界中的特定实体实例。如果这组属性不可约(减少任何一个属性)，就不能再唯一地标识这个特定实体实例，那么我们说，这组属性是候选的实体的<span class="just_red">标识符(Identifier)</span>。</p><p>一个实体可能有多个候选的实体标识符。选择其中一组作为该实体的<span class="just_red">主实体标识符(Primary Identifier)</span>，其余的候选的实体标识符称为<span class="just_red">辅助的实体标识符(Auxiliary Identifier)</span>。</p><div class="sub_title">在多个候选的实体标识符中选择一个作为主标识符的标准(Bruce1992)</div><ul>    <li>选择在实体实例的生命周期内不会被改变其值的属性作为标识符</li>    <li>选择实体实例中有有效值且不为空(或未知)的属性作为标识符。如果标识符是个复合属性，则    要确保组成标识符的所有属性的属性值都有效</li>    <li>避免使用可以表示分类、位置信息等所谓的智能标识符(或键) </li>    <li>尽量使用单一属性代理标识符替代复合属性标识符</li></ul><h4 id="属性的分类"><a href="#属性的分类" class="headerlink" title="属性的分类"></a>属性的分类</h4><p>E-R 模型中的属性可以不是原子值，原子值指简单属性 + 单值属性。</p><h5 id="简单属性-复合属性-Simple-Attribute-Composite-Attribute"><a href="#简单属性-复合属性-Simple-Attribute-Composite-Attribute" class="headerlink" title="简单属性&#x2F;复合属性 Simple Attribute &#x2F; Composite Attribute"></a>简单属性&#x2F;复合属性 Simple Attribute &#x2F; Composite Attribute</h5><p>简单属性：不能划分为更小部分的属性<br>复合属性：由若干个有意义的详细属性组合成的属性</p><p>例如：<br><span class="sub_title">年龄</span>是一个简单属性，因为其不能再划分为更小的部分<br><span class="sub_title">简历</span>是一个复合属性，因为其可以继续分成姓名、年龄、学历等属性</p><h5 id="单值属性-多值属性-single-valued-multi-valued"><a href="#单值属性-多值属性-single-valued-multi-valued" class="headerlink" title="单值属性&#x2F;多值属性 single-valued &#x2F; multi-valued"></a>单值属性&#x2F;多值属性 single-valued &#x2F; multi-valued</h5><p>单值属性：属性对一个特定实体都只有单独的一个值<br>多值属性：属性对某个特定实体而言，可能对应于一组值</p><p>用 {} 将属性名包起来表示该属性为多值属性</p><p>例如：<br><span class="sub_title">学号</span>是一个单值属性，因为每一个实体实例只能拥有一个学号<br><span class="sub_title">手机号</span>是一个多值属性，因为每一个实体实例可以拥有多个手机号</p><h5 id="必要属性-可选属性-Mandatory-Attribute-Optional-Attribute"><a href="#必要属性-可选属性-Mandatory-Attribute-Optional-Attribute" class="headerlink" title="必要属性&#x2F;可选属性 Mandatory Attribute &#x2F; Optional Attribute"></a>必要属性&#x2F;可选属性 Mandatory Attribute &#x2F; Optional Attribute</h5><p>必要属性：每个实体实例必须存在的属性<br>可选属性：每个实体实例可以为空值的属性</p><p><span class="sub_title">身份证号</span>是一个必要属性，因为身份证号必须填写<br><span class="sub_title">性别</span>是一个可选属性，因为性别可以不填写</p><h5 id="存储属性-派生属性-Stored-Attribute-Derive-Attribute"><a href="#存储属性-派生属性-Stored-Attribute-Derive-Attribute" class="headerlink" title="存储属性&#x2F;派生属性 Stored Attribute &#x2F; Derive Attribute"></a>存储属性&#x2F;派生属性 Stored Attribute &#x2F; Derive Attribute</h5><p>派生属性：值从别的相关属性或实体派生出来<br>存储属性：不属于派生属性</p><p>派生属性可以定期计算并存储，也可以完全不存储，等需要时计算。</p><p><span class="sub_title">出生年份</span>是一个派生属性，因为出生年份可以通过当前日期减去年龄算出<br><span class="sub_title">年龄</span>是一个存储属性，因为它不是派生属性</p><h5 id="复杂属性-Complex-Attribute"><a href="#复杂属性-Complex-Attribute" class="headerlink" title="复杂属性 Complex Attribute"></a>复杂属性 Complex Attribute</h5><p>复杂属性：复合属性和多值属性通过嵌套方式组合构成</p><p>用 () 将复合属性的各个组成部分包起来，用逗号分隔。</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p>联系是客观世界中，事物内部或者事物之间的规则。数据规则表示的是数据间如何关联，行为规则表示当属性为某个特殊值时，应当进行何种操作。E-R模型可以建模数据规则，但不能建模行为规则。</p><h4 id="结构完整性规则-基数约束规则"><a href="#结构完整性规则-基数约束规则" class="headerlink" title="结构完整性规则(基数约束规则)"></a>结构完整性规则(基数约束规则)</h4><h5 id="最大基数约束规则"><a href="#最大基数约束规则" class="headerlink" title="最大基数约束规则"></a>最大基数约束规则</h5><p>一个联系的最大基数是指：实体 B 中的实体实例可以和实体 A 中的实体实例发生关联的最大个数</p><ul>    <li>一对一</li>    <li>一对多/多对一</li>    <li>多对多</li></ul><ul>    <li>一个教师只能指导一个学生，一个学生只能被一个教师所指导</li>    <li>一个教师可以指导多个学生，一个学生只能被一个教师所指导</li>    <li>一个教师可以指导多个学生，一个学生可以被多个教师所指导</li></ul><h5 id="最小基数约束规则"><a href="#最小基数约束规则" class="headerlink" title="最小基数约束规则"></a>最小基数约束规则</h5><p>一个联系的最小基数是指：实体 B 中的实体实例可以和实体 A 中的实体实例发生关联的最小个数。</p><ul>    <li>部分参与</li>    <li>完全参与</li></ul><ul>    <li>一个教师可以指导学生，也可以不指导学生</li>    <li>一个教师至少指导一个学生</li></ul><h4 id="参照完整性约束规则"><a href="#参照完整性约束规则" class="headerlink" title="参照完整性约束规则"></a>参照完整性约束规则</h4><p>参照完整性约束规则确保属性取值的有效性，只能取所参照的实体对应属性中存在的值。</p><p>参照完整性大多是人为规定的，不能在 E-R 模型中表示出来。</p><h4 id="联系实例"><a href="#联系实例" class="headerlink" title="联系实例"></a>联系实例</h4><p>联系和联系实例类似于实体和实体实例</p><ul>    <li>人类是一个实体，陈髋髋是一个实体实例</li>    <li>老师指导学生的指导是一个联系，陈宽宽老师指导陈髋髋学生是一个联系实例</li></ul><h4 id="联系的描述性属性-关联"><a href="#联系的描述性属性-关联" class="headerlink" title="联系的描述性属性(关联)"></a>联系的描述性属性(关联)</h4><p>联系的描述性属性描述联系本身的特征，联系的属性本身不属于任何一个实体，仅仅用来描述联系的特征。</p><p>关联本身没有标识符，关联适合用来建模一次性的联系，而不是多次同类的联系。例如老师和学生之间的指导关系，教师成为学生的导师可以使用关联描述(是导师&#x2F;不是导师)，成为导师后多次指导学生，每次指导过程为同类联系，不能用关联建模。</p><h4 id="联系的度"><a href="#联系的度" class="headerlink" title="联系的度"></a>联系的度</h4><p>联系的度指参与联系的实体的个数，称为 n 元关系。</p><img src="/img/041.png" alt="" style="height: 500px;"><h4 id="关联实体"><a href="#关联实体" class="headerlink" title="关联实体"></a>关联实体</h4><p>联系是一个动词，关联实体是一个动名词。</p><p>教师指导学生做项目是一个三元关系，其中三个实体是教师、学生、项目。<br>将指导行为转变成指导活动，将三元关系转换成三个二元关系。</p><p>本质是将关联提升为一个关联实体，关联实体是由行为动作<span class="just_red">名词化</span>而抽象出来的实体。此时，关联实体具有一个自己的标识符。</p><h4 id="实体参与联系的角色"><a href="#实体参与联系的角色" class="headerlink" title="实体参与联系的角色"></a>实体参与联系的角色</h4><p>当参与一个联系的多个实体名字不同时，角色是隐含的<br>当参与一个联系的多个实体名字相同时，需要为实体集指定参与联系的角色名</p><ul>    <li>递归联系：课程和课程的先修/后修关系</li>    <li>同一组实体之间的多种联系：员工和企业的工作/股份关系</li></ul><h3 id="强实体和弱实体"><a href="#强实体和弱实体" class="headerlink" title="强实体和弱实体"></a>强实体和弱实体</h3><p>弱实体集是指在数据库中不能独立存在的实体集，它的存在依赖于另一个称为“强实体集”的实体集。弱实体集没有主键属性(Primary Key)，而是通过与强实体集的关系以及自身的部分属性(称为部分键)来唯一标识其实体。</p><img src="/img/042.png" alt="" style="width: 100%;"><p>弱实体集特点：</p><ul>    <li>依赖性：弱实体集依赖于强实体集存在。每个弱实体都<span class="just_red">必须与一个强实体关联</span>，才能存在。</li>    <li>部分键：弱实体集使用<span class="just_red">部分键(Partial Key)</span>来区分不同的弱实体。部分键在弱实体集内部是唯一的，但不能单独作为唯一标识符，需要结合强实体集的主键一起使用。</li>    <li>标识关系：弱实体集和强实体集之间存在一种称为<span class="just_red">标识关系(Identifying Relationship)</span>的特殊关系。这种关系帮助弱实体集通过引用强实体集的主键来唯一标识自身的实例。</li></ul><p>E-R 图中，用双矩形框表示弱实体，标识关系用双菱形标识，部分键用虚线下划线表示。</p><img src="/img/043.png" alt="" style="width: 100%;"><p>在关系数据库中，弱实体集通常通过外键约束来实现，确保弱实体集中的实体只能在与强实体集关联时存在。</p><h2 id="E-R-模型和关系模型的转换"><a href="#E-R-模型和关系模型的转换" class="headerlink" title="E-R 模型和关系模型的转换"></a>E-R 模型和关系模型的转换</h2>]]></content>
    
    
    
    <tags>
      
      <tag>DataBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库八股文——关系数据库习题</title>
    <link href="/2024/12/17/DataBase_practice1/"/>
    <url>/2024/12/17/DataBase_practice1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>赛博错题本，来源于书籍《新编 数据库原理习题与解析》</p></blockquote><h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><link rel="stylesheet" href="/css/DataBase_RelationModel.css"><div id="image-container1"></div><script>    const container = document.getElementById('image-container1');    let wrong = [9, 14, 37, 44, 48, 49, 50];    let total = 50;    for (let i = 1; i <= total; i++) {        const img = document.createElement('img');         img.src = `/img/2_${i}.png`;           img.alt = `Image ${i}`;        img.classList.add('dmx_img');        if (wrong.findIndex(item => item === i) !== -1) {            img.style.border = '2px solid red';        }        else {            img.style.border = '2px solid green';        }        container.appendChild(img);    }</script><h2 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h2><div id="image-container2"></div><script>    const container = document.getElementById('image-container1');    </script>]]></content>
    
    
    
    <tags>
      
      <tag>DataBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库八股文——关系代数</title>
    <link href="/2024/12/16/DataBase2/"/>
    <url>/2024/12/16/DataBase2/</url>
    
    <content type="html"><![CDATA[<h2 id="简单专门关系代数"><a href="#简单专门关系代数" class="headerlink" title="简单专门关系代数"></a>简单专门关系代数</h2><link rel="stylesheet" href="/css/DataBase_RelationModel.css"><p>关系代数是施加于关系之上的一组集合代数运算，每个运算都以一个或多个关系作为运算对象，并生成另外一个关系作为该关系运算的结果。</p><h3 id="选择运算"><a href="#选择运算" class="headerlink" title="选择运算"></a>选择运算</h3><img src="/img/007.png" alt="" style="height: 50px; border: 3px solid skyblue;"><p>选择运算为一元运算，其中 p 为谓词语句，R 为输入的关系，结果是 R 中所有符合谓词语句 p 的元组构成的新关系。</p><h3 id="投影运算"><a href="#投影运算" class="headerlink" title="投影运算"></a>投影运算</h3><img src="/img/009.png" alt="" style="height: 50px; border: 3px solid skyblue;"><p>投影运算为一元运算，其中 (A<sub>1</sub>, A<sub>2</sub>, …, A<sub>n</sub>) 为输入的属性列表，R 为输入的关系，结果是 R 中所有元组的 A<sub>1</sub>, A<sub>2</sub>, …, A<sub>n</sub> 列构成的新关系。</p><h2 id="复杂专门关系代数"><a href="#复杂专门关系代数" class="headerlink" title="复杂专门关系代数"></a>复杂专门关系代数</h2><h3 id="重命名运算"><a href="#重命名运算" class="headerlink" title="重命名运算"></a>重命名运算</h3><img src="/img/013.png" alt="" style="height: 44px; border: 3px solid skyblue;"><p>重命名运算为一元运算，其中 R 为输入的关系，S 为要修改的关系名，(A<sub>1</sub>, A<sub>2</sub>, …, A<sub>n</sub>) 为依次要修改的属性名。<br>也可以不传入 (A<sub>1</sub>, A<sub>2</sub>, …, A<sub>n</sub>) 参数，表示只需要修改关系名。</p><p>有点巧妙，放这里了<br>查找最高工资的关系代数表达式：</p><img src="/img/014.png" alt="" style="height: 100px;"><p>通过位置标记也可以获取第 i 个属性，使用关键字 $。</p><img src="/img/015.png" alt="" style="height: 45px;"><h3 id="连接运算"><a href="#连接运算" class="headerlink" title="连接运算"></a>连接运算</h3><img src="/img/017.png" alt="" style="height: 50px; border: 3px solid skyblue;"><h4 id="第一种连接"><a href="#第一种连接" class="headerlink" title="第一种连接"></a>第一种连接</h4><img src="/img/018.png" alt="" style="height: 40px; border: 3px solid skyblue;"><p>先求笛卡尔积，再进行选择运算，其中选择运算的谓词语句和连接的谓词语句相同。</p><h4 id="第二种连接"><a href="#第二种连接" class="headerlink" title="第二种连接"></a>第二种连接</h4><img src="/img/019.png" alt="" style="height: 40px; border: 3px solid skyblue;"><p>先求笛卡尔积，再进行选择运算，其中选择运算的谓词语句和连接的谓词语句相同。</p><h4 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h4><img src="/img/020.png" alt="" style="height: 50px; border: 3px solid skyblue;"><p>先求笛卡尔积，再找到 R 和 S 的<span style="color: red;">公共属性</span>，例如为 (A<sub>1</sub>, A<sub>2</sub>, …, A<sub>n</sub>)，通过谓词语句 R.A<sub>1</sub> &#x3D; S.A<sub>1</sub> … R.A<sub>n</sub> &#x3D; S.A<sub>n</sub> 筛选出符合要求的元组。</p><p>对于两个关系 R, S，我们称 R 的悬浮元组为不满足 R.A<sub>1</sub> &#x3D; S.A<sub>1</sub> … R.A<sub>n</sub> &#x3D; S.A<sub>n</sub> 的元组，S 同理。</p><p><span style="color: red;">外连接</span> 可以将悬浮元组保留表中，在其他属性上填写 NULL。<br><span style="color: red;">左外连接</span> 可以将左关系 R 悬浮元组保留表中，在其他属性上填写 NULL。<br><span style="color: red;">右外连接</span> 可以将右关系 S 悬浮元组保留表中，在其他属性上填写 NULL。</p><p>自然连接结果属性出现的顺序为：相同属性 &gt; 只属于第一个关系的属性 &gt; 只属于第二个关系的属性。</p><p>代数运算表示，但是我不想看：</p><img src="/img/021.png" alt="" style="height: 300px;"><h3 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h3><img src="/img/022.png" alt="" style="height: 35px; border: 3px solid skyblue;"><p>E 为关系代数表达式，T 为临时关系变量，通过赋值运算可以分解复杂的关系代数表达式，使查询变得简单。</p><img src="/img/023.png" alt="" style="height: 60px;"><h3 id="除运算"><a href="#除运算" class="headerlink" title="除运算"></a>除运算</h3><img src="/img/024.png" alt="" style="height: 50px; border: 3px solid skyblue;"><p>假设有两个关系 R(X, Y), S(Z) 其中，Y 和 Z 有相容性。</p><p>则 R(X, Y) ÷ S(Z) 为：<br>1 结果的属性集为 X，且是 R 中 X 的一个子集<br>2 保留下来的元组和 S(Z) 求笛卡尔积，得到的结果必须包含于 R(X, Y)<br>3 S 中的属性必须包含于 R 中</p><h3 id="去重运算"><a href="#去重运算" class="headerlink" title="去重运算"></a>去重运算</h3><img src="/img/025.png" alt="" style="height: 45px; border: 3px solid skyblue;"><p>去重运算可以去除关系中的重复元组，并返回去重之后的关系。</p><h3 id="广义投影运算"><a href="#广义投影运算" class="headerlink" title="广义投影运算"></a>广义投影运算</h3><img src="/img/026.png" alt="" style="height: 45px; border: 3px solid skyblue;"><p>允许在投影列表中使用算术运算和字符串函数等来对投影运算进行扩展，写过 miniob 都说好。</p><h3 id="聚集运算"><a href="#聚集运算" class="headerlink" title="聚集运算"></a>聚集运算</h3><img src="/img/027.png" alt="" style="height: 45px; border: 3px solid skyblue;"><p>其中 A<sub>1</sub>, A<sub>2</sub>, …, A<sub>k</sub> 为 R 中的属性列，F 为作用在属性 A 上的聚集函数，例如 count, sum, avg, min, max 等。</p><p>通过书法体 G 还可以完成 SQL 语句中的 GROUP BY 功能。</p><p>通过 distinct 关键字也可以完成去重功能，例如聚集函数 count-distionct。</p><img src="/img/029.png" alt="" style="height: 50px; border: 3px solid skyblue;">   <p>其中 G<sub>1</sub>, G<sub>2</sub>, …, G<sub>n</sub> 为属性集合，要求根据属性集合分组后，同一组的属性集合取值一样，不同组的属性集合取值不一样。也即，各组属性可以通过 G<sub>1</sub>, G<sub>2</sub>, …, G<sub>n</sub> 来唯一区分。</p><p>G<sub>1</sub>, G<sub>2</sub>, …, G<sub>n</sub> 为可选参数，如果不填写该参数，将所有元组视作一个组别。</p><h3 id="排序运算"><a href="#排序运算" class="headerlink" title="排序运算"></a>排序运算</h3><img src="/img/030.png" alt="" style="height: 50px; border: 3px solid skyblue;"><p>其中 A<sub>1</sub>, A<sub>2</sub>, …, A<sub>k</sub> 为 R 中的属性列，按照顺序依次对元组进行排序。</p><h2 id="传统集合运算"><a href="#传统集合运算" class="headerlink" title="传统集合运算"></a>传统集合运算</h2><h3 id="关系的相容性"><a href="#关系的相容性" class="headerlink" title="关系的相容性"></a>关系的相容性</h3><p>关系 R 和 关系 S 相容的充分必要条件是：</p><ol><li>R 和 S 中的属性个数相同</li><li>R 和 S 中属性存在一一对应关系</li><li>R 和 S 中的对应属性的域相同</li></ol><h3 id="并运算"><a href="#并运算" class="headerlink" title="并运算"></a>并运算</h3><img src="/img/010.png" alt="" style="height: 40px; border: 3px solid skyblue;"><p>并运算为二元运算，其中 R, S 为输入的两个<span style="color: red;">相容</span>关系，结果是 R 和 S 的并集。</p><h3 id="交运算"><a href="#交运算" class="headerlink" title="交运算"></a>交运算</h3><img src="/img/015.png" alt="" style="height: 45px; border: 3px solid skyblue;"><p>交运算为二元运算，其中 R, S 为输入的两个<span style="color: red;">相容</span>关系，结果是 R 和 S 的交集。</p><h3 id="差运算"><a href="#差运算" class="headerlink" title="差运算"></a>差运算</h3><img src="/img/011.png" alt="" style="height: 45px; border: 3px solid skyblue;"><p>差运算为二元运算，其中 R, S 为输入的两个<span style="color: red;">相容</span>关系，结果是 R 和 S 的差集。</p><h3 id="笛卡儿积运算"><a href="#笛卡儿积运算" class="headerlink" title="笛卡儿积运算"></a>笛卡儿积运算</h3><img src="/img/012.png" alt="" style="height: 42px; border: 3px solid skyblue;"><p>笛卡儿积运算为二元运算，其中 R, S 为输入的两个关系，结果是 R 和 S 的笛卡尔积。<br>若关系 R 是 m 度关系，有 x 个元组；关系 S 是 n 度关系，有 y 个元组；则笛卡尔积为 m + n 度关系，元组个数为 x × y。</p><p>换句话说，一个关系一定是：其所有属性的域的笛卡儿积的一个子集。</p><h2 id="关系演算语言"><a href="#关系演算语言" class="headerlink" title="关系演算语言"></a>关系演算语言</h2><h3 id="元组关系演算语言"><a href="#元组关系演算语言" class="headerlink" title="元组关系演算语言"></a>元组关系演算语言</h3><img src="/img/031.png" alt="" style="height: 42px; border: 3px solid skyblue;"><p>P 是原子公式，有以下三种形式：</p><img src="/img/032.png" alt="" style="height: 42px; border: 3px solid skyblue;"> <p>其中 t 为元组变量，R 为关系。</p><img src="/img/033.png" alt="" style="height: 42px; border: 3px solid skyblue;"> <p>其中 t, s 为元组变量，x, y 为关系中在元组 t, s 下的属性。</p><img src="/img/034.png" alt="" style="height: 42px; border: 3px solid skyblue;"> <p>其中 c 是属于 x 域中的常量。</p><h3 id="域关系演算语言"><a href="#域关系演算语言" class="headerlink" title="域关系演算语言"></a>域关系演算语言</h3><img src="/img/035.png" alt="" style="height: 42px; border: 3px solid skyblue;"><p>其中 x<sub>1</sub>, x<sub>2</sub>, …, x<sub>k</sub> 是域变量或者域常量。</p><blockquote><p>元组关系演算语言和域关系演算语言不是很好理解，下面附上一道例题</p></blockquote><img src="/img/036.png" alt="" style="height: 400px;"><img src="/img/037.png" alt="" style="height: 250px;"><p>感觉不太好用言语形容为什么做出来的答案是这样（尤其是域关系演算），多做题吧。</p><p>同时，关系代数表达式也有自己的优先级：</p><img src="/img/038.png" alt="" style="width: 100%;">]]></content>
    
    
    
    <tags>
      
      <tag>DataBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库八股文——关系模型的基本概念</title>
    <link href="/2024/12/15/DataBase1/"/>
    <url>/2024/12/15/DataBase1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/css/DataBase_RelationModel.css"><h2 id="关系、关系模式、关系实例的定义"><a href="#关系、关系模式、关系实例的定义" class="headerlink" title="关系、关系模式、关系实例的定义"></a>关系、关系模式、关系实例的定义</h2><p>一个 <span class="important">关系</span> 对应一张 <span class="important">表格</span></p><p>引入关系的目标是更数学化，规范化的描述一张表格</p><p>例如对于下面的表格：</p><img src="/img/001.png" alt="" style="height: 300px;"><p><span class="sub_title">① 关系的属性和属性值</span></p><p>关系中的每一列中的数据都属于某个域中（域是属性的取值范围），并有一个独特的名字称为属性名，关系中具体的值是属性值。ID 是属性名，该列的域为无符号整数域，10101为属性值。</p><p>域是一个集合，集合的个数成为域的基数。</p><p><span class="sub_title">② 关系的元组</span></p><p>关系的每一行称为属于关系的一个元组，关系包含的元组集合是所有域笛卡尔积的子集。元组的每一个值叫做一个分量。(12121, Wu, Finance, 90000) 为一个元组</p><p><span class="sub_title">③ 关系的度&#x2F;目</span></p><p>关系的属性个数称为关系的度/目。上述关系是一个四度关系。</p><p><span class="important">关系模式</span></p><p>关系可用 <span class="important">R(A<sub>1</sub>:D<sub>1</sub>, A<sub>2</sub>:D<sub>2</sub>, ..., A<sub>n</sub>:D<sub>n</sub>)</span> 来表示，这种描述又被称为关系模式。</p><p>其中 R 是关系的名字，A 是属性，D 是属性所对应的域，n 是关系的度或目， 关系中元组的数目称为关系的基数。</p><p>上述表格的描述为：table_name(ID: unsigned int, name: string, dept_name: string, salary: int)</p><p><span class="important">关系实例</span></p><p>关系模式是在关系模式下的一组元组，或者称一个确定的表格。</p><p>上述表格就是在关系模式 table_name(ID: unsigned int, name: string, dept_name: string, salary: int) 下的一个关系实例</p><h2 id="关系的特性"><a href="#关系的特性" class="headerlink" title="关系的特性"></a>关系的特性</h2><ul>    <li> <span class="sub_title">列的同质性：</span> 每一列的属性值属于同一个域</li>    <li> <span class="sub_title">行/列的互换等价性：</span>关系中区分行和列通过元组值与属性名，和顺序无关</li>    <li> <span class="sub_title">元组的不重复性：</span>不能存在两个完全一致的元组</li>    <li> <span class="sub_title">属性不可再分性（关系第一范式）：</span>属性不能再分成子属性，一个元组的各个分量的值只能为一个</li></ul><h2 id="关系的重要概念——码"><a href="#关系的重要概念——码" class="headerlink" title="关系的重要概念——码"></a>关系的重要概念——码</h2><h3 id="超码-Super-Key"><a href="#超码-Super-Key" class="headerlink" title="超码 Super Key"></a>超码 Super Key</h3><p><span class="sub_title">能够唯一标识一条记录的属性或属性集</span></p><p>标识性 + 非空性</p><img src="/img/002.png" alt="" style="height: 300px;"><p>超码：(学号, 课程名)，(学号，课程名，成绩)，(学号，课程名，性别，姓名)</p><h3 id="候选码-Candicate-Key"><a href="#候选码-Candicate-Key" class="headerlink" title="候选码 Candicate Key"></a>候选码 Candicate Key</h3><p><span class="sub_title">能够唯一标识一条记录的最小属性集（不含多余属性）</span></p><p>标识性 + 非空性 + 最小性</p><img src="/img/002.png" alt="" style="height: 300px;"><p>候选码：(学号, 课程名)，(课程名, 姓名)</p><h3 id="主码-Primary-Key"><a href="#主码-Primary-Key" class="headerlink" title="主码 Primary Key"></a>主码 Primary Key</h3><p><span class="sub_title">人为选择的候选码中的一个</span></p><p>标识性 + 非空性 + 最小性 + 唯一性</p><img src="/img/002.png" alt="" style="height: 300px;"><p>主码：(学号, 课程名)</p><h3 id="主属性-非主属性"><a href="#主属性-非主属性" class="headerlink" title="主属性&#x2F;非主属性"></a>主属性&#x2F;非主属性</h3><p><span class="sub_title">出现在候选码中的属性&#x2F;不出现在候选码中的属性</span></p><img src="/img/002.png" alt="" style="height: 300px;"><p>主属性：{学号，课程名，姓名}</p><p>非主属性：{成绩，性别}</p><h3 id="外码-Foreign-Key"><a href="#外码-Foreign-Key" class="headerlink" title="外码 Foreign Key"></a>外码 Foreign Key</h3><p><span class="sub_title">关系 R 中的一个属性组，它不是 R 的候选码，但它与另一个关系 S 的候选码相对应，则成这个属性组 R 的外码</span></p><img src="/img/003.png" alt="" style="height: 350px; margin-bottom: 15px;"><p>两个关系通常是靠外码连接起来的</p><p><span class="sub_title">超码，候选码，主码的关系</span></p><img src="/img/004.png" alt="" style="height: 300px;"><h2 id="关系中的数据约束"><a href="#关系中的数据约束" class="headerlink" title="关系中的数据约束"></a>关系中的数据约束</h2><h3 id="实体完整性约束——主码约束"><a href="#实体完整性约束——主码约束" class="headerlink" title="实体完整性约束——主码约束"></a>实体完整性约束——主码约束</h3><p>一个关系的主码不能取空值、重复值。</p><p>一个复合主码中的每一个属性均不能取空值。</p><p>只有关系才有实体完整性约束，对于查询结果（例如 SQL 语句的输出），不需要满足该约束。</p><h3 id="参照完整性约束——外码约束"><a href="#参照完整性约束——外码约束" class="headerlink" title="参照完整性约束——外码约束"></a>参照完整性约束——外码约束</h3><p>一个关系的外码可以取空值。</p><p>一个关系的外码如果是有效值，则必须包含于其对应另一个关系的主码的实际取值集合。</p><img src="/img/005.png" alt="" style="display: inline-block; height: 300px;"><img src="/img/006.png" alt="" style="display: inline-block; height: 200px;"><h3 id="用户完整性约束"><a href="#用户完整性约束" class="headerlink" title="用户完整性约束"></a>用户完整性约束</h3><p>用户针对具体的应用环境定义的完整性约束条件。</p><p>例如要求年龄在 0 ~ 100 之间，工资在 3000 ~ 6000 之间等。</p><h3 id="其他约束"><a href="#其他约束" class="headerlink" title="其他约束"></a>其他约束</h3><p>自增长约束、默认值约束、检查约束等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>DataBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库八股文——数据库概述</title>
    <link href="/2024/12/14/DataBase0/"/>
    <url>/2024/12/14/DataBase0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/css/DataBase_RelationModel.css"><h1 id="数据库概论"><a href="#数据库概论" class="headerlink" title="数据库概论"></a>数据库概论</h1><h2 id="数据库的功能"><a href="#数据库的功能" class="headerlink" title="数据库的功能"></a>数据库的功能</h2><ol><li>Storage Management: 存储数据</li><li>Query: 构建一条高效的查询路径</li><li>Execution Component: 根据查询所需的执行计划实际执行</li><li>Internal Management and Scheduling: 内部管理和调度</li><li>Management Tools Interfaces: 管理工具接口</li></ol><h2 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h2><h3 id="数据-Data"><a href="#数据-Data" class="headerlink" title="数据 Data"></a>数据 Data</h3><p>数据是指可以记录和存储在计算机介质上的关于对象和事件的事实，数据可以保存在文件系统和数据库中。</p><p>数据分为<span style="color: red;">结构化数据</span>和<span style="color: red;">非结构化数据</span>。</p><p>数据是指可以记录和存储在计算机介质上的关于对象和事件的事实。而信息是人们按照知识的方式处理后得到的数据。数据本身没有任何意义，只有通过某些操作将数据转化为信息才能被人们理解和利用。</p><h3 id="元数据-Metadata"><a href="#元数据-Metadata" class="headerlink" title="元数据 Metadata"></a>元数据 Metadata</h3><p>元数据是“数据的数据”，用于描述数据的特征或性质以及该数据的内容。例如数据的名称、长度、可能的取值；数据的来源、存储位置、使用方式。</p><p>元数据本身与数据独立，只用于描述数据的性质。</p><h3 id="文件系统存储数据的缺陷"><a href="#文件系统存储数据的缺陷" class="headerlink" title="文件系统存储数据的缺陷"></a>文件系统存储数据的缺陷</h3><section class="first_box">    <!-- title -->    <article class="title">Data Issues in Database Systems</article>    <!-- english -->    <article class="content">        <ul class="list">            <li>Data redundancy and inconsistency: Multiple file formats, duplication of information in different files.            </li>            <li>Difficulty in accessing data: Need to write a new program to carry out each new task.</li>            <li>Data isolation — multiple files and formats.</li>            <li>Integrity problems: Integrity constraints (e.g., account balance > 0) become “buried” in program code                rather than being stated explicitly and hard to add new constraints or change existing ones.</li>            <li>Atomicity of updates: Failures may leave database in an inconsistent state with partial updates carried                out. Example: Transfer of funds from one account to another should either complete or not happen at all.            </li>            <li>Concurrent access by multiple users: Concurrent access needed for performance. Uncontrolled concurrent                accesses can lead to inconsistencies. Example: Two people reading a balance (say 100) and updating it by                withdrawing money (say 50 each) at the same time.</li>            <li>Security problems: Hard to provide user access to some, but not all, data.</li>        </ul>    </article>    <!-- divide line -->    <div class="divider"></div>    <!-- chinese -->    <article class="content">        <div class="text">数据库系统中的数据问题</div>        <ul class="list">            <li>数据冗余和不一致：多种文件格式，信息在不同文件中重复。</li>            <li>数据访问困难：需要为每个新任务编写新的程序。</li>            <li>数据隔离 — 多种文件和格式。</li>            <li>完整性问题：完整性约束（例如，账户余额 > 0）被“埋”在程序代码中，而不是明确陈述，且很难添加新的约束或更改现有约束。</li>            <li>更新的原子性：故障可能会导致数据库处于不一致状态，并且部分更新已执行。例如：从一个账户转账到另一个账户应该要么完成，要么完全不发生。</li>            <li>多个用户并发访问：性能需要并发访问，未经控制的并发访问可能导致不一致。例如：两个人同时读取余额（例如100）并分别通过取款（例如每人50）来更新余额。</li>            <li>安全问题：很难为用户提供部分数据的访问权限，而不是全部数据。</li>        </ul>    </article></section><h3 id="数据库-DataBase"><a href="#数据库-DataBase" class="headerlink" title="数据库 DataBase"></a>数据库 DataBase</h3><p>数据库是长期存储在计算机内的、有组织的、可共享的大量数据集合。</p><h3 id="数据库系统-DBS"><a href="#数据库系统-DBS" class="headerlink" title="数据库系统 DBS"></a>数据库系统 DBS</h3><section class="first_box">    <!-- title -->    <article class="title">The Functions of a DBS</article>    <!-- english -->    <article class="content">        <ul class="list">            <li>Schema definition.</li>            <li>Storage structure and access-method definition.</li>            <li>Schema and physical-organization modification.</li>            <li>Granting of authorization for data access.</li>            <li>Routine maintenance.</li>        </ul>    </article>    <!-- divide line -->    <div class="divider"></div>    <!-- chinese -->    <article class="content">        <div class="text">数据库系统的功能</div>        <ul class="list">            <li>模式定义。</li>            <li>存储结构和访问方法定义。</li>            <li>模式和物理组织的修改。</li>            <li>授予数据访问权限。</li>            <li>常规维护。</li>        </ul>    </article></section><h3 id="数据库管理员-DBA"><a href="#数据库管理员-DBA" class="headerlink" title="数据库管理员 DBA"></a>数据库管理员 DBA</h3><section class="first_box">    <!-- title -->    <article class="title">The Functions of a DBA (数据库管理员的职能)</article>    <!-- main points in English and Chinese -->    <ul class="list">        <li>Schema definition. The DBA creates the original database schema by executing a set of data definition            statements in the DDL.            <br><span class="translation">模式定义。数据库管理员通过执行一组数据定义语句（DDL）来创建原始的数据库模式。</span>        </li>        <li>Storage structure and access-method definition.            <br><span class="translation">存储结构和访问方法定义。</span>        </li>        <li>Schema and physical-organization modification. The DBA carries out changes to the schema and physical            organization to reflect the changing needs of the organization, or to alter the physical organization to            improve performance.            <br><span class="translation">模式和物理组织的修改。数据库管理员根据组织需求的变化，或通过更改物理组织来提高性能，进行模式和物理组织的修改。</span>        </li>        <li>Granting of authorization for data access. By granting different types of authorization, the database            administrator can regulate which parts of the database various users can access. The authorization            information is kept in a special system structure that the database system consults whenever someone            attempts to access the data in the system.            <br><span                class="translation">授予数据访问权限。通过授予不同类型的权限，数据库管理员可以控制不同用户访问数据库的不同部分。授权信息存储在一个特殊的系统结构中，每当有人尝试访问系统中的数据时，数据库系统会查阅此信息。</span>        </li>        <li>Routine maintenance.            <br><span class="translation">常规维护。</span>            <ul class="sublist">                <li>Periodically backing up the database, either onto tapes or onto remote servers, to prevent loss of                    data in case of disasters such as flooding.                    <br><span class="translation">定期备份数据库，可以备份到磁带或远程服务器，以防止灾难（如洪水）导致数据丢失。</span>                </li>                <li>Ensuring that enough free disk space is available for normal operations, and upgrading disk space as                    required.                    <br><span class="translation">确保有足够的空闲磁盘空间进行正常操作，并根据需要升级磁盘空间。</span>                </li>                <li>Monitoring jobs running on the database and ensuring that performance is not degraded by very                    expensive tasks submitted by some users.                    <br><span class="translation">监控数据库中运行的作业，确保性能不会因某些用户提交的高消耗任务而受到影响。</span>                </li>            </ul>        </li>    </ul></section><h3 id="数据模型-DataModel"><a href="#数据模型-DataModel" class="headerlink" title="数据模型 DataModel"></a>数据模型 DataModel</h3><p>数据模型的发展历程</p><ol><li>层次模型</li><li>网状模型</li><li>关系模型</li></ol><p>数据处理的三个世界</p><ol><li>现实世界：是对客观存在的世界中的事物及其联系</li><li>信息世界：是现实世界在人们头脑中的反映，是对客观事物及其联系的一种抽象描述</li><li>计算机世界：是在信息世界基础上的进一步抽象</li></ol><p>数据模型应满足以下三个要求：</p><ol><li>比较真实地模拟现实世界（现实世界）</li><li>容易为人所理解（概念世界）</li><li>便于在计算机上实现（机器世界）</li></ol><p>数据模型的分类</p><ol><li>概念数据模型：高层模型</li><li>表示型&#x2F;实现型模型：中间层模型</li><li>物理数据模型：低层模型</li></ol><h3 id="概念数据模型——高层模型"><a href="#概念数据模型——高层模型" class="headerlink" title="概念数据模型——高层模型"></a>概念数据模型——高层模型</h3><p><span style="color: red;">实体联系模型</span>和<span style="color: red;">对象数据模型</span></p><h3 id="实体-联系模型-entity-relation-model"><a href="#实体-联系模型-entity-relation-model" class="headerlink" title="实体-联系模型 entity-relation model"></a>实体-联系模型 entity-relation model</h3><p>实体是一个集合名词，表示真是世界中的对象集合或概念。<br>属性表示进一步描述实体的某个感兴趣的特性。<br>联系表示在两个或多个实体间的关联。</p><h3 id="对象-数据模型-object-data-model"><a href="#对象-数据模型-object-data-model" class="headerlink" title="对象-数据模型 object-data model"></a>对象-数据模型 object-data model</h3><p>类间的关系：</p><ol><li>泛化 (is-a)<ol><li>继承</li></ol></li><li>关联 (has-a)<ol><li>关联 assiaciation</li><li>聚合 aggregation</li><li>组合 composition</li></ol></li><li>依赖 (use-a)<ol><li>在方法接口中使用 use-in-interface</li><li>在实现中使用 use-in-implementation</li></ol></li><li>实现 (implement)<ol><li>实现一个接口</li></ol></li></ol><h3 id="表示型-实现型模型——中间层模型"><a href="#表示型-实现型模型——中间层模型" class="headerlink" title="表示型&#x2F;实现型模型——中间层模型"></a>表示型&#x2F;实现型模型——中间层模型</h3><p>表示型数据模型使用记录结构来表示数据，因此也称为基于记录的数据模型。目前主要的数据库模型是关系数据模型。</p><h3 id="物理数据模型——低层模型"><a href="#物理数据模型——低层模型" class="headerlink" title="物理数据模型——低层模型"></a>物理数据模型——低层模型</h3><p>提供的概念只对计算机专家有意义，而不是最终用户。描述了数据如何在计算机存储介质（硬盘）上存储的细节。</p><h3 id="数据库规范化-Normalization-Theory"><a href="#数据库规范化-Normalization-Theory" class="headerlink" title="数据库规范化 Normalization Theory"></a>数据库规范化 Normalization Theory</h3><p>数据库规范化是将数据库组织成符合一定规则和标准的过程。其核心目标是消除数据冗余、增强数据一致性、提高查询性能。规范化通常分为几个阶段或“范式”，每个范式都有特定的规则和标准。</p><p>1.第一范式（1NF）要求消除重复的列，从而确保每个列都包含原子值。<br>2.第二范式（2NF）在第一范式的基础上，消除非主属性对部分关键字的依赖。<br>3.第三范式（3NF）要求消除非主属性对主关键字的传递依赖。进一步的规范化阶段如BCNF（Boyce Codd范式）。<br>4.第四范式（4NF），则解决了更复杂的依赖和多值依赖问题。</p><h2 id="数据库三层模式体系结构-Three-Schema"><a href="#数据库三层模式体系结构-Three-Schema" class="headerlink" title="数据库三层模式体系结构 Three-Schema"></a>数据库三层模式体系结构 Three-Schema</h2><h3 id="内模式-internal-schema"><a href="#内模式-internal-schema" class="headerlink" title="内模式 internal schema"></a>内模式 internal schema</h3><p>内层对应内模式，用于描述数据库的物理存储结构。内模式使用物理数据模型，描述数据库的从存取路径和数据存储的全部细节。</p><h3 id="概念模式-conceptual-schema"><a href="#概念模式-conceptual-schema" class="headerlink" title="概念模式 conceptual schema"></a>概念模式 conceptual schema</h3><p>简称模式，中间层为概念层，对应概念模式。<br>用于为所有用户描述整个数据库的结构，注重描述实体、数据类型、联系、用户操作和约束，并隐藏了物理存储结构的细节。</p><p>使用表示型数据模型 E-R 模型来描述概念模式。<br>使用实现型数据模型 OO 模型来进行概念模式设计。</p><h3 id="外模式-external-schema"><a href="#外模式-external-schema" class="headerlink" title="外模式 external schema"></a>外模式 external schema</h3><p>外层或者视图层，对应若干位模式或用户视图。</p><p>每个外模式描述了特定用户组感兴趣的一部分数据库，并且对该组用户隐藏数据库的其他部分。</p><blockquote><p>例子：把数据库看作仓库，数据看作货物。内模式描述货物的摆放规则；概念模式描述仓库中货物的分类等信息；外模式实际服务仓库的相关人员。</p></blockquote><p>需要注意的是，三层模式仅仅是对数据的描述，数据实际上仅存储在物理层</p><ol><li>每个用户组只需关注自己的外模式</li><li>DBMS 必须将在外模式中指定的请求转化为针对概念模式的请求，并进而转化为对内模式的请求以实现对存储的数据库进行处理。</li><li>如果是一个数据库检索请求，那么从存储在数据库中提取出的数据必须经过格式转化，来匹配用户外部视图所要求的格式。</li><li>在各层之间完成请求和结果转换的处理过程被称为映射。</li></ol><h3 id="数据独立性"><a href="#数据独立性" class="headerlink" title="数据独立性"></a>数据独立性</h3><p>较低层的修改不会对较高层产生影响</p><ol><li>逻辑数据独立性: 外模式不会受概念模式变化的影响</li><li>物理数据独立性: 概念模式不会受内模式变化的影响</li></ol><h2 id="DBMS-体系结构"><a href="#DBMS-体系结构" class="headerlink" title="DBMS 体系结构"></a>DBMS 体系结构</h2><ol><li>Centralized</li><li>Client-server</li><li>Parallel computer architectures.</li><li>Distributed databases</li></ol><p>数据库是一整套数据管理体系，包括数据存储的模型、数据组织的架构、数据分析的算法、数据管理的工具以及数据访问的接口等等。</p><img src="/img/039.png" alt="" style="height: 400px;"><p>ppt 中有大量的概念，这里直接附上英文原文和翻译，虽然完全记不住：</p><section class="first_box">    <!-- title -->    <article class="title">Storage Manager</article>    <!-- english -->    <article class="content">        <div class="text">Storage manager is a program module that provides the interface between the low-level data            stored in the database and the application programs and queries submitted to the system.</div>        <div class="text">The storage manager is responsible for the following tasks:</div>        <ul class="list">            <li>Interaction with the file manager</li>            <li>Efficient storing, retrieving and updating of data</li>        </ul>        <div class="text">Issues:</div>        <ul class="list">            <li>Storage access</li>            <li>File organization</li>            <li>Indexing and hashing</li>        </ul>    </article>    <!-- divide line -->    <div class="divider"></div>    <!-- chinese -->    <article class="content">        <div class="text">存储管理器是一个程序模块，它提供了数据库中存储的低级数据与提交给系统的应用程序和查询之间的接口。</div>        <div class="text">存储管理器负责以下任务：</div>        <ul class="list">            <li>与文件管理器的交互</li>            <li>数据的高效存储、检索和更新</li>        </ul>        <div class="text">问题：</div>        <ul class="list">            <li>存储访问</li>            <li>文件组织</li>            <li>索引和哈希</li>        </ul>    </article></section><section class="first_box">    <!-- title -->    <article class="title">Query Processor</article>    <!-- english -->    <article class="content">        <ul class="list">            <li>DDL interpreter</li>            <li>DML Compiler</li>            <li>Query Evaluation Engine</li>        </ul>        <div class="text">Alternative ways of evaluating a given query</div>        <ul class="list">            <li>Equivalent expressions</li>            <li>Different algorithms for each operation</li>        </ul>        <div class="text">Cost difference between a good and a bad way of evaluating a query can be enormous</div>        <div class="text">Need to estimate the cost of operations</div>        <ul class="list">            <li>Depends critically on statistical information about relations which the database must maintain</li>            <li>Need to estimate statistics for intermediate results to compute cost of complex expressions</li>        </ul>    </article>    <!-- divide line -->    <div class="divider"></div>    <!-- chinese -->    <article class="content">        <div class="text">查询处理器</div>        <ul class="list">            <li>DDL 解释器</li>            <li>DML 编译器</li>            <li>查询评估引擎</li>        </ul>        <div class="text">评估给定查询的替代方法：</div>        <ul class="list">            <li>等效表达式</li>            <li>每个操作的不同算法</li>        </ul>        <div class="text">评估查询的好方式和坏方式之间的成本差异可能是巨大的，需要估算操作的成本：</div>        <ul class="list">            <li>成本估算严重依赖于数据库必须维护的关系的统计信息。</li>            <li>为了计算复杂表达式的成本，还需要估算中间结果的统计信息。</li>        </ul>    </article></section><section class="first_box">    <!-- title -->    <article class="title">Possible Issues in Databases</article>    <!-- english -->    <article class="content">        <ul class="list">            <li>What if the system fails?</li>            <li>What if more than one user is concurrently updating the same data?</li>            <li>A transaction is a collection of operations that performs a single logical function in a database                application.</li>            <li>Transaction-management component ensures that the database remains in a consistent (correct) state                despite system failures (e.g., power failures and operating system crashes) and transaction failures.            </li>            <li>Concurrency-control manager controls the interaction among the concurrent transactions, to ensure the                consistency of the database.</li>        </ul>    </article>    <!-- divide line -->    <div class="divider"></div>    <!-- chinese -->    <article class="content">        <ul class="list">            <li>如果多个用户同时更新相同的数据怎么办？</li>            <li>事务是一个操作集合，在数据库应用程序中执行一个单一的逻辑功能。</li>            <li>事务管理组件确保数据库在系统故障（例如电力故障和操作系统崩溃）和事务失败的情况下仍保持一致（正确）状态。</li>            <li>并发控制管理器控制并发事务之间的交互，确保数据库的一致性。</li>        </ul>    </article></section><section class="first_box">    <!-- title -->    <article class="title">ACID of A Transaction - Atomicity</article>    <!-- english -->    <article class="content">        <ul class="list">            <li>Often, several operations on the database form a single logical unit of work (Transaction).</li>            <li>An example is a funds transfer.</li>            <li>One department account (say A) is debited.</li>            <li>Another department account (say B) is credited.</li>        </ul>        <div class="text">Clearly, it is essential that either both the credit and debit occur, or that neither occur.            That is, the funds transfer must happen in its entirety or not at all.</div>        <div class="text">This all-or-none requirement is called Atomicity.</div>    </article>    <!-- divide line -->    <div class="divider"></div>    <!-- chinese -->    <article class="content">        <div class="text">事务的ACID——原子性 (Atomicity)</div>        <ul class="list">            <li>通常，多个操作在数据库上形成一个单一的逻辑工作单元（事务）。</li>            <li>例如，一个资金转账操作。</li>            <li>一个部门账户（如A）被扣款。</li>            <li>另一个部门账户（如B）被存款。</li>        </ul>        <div class="text">显然，至关重要的是，扣款和存款要么都发生，要么都不发生。也就是说，资金转账要么完全发生，要么完全不发生。</div>        <div class="text">这种“全有或全无”的要求被称为原子性。</div>    </article></section><section class="first_box">    <!-- title -->    <article class="title">ACID of A Transaction - Consistency</article>    <!-- english -->    <article class="content">        <ul class="list">            <li>It is essential that the execution of the funds transfer preserve the consistency of the database.</li>            <li>That is, the value of the sum of the balances of A and B must be preserved.</li>            <li>This correctness requirement is called consistency.</li>        </ul>    </article>    <!-- divide line -->    <div class="divider"></div>    <!-- chinese -->    <article class="content">        <div class="text">事务的ACID —— 一致性 (Consistency)</div>        <ul class="list">            <li>确保资金转账的执行保持数据库的一致性是至关重要的。</li>            <li>也就是说，A和B账户余额的总和必须保持不变。</li>            <li>这种正确性要求被称为一致性。</li>        </ul>    </article></section><section class="first_box">    <!-- title -->    <article class="title">ACID of A Transaction - Durability</article>    <!-- english -->    <article class="content">        <ul class="list">            <li>Finally, after the successful execution of a funds transfer, the new values of the balances of accounts                A and B must persist, despite the possibility of system failure.</li>            <li>This persistence requirement is called durability.</li>        </ul>    </article>    <!-- divide line -->    <div class="divider"></div>    <!-- chinese -->    <article class="content">        <div class="text">事务的ACID —— 持久性 (Durability)</div>        <ul class="list">            <li>最后，在资金转账成功执行后，账户A和B的新余额值必须持久存在，即使系统发生故障也不受影响。</li>            <li>这种持久性要求被称为持久性。</li>        </ul>    </article></section><section class="first_box">    <!-- title -->    <article class="title">ACID of A Transaction - Isolation</article>    <!-- english -->    <article class="content">        <ul class="list">            <li>Even if the consistency and atomicity properties are ensured for each transaction, if several                transactions are executed concurrently, their operations may interleave in some undesirable way,                resulting in an inconsistent state.</li>            <li>For example, as we saw earlier, the database is temporarily inconsistent while the transaction to                transfer funds from A to B is executing, with the deducted total written to A and the increased total                yet to be written to B.</li>            <li>If a second concurrently running transaction reads A and B at this intermediate point and computes A+B,                it will observe an inconsistent value.</li>            <li>Furthermore, if this second transaction then performs updates on A and B based on the inconsistent                values that it read, the database may be left in an inconsistent state even after both transactions have                completed.</li>        </ul>    </article>    <!-- divide line -->    <div class="divider"></div>    <!-- chinese -->    <article class="content">        <div class="text">事务的ACID —— 隔离性 (Isolation)</div>        <ul class="list">            <li>即使每个事务都确保了一致性和原子性属性，如果多个事务并发执行，它们的操作可能会以某种不期望的方式交错，导致数据库处于不一致状态。</li>            <li>例如，如前所述，在从A账户转账到B账户的事务执行期间，数据库是暂时不一致的，因为A账户的扣款已写入，而B账户的增加金额尚未写入。</li>            <li>如果第二个并发运行的事务在这个中间状态下读取A和B，并计算A+B，它将观察到一个不一致的值。</li>            <li>此外，如果这个第二个事务基于读取到的不一致值对A和B进行更新，即使两个事务都已完成，数据库仍可能处于不一致的状态。</li>        </ul>    </article></section><section class="first_box">    <!-- title -->    <article class="title">ACID of A Transaction - Isolation</article>    <!-- english -->    <article class="content">        <ul class="list">            <li>A way to avoid the problem of concurrently executing transactions is to execute transactions                serially—that is, one after the other. However, concurrent execution of transactions provides                significant performance benefits.</li>            <li>Other solutions have therefore been developed; they allow multiple transactions to execute concurrently.                We discuss the problems caused by concurrently executing transactions in Section 14.5.</li>            <li>The isolation property of a transaction ensures that the concurrent execution of transactions results in                a system state that is equivalent to a state that could have been obtained had these transactions                executed one at a time in some order.</li>            <li>Ensuring the isolation property is the responsibility of a component of the database system called the                concurrency-control system.</li>        </ul>    </article>    <!-- divide line -->    <div class="divider"></div>    <!-- chinese -->    <article class="content">        <div class="text">事务的ACID —— 隔离性 (Isolation)</div>        <ul class="list">            <li>避免并发执行事务问题的一种方法是串行执行事务——即一个接一个地执行。然而，并发执行事务能够提供显著的性能提升。</li>            <li>因此，已经开发出其他解决方案，它们允许多个事务并发执行。我们将在第14.5节讨论并发执行事务引发的问题。</li>            <li>事务的隔离性属性确保并发执行的事务结果等同于按某种顺序逐个执行这些事务时所得到的系统状态。</li>            <li>确保隔离性属性是数据库系统中的一个组件——并发控制系统——的责任。</li>        </ul>    </article></section>]]></content>
    
    
    
    <tags>
      
      <tag>DataBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust</title>
    <link href="/2024/11/24/Rust/"/>
    <url>/2024/11/24/Rust/</url>
    
    <content type="html"><![CDATA[<h2 id="Chapter2"><a href="#Chapter2" class="headerlink" title="Chapter2"></a>Chapter2</h2><p>let 定义变量，默认不可变，可变变量需要用 mut 关键字。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>强类型推导，会根据等号右边结果或者后文自动推导变量类型。使用冒号可以定义类型。Rust 在编译的时候就必须知道变量的类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span>: <span class="hljs-type">u32</span> = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>宏<code>println!</code>用于输出，<code>&#123;&#125;</code>用于填入此参数，在大括号中填数字可以分组。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;cout &#123;0&#125;, &#123;0&#125;, &#123;1&#125;&quot;</span>, a, b);<br></code></pre></td></tr></table></figure><p>有些函数的返回值为<code>Rusult</code>，有<code>Ok</code>, <code>Err</code>两种，使用<code>expect</code>函数可以在错误时输出信息，但是程序仍然会崩溃。使用<code>match</code>可以优美(网上这么说的)的在错误时采取其他的行为从而使程序继续。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-comment">// expect</span><br>io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> num).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Failed to read line&quot;</span>);<br><br><span class="hljs-comment">// match</span><br><span class="hljs-keyword">match</span> io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> num) &#123;<br>  <span class="hljs-title function_ invoke__">Ok</span>(num) =&gt; num,<br>  <span class="hljs-title function_ invoke__">Err</span>(_) =&gt; ...,    <span class="hljs-comment">// _ = not care</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>猜数游戏：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> rand::Rng;<br><span class="hljs-keyword">use</span> std::cmp::Ordering;<br><span class="hljs-keyword">use</span> std::io;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">secret_number</span> = rand::<span class="hljs-title function_ invoke__">thread_rng</span>().<span class="hljs-title function_ invoke__">gen_range</span>(<span class="hljs-number">1</span>..=<span class="hljs-number">100</span>);<br><br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Please input your guess.&quot;</span>);<br><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">guess</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br><br>        io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> guess).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Failed to read line&quot;</span>);<br><br>        <span class="hljs-comment">// shadow</span><br>        <span class="hljs-comment">// trim : delete &quot; &quot;</span><br>        <span class="hljs-comment">// parse : stoi</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">guess</span>: <span class="hljs-type">u32</span> = <span class="hljs-keyword">match</span> guess.<span class="hljs-title function_ invoke__">trim</span>().<span class="hljs-title function_ invoke__">parse</span>() &#123;<br>            <span class="hljs-title function_ invoke__">Ok</span>(num) =&gt; num,<br>            <span class="hljs-title function_ invoke__">Err</span>(_) =&gt; <span class="hljs-keyword">continue</span>,     <span class="hljs-comment">// _ = not care</span><br>        &#125;;<br><br>        <span class="hljs-keyword">match</span> guess.<span class="hljs-title function_ invoke__">cmp</span>(&amp;secret_number) &#123;<br>            Ordering::Less =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Too small!&quot;</span>),<br>            Ordering::Greater =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Too big!&quot;</span>),<br>            Ordering::Equal =&gt; &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;You win!&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Chapter3"><a href="#Chapter3" class="headerlink" title="Chapter3"></a>Chapter3</h2><p>常量不等于不可变的变量，const 声明，必须指定类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">const</span> MAX_NUM: <span class="hljs-type">i64</span> = <span class="hljs-number">20070206</span>;<br></code></pre></td></tr></table></figure><p>Shadow 机制，同名变量后者会隐藏前者。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-comment">// mut</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num1</span> = <span class="hljs-number">10</span>;<br>num1 = <span class="hljs-number">20</span>;<br><br><span class="hljs-comment">// shadow</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num1</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">num1</span> = <span class="hljs-string">&quot;dmx20070206&quot;</span>;<br></code></pre></td></tr></table></figure><p>Rust 的整数类型：</p><table><thead><tr><th>位长度</th><th>有符号</th><th>无符号</th></tr></thead><tbody><tr><td>8 bit</td><td>i8</td><td>u8</td></tr><tr><td>16 bit</td><td>i16</td><td>u16</td></tr><tr><td>32 bit</td><td>i32</td><td>u32</td></tr><tr><td>64 bit</td><td>i64</td><td>u64</td></tr><tr><td>128 bit</td><td>i128</td><td>u128</td></tr><tr><td>arch</td><td>isize</td><td>usize</td></tr><tr><td>不同进制：0x, 0o, 0b。任何进制都可以用 _ 分割。i32 为默认类型。</td><td></td><td></td></tr></tbody></table><p>Rust 的浮点数类型：<br>f32, f64, IEEE-754 标准。f64 为默认类型。</p><p>Rust 的布尔类型：略</p><p>Rust 的字符类型：<br>表示一个 Unicode 字符，占用 4 个字节。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num1</span> = &#x27;😅&#x27;;<br></code></pre></td></tr></table></figure><p>Rust 中的 Tuple：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span>: (<span class="hljs-type">u32</span>, <span class="hljs-type">char</span>, <span class="hljs-type">f32</span>) = (<span class="hljs-number">10</span>, &#x27;😅&#x27;, <span class="hljs-number">1.5</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, num.<span class="hljs-number">0</span>, num.<span class="hljs-number">1</span>, num.<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>Rust 中的 数组:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-comment">// 类型; 长度</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span>: [<span class="hljs-type">f64</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">1.1</span>, <span class="hljs-number">1.2</span>, <span class="hljs-number">1.3</span>];<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, num[<span class="hljs-number">0</span>], num[<span class="hljs-number">1</span>], num[<span class="hljs-number">2</span>]);<br><br><span class="hljs-comment">// 数据; 重复次数</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = [<span class="hljs-number">3</span>; <span class="hljs-number">5</span>];<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, num[<span class="hljs-number">0</span>], num[<span class="hljs-number">1</span>], num[<span class="hljs-number">2</span>], num[<span class="hljs-number">3</span>], num[<span class="hljs-number">4</span>]);<br></code></pre></td></tr></table></figure><p>Rust 中的表达式类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-comment">// x = the last expression</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-number">10</span>;<br>        num<br>    &#125;;<br></code></pre></td></tr></table></figure><p>Rust 中的函数，用<code>fn</code>关键字，参数必须声明类型，返回值用<code>-&gt;</code>符号定义，函数默认返回最后一个表达式，可以隐藏<code>return</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-comment">// return the last expression</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>(x: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    x + <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>(x: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Rust 中的 if-else：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">condition</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-keyword">if</span> condition &#123; <span class="hljs-number">10</span> &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-number">20</span> &#125;;<br></code></pre></td></tr></table></figure><h2 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h2><p><strong>所有权</strong>是 Rust 中很重要的概念，所有程序在运行时都必须管理它们使用计算机内存的方式。</p><ol><li>有些语言自带 GC，程序运行时会一直搜索已经不用的内存</li><li>有些语言需要程序员显式的申请和释放内存</li><li>Rust 通过一个所有权系统来管理内存，其中包含一组编译器在编译时检测的规则</li></ol><p>Rust 中，可以向 Stack 和 Heap 申请内存。Stack 只能存放<strong>定长</strong>的数据，Heap 可以存放<strong>变长</strong>的数据。很明显，计算机访问 Stack 上的数据快于 Heap，因为从 Stack 获取数据一定是栈顶，并且 Stack 中各个数据离得近。</p><p>String 类型是典型的变长数据类型，它只能存放于 Heap 上。通过<code>from</code>方法可以通过字符串常量创建一个 String 类型，它存放于 Heap 上，所以它是可变的。</p><p><strong>Drop</strong>, <strong>Move</strong>, <strong>Copy</strong>, <strong>Clone</strong></p><p><strong>Drop</strong> 清理规则：</p><ol><li>当一个数据<strong>离开作用域</strong>时，立即释放它占用的内存</li><li>对于失效(Moved)的变量，不会释放它占用的内存</li><li>对于 Stack 上的简单数据，不需要 Drop</li><li>对于 Heap 上的数据，需要 Drop</li></ol><p><strong>Move</strong> 移动规则：</p><ol><li>对于 Stack 数据，等同于 Copy</li><li>对于 Heap 数据，前者将被<strong>失效</strong><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num1</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">num2</span> = num1;    <span class="hljs-comment">// copy</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;dmx&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1;        <span class="hljs-comment">// s1 moved</span><br><br><span class="hljs-comment">// borrow of moved value: `s1`</span><br><span class="hljs-comment">// println!(&quot;&#123;&#125;&quot;, s1);</span><br><br><span class="hljs-comment">// exit, s2 will be destoryed</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>Copy</strong> 拷贝规则：</p><ol><li>如果变量一部分创建了 Drop，那么该变量不能拥有 Copy</li><li>Copy 类型的变量一般存放于 Stack 上，不需要额外的 Drop 操作<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num1</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">num2</span> = num1;    <span class="hljs-comment">// copy type</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>Clone</strong> 克隆规则：</p><ol><li>使用 clone 方法，可以实现深拷贝？</li><li>在 Heap 上开辟新的一块内存<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;dmx&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1.<span class="hljs-title function_ invoke__">clone</span>();    <span class="hljs-comment">// s1 still valid</span><br></code></pre></td></tr></table></figure></li></ol><p>函数的参数传递中所有权的转移</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-comment">// s 被声明有效</span><br><br>    <span class="hljs-title function_ invoke__">takes_ownership</span>(s);<br>    <span class="hljs-comment">// s 的值被当作参数传入函数</span><br>    <span class="hljs-comment">// 所以可以当作 s 已经被移动，从这里开始已经无效</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-comment">// x 被声明有效</span><br><br>    <span class="hljs-title function_ invoke__">makes_copy</span>(x);<br>    <span class="hljs-comment">// x 的值被当作参数传入函数</span><br>    <span class="hljs-comment">// 但 x 是基本类型，依然有效</span><br>    <span class="hljs-comment">// 在这里依然可以使用 x 却不能使用 s</span><br><br>&#125; <span class="hljs-comment">// 函数结束, x 无效, 然后是 s. 但 s 已被移动, 所以不用被释放</span><br><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">takes_ownership</span>(some_string: <span class="hljs-type">String</span>) &#123; <br>    <span class="hljs-comment">// 一个 String 参数 some_string 传入，有效</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, some_string);<br>&#125; <span class="hljs-comment">// 函数结束, 参数 some_string 在这里释放</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">makes_copy</span>(some_integer: <span class="hljs-type">i32</span>) &#123; <br>    <span class="hljs-comment">// 一个 i32 参数 some_integer 传入，有效</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, some_integer);<br>&#125; <span class="hljs-comment">// 函数结束, 参数 some_integer 是基本类型, 无需释放</span><br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-title function_ invoke__">gives_ownership</span>();<br>    <span class="hljs-comment">// gives_ownership 移动它的返回值到 s1</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-comment">// s2 被声明有效</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span> = <span class="hljs-title function_ invoke__">takes_and_gives_back</span>(s2);<br>    <span class="hljs-comment">// s2 被当作参数移动, s3 获得返回值所有权</span><br>&#125; <span class="hljs-comment">// s3 无效被释放, s2 被移动, s1 无效被释放.</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">gives_ownership</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">some_string</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-comment">// some_string 被声明有效</span><br><br>    <span class="hljs-keyword">return</span> some_string;<br>    <span class="hljs-comment">// some_string 被当作返回值移动出函数</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">takes_and_gives_back</span>(a_string: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123; <br>    <span class="hljs-comment">// a_string 被声明有效</span><br><br>    a_string  <span class="hljs-comment">// a_string 被当作返回值移出函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Rust 中的<strong>引用</strong>和<strong>租借</strong></p><p>引用是一种“借”所有权的过程，例如下面的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = <span class="hljs-title function_ invoke__">calculate_length</span>(&amp;s1);<br><br>    <span class="hljs-comment">// s1 is borrowed</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>借用后不可以修改原数据，除非用<code>mut</code>关键字修饰，如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;dmx&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = &amp;<span class="hljs-keyword">mut</span> s1;<br><br>    s2.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;20070206&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s2);<br>&#125;<br></code></pre></td></tr></table></figure><p>一个变量的某时刻的全部有效引用必须满足如下规则：</p><ol><li>有至多一个可变引用</li><li>有若干个不可变引用</li><li>引用必须一致有效</li></ol><p>同时，在 Rust 中不允许悬空引用，如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">reference_to_nothing</span> = <span class="hljs-title function_ invoke__">dangle</span>();<br>    <span class="hljs-comment">// null</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dangle</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    &amp;s<br>&#125;<br><span class="hljs-comment">// s will be destoryed</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ENGLISH</title>
    <link href="/2024/11/21/ENGLISH/"/>
    <url>/2024/11/21/ENGLISH/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/css/ENGLISH.css"><h2 id="2024-11-22"><a href="#2024-11-22" class="headerlink" title="2024-11-22"></a>2024-11-22</h2><h3 id="list-1"><a href="#list-1" class="headerlink" title="list 1"></a>list 1</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>account</td><td>benefit</td><td>challenge</td></tr><tr><td>impact</td><td>apply</td><td>focus</td></tr><tr><td>involve</td><td>potential</td><td>promote</td></tr><tr><td>shift</td><td>tend</td><td>access</td></tr><tr><td>resource</td><td>launch</td><td>current</td></tr><tr><td>opportunity</td><td>reflect</td><td>debate</td></tr><tr><td>conduct</td><td>despite</td><td>determine</td></tr><tr><td>purchase</td><td>specific</td><td>senior</td></tr><tr><td>unique</td><td>amount</td><td>agency</td></tr><tr><td>expand</td><td>attitude</td><td>financial</td></tr><tr><td>release</td><td>declare</td><td>institution</td></tr><tr><td>estimate</td><td>pose</td><td>significant</td></tr><tr><td>associate</td><td>assume</td><td>eventually</td></tr><tr><td>replace</td><td>series</td><td>fund</td></tr><tr><td>rank</td><td>respond</td><td>advocate</td></tr><tr><td>boost</td><td>throughout</td><td>define</td></tr><tr><td>establish</td><td>predict</td><td>attach</td></tr><tr><td>campaign</td><td>track</td><td>exchange</td></tr><tr><td>numerous</td><td>expose</td><td>overall</td></tr><tr><td>vehicle</td><td>outcome</td><td>intend</td></tr><tr><td>reveal</td><td>positive</td><td>critical</td></tr><tr><td>survey</td><td>capacity</td><td>enhance</td></tr></tbody></table><h3 id="list-2"><a href="#list-2" class="headerlink" title="list 2"></a>list 2</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>vocal</td><td>officials</td><td>overestimate</td></tr><tr><td>hesitant</td><td>terminate</td><td>invest</td></tr><tr><td>bleak</td><td>inclusiveness</td><td>frontline</td></tr><tr><td>genre</td><td>regulation</td><td>overnight</td></tr><tr><td>distinguish</td><td>money-making</td><td>monolingual</td></tr><tr><td>bilingual</td><td>multilingual</td><td>leather</td></tr><tr><td>substitute</td><td>fierce</td><td>particularly</td></tr><tr><td>obsessed</td><td>cognitive</td><td>elite</td></tr><tr><td>vast</td><td>bulk</td><td>aggressive</td></tr><tr><td>inflation</td><td>cross-country</td><td>church</td></tr><tr><td>dictate</td><td>infant</td><td>struggle</td></tr><tr><td>category</td><td>measure</td><td>interpret</td></tr><tr><td>exotic</td><td>acclaim</td><td>infrastructure</td></tr></tbody></table><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] total = <span class="hljs-number">66</span> + <span class="hljs-number">39</span>;<br></code></pre></td></tr></table></figure><h2 id="2024-11-24"><a href="#2024-11-24" class="headerlink" title="2024-11-24"></a>2024-11-24</h2><h3 id="list-1-1"><a href="#list-1-1" class="headerlink" title="list 1"></a>list 1</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>executive</td><td>confidence</td><td>motivate</td></tr><tr><td>eliminate</td><td>expense</td><td>peer</td></tr><tr><td>responsibility</td><td>ignore</td><td>commit</td></tr><tr><td>complex</td><td>corporate</td><td>bias</td></tr><tr><td>majority</td><td>distinguish</td><td>alternative</td></tr><tr><td>identify</td><td>invest</td><td>consequence</td></tr><tr><td>spot</td><td>combine</td><td>option</td></tr><tr><td>annual</td><td>discount</td><td>negative</td></tr><tr><td>superior</td><td>obtain</td><td>extreme</td></tr><tr><td>attribute</td><td>assess</td><td>identity</td></tr><tr><td>notion</td><td>rely</td><td>perceive</td></tr><tr><td>staff</td><td>vital</td><td>chain</td></tr><tr><td>yield</td><td>enable</td><td>priority</td></tr><tr><td>consist</td><td>embrace</td><td>imply</td></tr><tr><td>refer</td><td>detail</td><td>recommend</td></tr><tr><td>exhibit</td><td>crucial</td><td>talent</td></tr><tr><td>consume</td><td>relate</td><td>construction</td></tr><tr><td>diminish</td><td>emission</td><td>incentive</td></tr><tr><td>remind</td><td>accelerate</td><td>shrink</td></tr><tr><td>counterpart</td><td>medium</td><td>enormous</td></tr><tr><td>giant</td><td>locate</td><td>ongoing</td></tr><tr><td>status</td><td>thrive</td><td>cater</td></tr><tr><td>transfer</td><td>investigate</td><td>encounter</td></tr><tr><td>essential</td><td>necessarily</td><td></td></tr></tbody></table><h3 id="list-2-1"><a href="#list-2-1" class="headerlink" title="list 2"></a>list 2</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>fellow</td><td>agriculture</td><td>entirely</td></tr><tr><td>presense</td><td>intensify</td><td>foster</td></tr><tr><td>talent</td><td>culturally</td><td>competency</td></tr><tr><td>bond</td><td>exaggerate</td><td>entrepreneur</td></tr><tr><td>permission</td><td>principal</td><td>separate</td></tr><tr><td>weird</td><td>willpower</td><td>faculty</td></tr><tr><td>donate</td><td>maintenance</td><td>campus</td></tr><tr><td>utility</td><td>insight</td><td>fertilizer</td></tr><tr><td>impressively</td><td>policymaker</td><td>tongue</td></tr><tr><td>magnify</td><td>split</td><td>depict</td></tr><tr><td>simul-taneously</td><td>endeavour</td><td>restrict</td></tr><tr><td>composition</td><td>inspirational</td><td>peak</td></tr><tr><td>anxiety</td><td>transition</td><td>harsh</td></tr><tr><td>wither</td><td>contract</td><td>curriculum</td></tr><tr><td>inferior</td><td>ladylike</td><td>devour</td></tr><tr><td>object</td><td>species</td><td>chemical</td></tr><tr><td>favor</td><td>sanctuary</td><td>bold</td></tr></tbody></table><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">total</span>: <span class="hljs-type">u32</span> = <span class="hljs-number">71</span> + <span class="hljs-number">51</span>;<br></code></pre></td></tr></table></figure><h2 id="2024-11-25"><a href="#2024-11-25" class="headerlink" title="2024-11-25"></a>2024-11-25</h2><h3 id="list-1-2"><a href="#list-1-2" class="headerlink" title="list 1"></a>list 1</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>previous</td><td>alter</td><td>institute</td></tr><tr><td>engage</td><td>abandon</td><td>transform</td></tr><tr><td>maintain</td><td>preserve</td><td>budget</td></tr><tr><td>assumption</td><td>cooperation</td><td>demonstrate</td></tr><tr><td>inform</td><td>recession</td><td>regulation</td></tr><tr><td>sophisticated</td><td>upgrade</td><td>abuse</td></tr><tr><td>circumstance</td><td>emerge</td><td>function</td></tr><tr><td>generate</td><td>profit</td><td>label</td></tr><tr><td>oppose</td><td>revenue</td><td>adapt</td></tr><tr><td>behave</td><td>cognitive</td><td>collapse</td></tr><tr><td>curriculum</td><td>exert</td><td>stimulate</td></tr><tr><td>stuff</td><td>bother</td><td>brand</td></tr><tr><td>considerable</td><td>contrast</td><td>indicate</td></tr><tr><td>modify</td><td>scale</td><td>absorb</td></tr><tr><td>candidate</td><td>crash</td><td>statistic</td></tr><tr><td>switch</td><td>tuition</td><td>reserve</td></tr><tr><td>breed</td><td>appreciate</td><td>conflict</td></tr><tr><td>implement</td><td>massive</td><td>highlight</td></tr><tr><td>capable</td><td>crime</td><td>explore</td></tr><tr><td>extend</td><td>meanwhile</td><td>regulate</td></tr><tr><td>cultivate</td><td>luxury</td><td>retain</td></tr><tr><td>due</td><td>latter</td><td>reverse</td></tr><tr><td>reject</td><td>virtue</td><td>sufficient</td></tr><tr><td>profound</td><td>reward</td><td>approach</td></tr><tr><td>appropriate</td><td></td><td></td></tr></tbody></table><h3 id="list-2-2"><a href="#list-2-2" class="headerlink" title="list 2"></a>list 2</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>treatment</td><td>relieve</td><td>figure</td></tr><tr><td>maintenance</td><td>pit</td><td>deposit</td></tr><tr><td>stick</td><td>alien</td><td>ecosystem</td></tr><tr><td>noticeable</td><td>witness</td><td>bankruptcy</td></tr><tr><td>phenomenon</td><td>arrest</td><td>charge</td></tr><tr><td>corruption</td><td>destined</td><td>victorious</td></tr><tr><td>sharply</td><td>regardless</td><td>observe</td></tr><tr><td>progress</td><td>rigorous</td><td>endure</td></tr><tr><td>pierce</td><td>elbow</td><td>snobby</td></tr><tr><td>insurance</td><td>commision</td><td>swamp</td></tr><tr><td>dweller</td><td>federal</td><td>drain</td></tr><tr><td>mental</td><td>lottery</td><td>laborious</td></tr><tr><td>ordeal</td><td>milestone</td><td>wheat</td></tr><tr><td>rupture</td><td>diplomatic</td><td>incident</td></tr><tr><td>infrastructure</td><td>peril</td><td>indeed</td></tr><tr><td>prestige</td><td>brand</td><td>former</td></tr><tr><td>reversible</td><td>pity</td><td>assert</td></tr><tr><td>dominance</td><td>companion</td><td>appropriation</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> total = <span class="hljs-number">73</span> + <span class="hljs-number">54</span>;<br></code></pre></td></tr></table></figure><h2 id="2024-11-27"><a href="#2024-11-27" class="headerlink" title="2024-11-27"></a>2024-11-27</h2><h3 id="list-1-3"><a href="#list-1-3" class="headerlink" title="list 1"></a>list 1</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>anticipate</td><td>array</td><td>embed</td></tr><tr><td>expertise</td><td>frame</td><td>grand</td></tr><tr><td>insist</td><td>obstacle</td><td>patent</td></tr><tr><td>peak</td><td>principal</td><td>shed</td></tr><tr><td>prior</td><td>prospect</td><td>remedy</td></tr><tr><td>rigorous</td><td>strengthen</td><td>tackle</td></tr><tr><td>transition</td><td>acknowledge</td><td>deposit</td></tr><tr><td>discourage</td><td>evolve</td><td>fake</td></tr><tr><td>manner</td><td>rival</td><td>severe</td></tr><tr><td>stereotype</td><td>toxic</td><td>vulnerable</td></tr><tr><td>ceremony</td><td>aspect</td><td>capture</td></tr><tr><td>domestic</td><td>endanger</td><td>exaggerate</td></tr><tr><td>indispensable</td><td>passion</td><td>phenomenon</td></tr><tr><td>pile</td><td></td><td></td></tr></tbody></table><h3 id="list-2-3"><a href="#list-2-3" class="headerlink" title="list 2"></a>list 2</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> total = ; <br></code></pre></td></tr></table></figure><h2 id="2024-11-29"><a href="#2024-11-29" class="headerlink" title="2024-11-29"></a>2024-11-29</h2><h3 id="list-1-4"><a href="#list-1-4" class="headerlink" title="list 1"></a>list 1</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>rare</td><td>rear</td><td>adolescent</td></tr><tr><td>assign</td><td>float</td><td>furthermore</td></tr><tr><td>illustrate</td><td>occupy</td><td>perspective</td></tr><tr><td>register</td><td>relieve</td><td>robust</td></tr><tr><td>ecosystem</td><td>responsible</td><td>fatal</td></tr><tr><td>reproduce</td><td>decrease</td><td>propose</td></tr><tr><td>ultimate</td><td>adjust</td><td>incorporate</td></tr><tr><td>version</td><td>ingredient</td><td>recall</td></tr><tr><td>artificial</td><td>arise</td><td>complain</td></tr><tr><td>differ</td><td>dramatic</td><td>intelligence</td></tr><tr><td>mininum</td><td>obvious</td><td>prosperity</td></tr><tr><td>abstract</td><td>accuse</td><td>intelligent</td></tr><tr><td>tenant</td><td>display</td><td>refrain</td></tr><tr><td>bet</td><td>stable</td><td>underestimate</td></tr><tr><td>compel</td><td>facilitate</td><td>leap</td></tr><tr><td>update</td><td>participate</td><td>resolve</td></tr></tbody></table><h3 id="list-2-4"><a href="#list-2-4" class="headerlink" title="list 2"></a>list 2</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="2024-12-4"><a href="#2024-12-4" class="headerlink" title="2024-12-4"></a>2024-12-4</h2><h3 id="list-1-5"><a href="#list-1-5" class="headerlink" title="list 1"></a>list 1</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>embark</td><td>accomodate</td><td>acquisition</td></tr><tr><td>arrange</td><td>award</td><td>contend</td></tr><tr><td>compromise</td><td>confirm</td><td>consultant</td></tr><tr><td>contract</td><td>controversy</td><td>criminal</td></tr><tr><td>curb</td><td>deny</td><td>enterprise</td></tr><tr><td>equip</td><td>essence</td><td>illegal</td></tr><tr><td>imperative</td><td>inquiry</td><td>insurance</td></tr><tr><td>integrate</td><td>literacy</td><td>odd</td></tr><tr><td>protest</td><td>renew</td><td>resort</td></tr><tr><td>segregation</td><td>semester</td><td>shortage</td></tr><tr><td>specialize</td><td>stem</td><td>submit</td></tr><tr><td>withdraw</td><td>calculate</td><td>consult</td></tr><tr><td>deadly</td><td>decorate</td><td>devote</td></tr><tr><td>dynamic</td><td>export</td><td>extent</td></tr><tr><td>grant</td><td>impose</td><td>justify</td></tr><tr><td>mortgage</td><td>odds</td><td>penalty</td></tr><tr><td>prejudice</td><td>profile</td><td>proportion</td></tr><tr><td>scare</td><td>skeptical</td><td>spark</td></tr><tr><td>symptom</td><td>steady</td><td>stake</td></tr><tr><td>emergency</td><td>concentrate</td><td>confront</td></tr><tr><td>derive</td><td>distribute</td><td>endure</td></tr><tr><td>entail</td><td>evaluate</td><td>impress</td></tr><tr><td>integral</td><td>intense</td><td>isolate</td></tr><tr><td>neglect</td><td>migrate</td><td>portray</td></tr><tr><td>prompt</td><td>trace</td><td>vision</td></tr><tr><td>complicate</td><td>distract</td><td>sensitive</td></tr></tbody></table><h3 id="list-2-5"><a href="#list-2-5" class="headerlink" title="list 2"></a>list 2</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>rationality</td><td>discourse</td><td>gradual</td></tr><tr><td>exposition</td><td>assertion</td><td>confine</td></tr><tr><td>overturn</td><td>reduce</td><td>sensationalism</td></tr><tr><td>commerce</td><td>proposition</td><td>commercial</td></tr><tr><td>derive</td><td>grip</td><td>colonize</td></tr><tr><td>instant</td><td>approval</td><td>constantly</td></tr><tr><td>unconsciously</td><td>curiosty</td><td>reason</td></tr><tr><td>supremacy</td><td>conducive</td><td>entitlement</td></tr><tr><td>dysfunction</td><td>legitimately</td><td>generous</td></tr><tr><td>irrespective</td><td>discrepancy</td><td>privilege</td></tr><tr><td>inflate</td><td>slack off</td><td>overindulge</td></tr><tr><td>thereby</td><td>spolit</td><td>nonetheless</td></tr><tr><td>virtue</td><td>heighten</td><td>respondent</td></tr><tr><td>alleviate</td><td>indulge</td><td>accountable</td></tr><tr><td>genuinely</td><td>deviate</td><td>confront</td></tr><tr><td>disincline</td><td>tactfully</td><td>somewhat</td></tr><tr><td>distorte</td><td>criterion</td><td></td></tr></tbody></table><h2 id="2024-12-10"><a href="#2024-12-10" class="headerlink" title="2024-12-10"></a>2024-12-10</h2><h3 id="list-2-6"><a href="#list-2-6" class="headerlink" title="list 2"></a>list 2</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>obsess</td><td>obsessive</td><td>obsession</td></tr><tr><td>onsessively</td><td>grant</td><td>assualt</td></tr><tr><td>self-esteem</td><td>mental</td><td>possess</td></tr><tr><td>possession</td><td>outright</td><td>breach</td></tr><tr><td>infringe</td><td>surveillance</td><td>inherent</td></tr><tr><td>relentness</td><td>squeeze</td><td>exhaust</td></tr><tr><td>badge</td><td>intrusive</td><td>exponent</td></tr><tr><td>harassment</td><td>implant</td><td>orinented</td></tr><tr><td>substantial</td><td>slack</td><td>revolt</td></tr><tr><td>liberty</td><td>empower</td><td>intrusion</td></tr><tr><td>counterproductive</td><td>deem</td><td></td></tr></tbody></table><h2 id="2024-12-11"><a href="#2024-12-11" class="headerlink" title="2024-12-11"></a>2024-12-11</h2><h3 id="list-1-6"><a href="#list-1-6" class="headerlink" title="list 1"></a>list 1</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>visible</td><td>visibility</td><td>invisible</td></tr><tr><td>revise</td><td>supervise</td><td>supervisor</td></tr><tr><td>vision</td><td>visionary</td><td>envisage</td></tr><tr><td>visualize</td><td>expectancy</td><td>expectation</td></tr><tr><td>unexpected</td><td>inspect</td><td>perspective</td></tr><tr><td>prospect</td><td>prospective</td><td>spectacle</td></tr><tr><td>spectacular</td><td>spectator</td><td>suspect</td></tr><tr><td>speculate</td><td>speculation</td><td>speculative</td></tr><tr><td>suspicion</td><td>suspicious</td><td>despise</td></tr><tr><td>foresight</td><td>insight</td><td>oversee</td></tr><tr><td>oversignt</td><td>coordinate</td><td>subordinate</td></tr><tr><td>oral</td><td>esteem</td><td>nurture</td></tr><tr><td>nutrition</td><td>nourish</td><td>distinct</td></tr><tr><td>distinctive</td><td>distinguishable</td><td>distinguished</td></tr><tr><td>extinguish</td><td>extinct</td><td>extinction</td></tr><tr><td>instinct</td><td>questionnare</td><td>quest</td></tr><tr><td>acquisition</td><td>inquire</td><td>inquiry</td></tr><tr><td>exquisite</td><td>layer</td><td>layout</td></tr><tr><td>lay-off</td><td>relay</td><td>compile</td></tr><tr><td>edition</td><td>editorial</td><td>justice</td></tr><tr><td>justification</td><td>justify</td><td>protest</td></tr><tr><td>testify</td><td>testimony</td><td>derive</td></tr><tr><td>rival</td><td>rating</td><td>ratio</td></tr><tr><td>ration</td><td>rational</td><td>irrational</td></tr><tr><td>minister</td><td>ministerial</td><td>ministry</td></tr><tr><td>administer</td><td>administration</td><td>administrative</td></tr></tbody></table><h3 id="list-2-7"><a href="#list-2-7" class="headerlink" title="list 2"></a>list 2</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>simultaneously</td><td>permanant</td><td>tempt</td></tr><tr><td>incorporate</td><td>unethical</td><td>unequal</td></tr><tr><td>lawfully</td><td>stain</td><td>reputation</td></tr><tr><td>delicate</td><td>stipulate</td><td>consistent</td></tr><tr><td>tip</td><td>demand</td><td>brand</td></tr><tr><td>intuitive</td><td>bolster</td><td>articulate</td></tr><tr><td>dairy</td><td>discourse</td><td>supposition</td></tr><tr><td>stigma</td><td>tread</td><td>verbal</td></tr><tr><td>broadly</td><td>devastate</td><td>warehouse</td></tr><tr><td>grocery</td><td>lane</td><td>stagger</td></tr><tr><td>trade</td><td>insecurity</td><td>peril</td></tr><tr><td>futile</td><td>inevitable</td><td>detrimental</td></tr><tr><td>sensible</td><td>overstate</td><td>prominent</td></tr><tr><td>upward</td><td>allege</td><td>erroneous</td></tr><tr><td>overview</td><td>dimension</td><td>trait</td></tr><tr><td>demographic</td><td>correlate</td><td>occupation</td></tr><tr><td>regard</td><td>authority</td><td>generalize</td></tr><tr><td>constrain</td><td>dwell</td><td></td></tr></tbody></table><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">total <span class="hljs-punctuation">=</span> <span class="hljs-keyword">Новый</span> <span class="hljs-built_in">Число</span><span class="hljs-punctuation">(</span><span class="hljs-number">78</span> <span class="hljs-punctuation">+</span> <span class="hljs-number">50</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure><h2 id="2024-12-12"><a href="#2024-12-12" class="headerlink" title="2024-12-12"></a>2024-12-12</h2><h3 id="list-2-8"><a href="#list-2-8" class="headerlink" title="list 2"></a>list 2</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>pledge</td><td>surpass</td><td>volume</td></tr><tr><td>affirm</td><td>differentiate</td><td>domian</td></tr><tr><td>formidable</td><td>overstate</td><td>term</td></tr><tr><td>loan</td><td>prevalent</td><td>intermediary</td></tr><tr><td>optimize</td><td>utterly</td><td>sneak</td></tr><tr><td>proficent</td><td>immerse</td><td>immersive</td></tr><tr><td>sprinkle</td><td>systematic</td><td>explicit</td></tr><tr><td>explicitly</td><td>notorious</td><td>legislature</td></tr><tr><td>systhesize</td><td>disprove</td><td>deliberate</td></tr><tr><td>repute</td><td>arbitrarily</td><td>convene</td></tr></tbody></table><h2 id="translate-1"><a href="#translate-1" class="headerlink" title="translate 1"></a>translate 1</h2><h3 id="Original-text"><a href="#Original-text" class="headerlink" title="Original text"></a>Original text</h3><p>中国盛产竹子，是最早开发利用竹资源的国家。竹子在中国分布广泛，品种丰富。竹子实用性强，用于生产和生活的许多方面，如筷子、桌椅的制作和桥梁、房屋的建造。中国人爱竹，自古以来就有无数文人以竹为主题，创作了绚丽多彩的文学和绘画作品。竹子主干(stem)笔直，象征正直的品格。竹子具有强大的生命力和适应能力，无论环境多么恶劣，都能够顽强生存，因而寓意坚韧不拔的精神。几千年来，竹子一直被视为中华民族品格的象征。</p><h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><p><strong>中国盛产竹子，是最早开发利用竹资源的国家。</strong><br><strong>China boasts abundant bamboo production, and stands as the earliest country to develop and utilize bamboo resources.</strong><br>词语：boast, abundant, utilize.<br>短语：stand as</p><p><strong>竹子在中国分布广泛，品种丰富。</strong><br><strong>Bamboo is widely distributed in China, and rich in variety.</strong><br>词语：widely, distributed, variety.<br>短语：rich in variety</p><p><strong>竹子实用性强，用于生产和生活的许多方面，如筷子、桌椅的制作和桥梁、房屋的建造。</strong><br><strong>Known for its high practicality, it is used in many aspects of production and daliy life, such as the making of chopsticks, tables and chairs, as well as the construction of bridges and houses.</strong><br>词语：practicality, chopstic.<br>短语：known for, high practicality, daliy life, such as … as well as</p><p><strong>中国人爱竹，自古以来就有无数文人以竹为主题，创作了绚丽多彩的文学和绘画作品。</strong><br><strong>Chinese people’s love for bamboo has been enduring, and since ancient times, countless literati have created colorful literacy and artistic works with bamboo as the theme.</strong><br>词语：endure, countless, literatus, literati, literacy, artistic.<br>短语：since the ancient times, artistic work, as the theme</p><p><strong>竹子主干(stem)笔直，象征正直的品格。</strong><br><strong>Bamboo, known for its straight stem, symbolizes integrity.</strong><br>词语：symbolize, integrity.</p><p><strong>竹子具有强大的生命力和适应能力，无论环境多么恶劣，都能够顽强生存，因而寓意坚韧不拔的精神。</strong><br><strong>Its powerful vitality and adaptability allow it to thrive in any adverse conditions, thereby signifying unyeilding perseverance.</strong><br>词语：powerful, vitality, adaptability, thrive, adverse, thereby, signify, unyield, perseverance.<br>短语：thrive in, adverse condition</p><p><strong>几千年来，竹子一直被视为中华民族品格的象征。</strong><br><strong>For thousands of years, bamboo has been regarded as a symbol of the character of the Chinese nation.</strong><br>词语：character, nation.<br>短语：regard as, Chinese nation</p><h2 id="translate-2"><a href="#translate-2" class="headerlink" title="translate 2"></a>translate 2</h2><h3 id="Original-text-1"><a href="#Original-text-1" class="headerlink" title="Original text"></a>Original text</h3><p>中国的传统婚礼习俗历史悠久，从周朝开始就逐渐形成了一套完整的婚礼仪式，有些一直沿用至今。如今的中式婚礼习俗已有很大变化，但婚礼庆典仍然十分隆重。婚礼场地经过精心装饰，以象征喜庆（jubilance）的红色为主色调，摆放着许多祝愿新人幸福的物件。在婚礼上，新人要拜天地（bow to Heaven and Earth）、拜父母和相互对拜，然后设宴招待宾客，并向宾客敬酒致谢。今天，许多年轻人依然钟情于传统的中式婚礼，体验独特而美好的中国式浪漫。</p><h3 id="Translation-1"><a href="#Translation-1" class="headerlink" title="Translation"></a>Translation</h3><p><strong>中国的传统婚礼习俗历史悠久，从周朝开始就逐渐形成了一套完整的婚礼仪式，有些一直沿用至今。</strong><br>*<em>The traditional Chinese wedding customs, which gradually formed a complete set of ceremonyies</em></p><p><span class="fuck">不学了，傻逼英语</span></p><p>听力扣了 5 分，阅读扣了 6 分，嘻嘻</p>]]></content>
    
    
    
    <tags>
      
      <tag>Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>miniob 初赛参赛总结</title>
    <link href="/2024/11/11/miniob/"/>
    <url>/2024/11/11/miniob/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>参加这个比赛其实主要目的是赚钱（感谢周师姐的校友基金，最后含泪收下 7000￥ ），所以以下很多内容可能并不专业。</p><p>最终的结果是全国第 40 名，进决赛一共有 50 个队伍，不过由于加权压力（目前估计加权相较于大二上要掉 6 分左右），决赛不一定会付出太多心血去打了。</p><p>感谢我的队友 Sazikk 和我一起熬夜肝代码，并且忍耐我的屎山代码长达 21 天之久。由于屎山太多了，所以出现屎的部分会标注。</p><blockquote><p>Sazikk 个人博客：<a href="https://sazikk.github.io/">https://sazikk.github.io</a>  目前已有数十万的观看量（狗头<br>我们的项目：<a href="https://github.com/SaZiKK/miniob-2024">https://github.com/SaZiKK/miniob-2024</a><br>806 官方链接：<a href="https://ustb-806.github.io/blogs/2024/11/oceanbase/">https://ustb-806.github.io/blogs/2024/11/oceanbase/</a></p></blockquote><h2 id="个人心得"><a href="#个人心得" class="headerlink" title="个人心得"></a>个人心得</h2><p>参加这个比赛需要什么能力：</p><ol><li>较强的 C++ 开发能力</li><li>一定的 SQL 语言理解能力</li><li>对 miniob 内核有较好的理解</li></ol><h2 id="miniob-框架解析"><a href="#miniob-框架解析" class="headerlink" title="miniob 框架解析"></a>miniob 框架解析</h2><h2 id="我负责的题目"><a href="#我负责的题目" class="headerlink" title="我负责的题目"></a>我负责的题目</h2><h3 id="drop-table"><a href="#drop-table" class="headerlink" title="drop table"></a>drop table</h3><p><img src="/img/drop_table.png"></p><p>题目要求删除某个表格，一个表格的信息包括三种：数据信息 + 索引信息 + 表格元数据</p><ol><li>数据信息：真实存放到表格当中的数据</li><li>索引信息：一个索引对应一棵 B+ 树</li><li>表格元数据：各种表格的描述信息</li></ol><p>drop table 不需要算子，需要执行器</p><h4 id="前端-lex-yacc-完善"><a href="#前端-lex-yacc-完善" class="headerlink" title="前端 lex yacc 完善"></a>前端 lex yacc 完善</h4><p>lex 加入关键字 DROP</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">DROP                                    <span class="hljs-title">RETURN_TOKEN</span><span class="hljs-params">(DROP)</span></span>;<br></code></pre></td></tr></table></figure><p>yacc 加入语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">drop_table_stmt:<br>    DROP TABLE ID &#123;<br>      $$ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ParsedSqlNode</span>(SCF_DROP_TABLE);<br>      $$-&gt;drop_table.relation_name = $<span class="hljs-number">3</span>;<br>      <span class="hljs-built_in">free</span>($<span class="hljs-number">3</span>);<br>    &#125;;<br></code></pre></td></tr></table></figure><h4 id="STMT-设计"><a href="#STMT-设计" class="headerlink" title="STMT 设计"></a>STMT 设计</h4><p>删除表格只需要表格的表名，当然正常来说在 STMT 级就应该通过表格名称获取到实际的 Table 了，但是当时写的时候放到了 Db 的删除表格函数中。</p><h4 id="EXECUTE-设计"><a href="#EXECUTE-设计" class="headerlink" title="EXECUTE 设计"></a>EXECUTE 设计</h4><p>在执行器中通过调用 db 的删除表格函数或者 table 的自毁函数。表格的自毁函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">RC <span class="hljs-title">Table::drop</span><span class="hljs-params">()</span> </span>&#123;<br><br>  <span class="hljs-comment">// 删除数据文件 data_file</span><br>  string data_file = <span class="hljs-built_in">table_data_file</span>(base_dir_.<span class="hljs-built_in">c_str</span>(), table_meta_.<span class="hljs-built_in">name</span>());<br>  <span class="hljs-built_in">unlink</span>(data_file.<span class="hljs-built_in">c_str</span>());<br><br>  <span class="hljs-comment">// 删除索引文件 index_file</span><br>  <span class="hljs-type">int</span> indexNum = table_meta_.<span class="hljs-built_in">index_num</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; indexNum; i++) &#123;<br>    <span class="hljs-keyword">auto</span> *index_meta = table_meta_.<span class="hljs-built_in">index</span>(i);<br>    string index_file = <span class="hljs-built_in">table_index_file</span>(base_dir_.<span class="hljs-built_in">c_str</span>(), table_meta_.<span class="hljs-built_in">name</span>(), index_meta-&gt;<span class="hljs-built_in">name</span>());<br>    <span class="hljs-built_in">unlink</span>(index_file.<span class="hljs-built_in">c_str</span>());<br>  &#125;<br><br>  <span class="hljs-comment">// 删除元文件 meta_file</span><br>  string meta_file = <span class="hljs-built_in">table_meta_file</span>(base_dir_.<span class="hljs-built_in">c_str</span>(), table_meta_.<span class="hljs-built_in">name</span>());<br>  <span class="hljs-built_in">unlink</span>(meta_file.<span class="hljs-built_in">c_str</span>());<br><br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p><img src="/img/update.png"></p><p>虽然题目只要求单字段的更新，但是由于后面很快就要扩充，所以下面直接放完整版。</p><p>需要注意的有两点，如何将 在某些字段修改为某值 推得 在内存某些位置修改二进制数据；以及对于多个字段的更新，必须同时成功或失败，也即先判断后修改（或回滚），不仅有单个字段间的回滚，还有单个元组间的回滚。</p><p>update 语句不需要执行器，需要算子</p><h4 id="前端-lex-yacc-完善-1"><a href="#前端-lex-yacc-完善-1" class="headerlink" title="前端 lex yacc 完善"></a>前端 lex yacc 完善</h4><p>lex 加入关键字 UPDATE</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">UPDATE                                  <span class="hljs-title">RETURN_TOKEN</span><span class="hljs-params">(UPDATE)</span></span>;<br></code></pre></td></tr></table></figure><p>yacc 加入语句<br>其中 update_target 为一个字段的更新，update_target_list 为若干字段的更新，where 为谓词表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++">update_stmt:      <span class="hljs-comment">/*  update 语句的语法解析树*/</span><br>    UPDATE ID SET update_target update_target_list where <br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ParsedSqlNode</span>(SCF_UPDATE);<br>      $$-&gt;update.relation_name = $<span class="hljs-number">2</span>;<br><br>      <span class="hljs-keyword">if</span> ($<span class="hljs-number">6</span> != <span class="hljs-literal">nullptr</span>) &#123;<br>        $$-&gt;update.conditions.<span class="hljs-built_in">swap</span>(*$<span class="hljs-number">6</span>);<br>        <span class="hljs-keyword">delete</span> $<span class="hljs-number">6</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span>($<span class="hljs-number">5</span> != <span class="hljs-literal">nullptr</span>)<br>        $$-&gt;update.update_targets.<span class="hljs-built_in">swap</span>(*$<span class="hljs-number">5</span>);<br>      $$-&gt;update.update_targets.<span class="hljs-built_in">emplace_back</span>(*$<span class="hljs-number">4</span>);<br>      std::<span class="hljs-built_in">reverse</span>($$-&gt;update.update_targets.<span class="hljs-built_in">begin</span>(), $$-&gt;update.update_targets.<span class="hljs-built_in">end</span>());<br>    &#125;<br>    ;<br></code></pre></td></tr></table></figure><p>对于 ParseSqlNode，新增 update 语句对应的 node。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UpdateSqlNode</span> &#123;<br>  std::string relation_name;                <span class="hljs-comment">// 更新表格名称</span><br>  std::vector&lt;UpdateTarget&gt; update_targets; <span class="hljs-comment">// 更新字段集合</span><br>  std::vector&lt;ConditionSqlNode&gt; conditions; <span class="hljs-comment">// 谓词条件</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UpdateTarget</span> &#123;<br>  <span class="hljs-type">bool</span> is_value;                            <span class="hljs-comment">// 是否为简单值，本题视作 true</span><br>  Value value;                              <span class="hljs-comment">// 更新的值</span><br>  std::string attribute_name;               <span class="hljs-comment">// 更新的属性名</span><br>  SubSelectSqlNode *sub_select;             <span class="hljs-comment">// 子查询，后面习题涉及</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="STMT-设计-1"><a href="#STMT-设计-1" class="headerlink" title="STMT 设计"></a>STMT 设计</h4><p>update 语句对应的 STMT 中包含：所有修改域信息(FieldMeta)，目标表格，筛选对应的 STMT(FilterStmt)，以及处理好的 UpdateTarget 数组。</p><p>第一步，拿到表格</p><p>第二步，通过所有修改域的名称，拿到全部修改域，注意顺序是不重要的，因为它们都是同时成功或同时失败的。</p><p>第三步，如果有子查询需要将子查询转化为一个 Value，后面对应的题再解释。</p><h4 id="逻辑算子和物理算子设计"><a href="#逻辑算子和物理算子设计" class="headerlink" title="逻辑算子和物理算子设计"></a>逻辑算子和物理算子设计</h4><p>逻辑算子中需要包含表格以及一个数组，数组表示需要更新的域和值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">Table *table_ = <span class="hljs-literal">nullptr</span>;<br>std::vector&lt;std::pair&lt;Value, FieldMeta&gt;&gt; update_map_;<br></code></pre></td></tr></table></figure><p>物理算子直接继承逻辑算子中的表格和&lt;域, 值&gt;数组，除此之外还需要包含一个 Record 数组，因为我们要处理单个元组的回滚。在存在 unique index 的情境下，一条 update 语句可能对多个元组进行修改，<br>如果修改时发现某一条元组的修改是非法的，则之前所有的修改都要撤回。此处存放修改前的 Record 数组方便回滚。而对于单个字段的回滚，我们采取先判断合法再修改的策略，也即只有全部字段的修改都是有效的<br>才会开始实际的修改。</p><p>例如： </p><table><thead><tr><th>id</th><th>num</th><th>col</th></tr></thead><tbody><tr><td>id1</td><td>num1</td><td>col1</td></tr><tr><td>id2</td><td>num2</td><td>col2</td></tr><tr><td>id3</td><td>num3</td><td>col3</td></tr></tbody></table><p>update 语句需要修改第一个元组和第三个元组的 id, col 字段。</p><p>元组级别的回滚：更新第一个元组没问题，但是更新第三个元组是非法的。</p><p>字段级别的回滚：更新某个元组时，更新 id 域没问题，但是更新 col 域是非法的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">Table *table_ = <span class="hljs-literal">nullptr</span>;<br>Trx *trx_ = <span class="hljs-literal">nullptr</span>;<br>std::vector&lt;std::pair&lt;Value, FieldMeta&gt;&gt; update_map_;<br>std::vector&lt;Record&gt; records_;<br></code></pre></td></tr></table></figure><p>物理算子 open 函数设计：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// main_tuple 涉及到复杂子查询</span><br><span class="hljs-function">RC <span class="hljs-title">UpdatePhysicalOperator::open</span><span class="hljs-params">(Trx *trx, <span class="hljs-type">const</span> Tuple *main_tuple)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (children_.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-keyword">return</span> RC::SUCCESS;<br>  &#125;<br><br>  std::unique_ptr&lt;PhysicalOperator&gt; &amp;child = children_[<span class="hljs-number">0</span>];<br><br>  <span class="hljs-comment">// 调用子算子的 open 函数</span><br>  RC rc = child-&gt;<span class="hljs-built_in">open</span>(trx, main_tuple);<br>  <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to open child operator: %s&quot;</span>, <span class="hljs-built_in">strrc</span>(rc));<br>    <span class="hljs-keyword">return</span> rc;<br>  &#125;<br><br>  trx_ = trx;<br><br>  <span class="hljs-comment">// 收集全部元组</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">OB_SUCC</span>(rc = child-&gt;<span class="hljs-built_in">next</span>(main_tuple))) &#123;<br>    Tuple *tuple = child-&gt;<span class="hljs-built_in">current_tuple</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == tuple) &#123;<br>      <span class="hljs-keyword">return</span> rc;<br>    &#125;<br><br>    RowTuple *row_tuple = <span class="hljs-built_in">static_cast</span>&lt;RowTuple *&gt;(tuple);<br>    Record &amp;record = row_tuple-&gt;<span class="hljs-built_in">record</span>();<br>    records_.<span class="hljs-built_in">emplace_back</span>(std::<span class="hljs-built_in">move</span>(record));<br>  &#125;<br><br>  child-&gt;<span class="hljs-built_in">close</span>();<br><br>  <span class="hljs-keyword">if</span> (records_.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;no records to update&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 将这些元组数据拷贝到一个新数组中，用于回滚</span><br>  std::vector&lt;<span class="hljs-type">char</span> *&gt; backup_datas;<br>  <span class="hljs-keyword">for</span> (Record &amp;record : records_) &#123;<br>    Record backup_record;<br>    <span class="hljs-type">char</span> *old_data = record.<span class="hljs-built_in">data</span>();<br>    <span class="hljs-type">char</span> *backup_data = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(record.<span class="hljs-built_in">len</span>());<br>    <span class="hljs-built_in">memcpy</span>(backup_data, old_data, record.<span class="hljs-built_in">len</span>());<br><br>    backup_datas.<span class="hljs-built_in">push_back</span>(backup_data);<br>  &#125;<br><br>  <span class="hljs-type">size_t</span> update_num = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 先收集记录再更新</span><br>  <span class="hljs-keyword">for</span> (Record &amp;record : records_) &#123;<br>    rc = trx_-&gt;<span class="hljs-built_in">update_records</span>(table_, record, update_map_);<br>    ++update_num;<br>    <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) &#123;<br>      <span class="hljs-comment">// 如果更新失败，需要回滚，重新将修改过的元组复原</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">int</span>)update_num; ++i) &#123;<br>        <span class="hljs-type">char</span> *backup_data = backup_datas[i];<br>        Record &amp;record = records_[i];<br><br>        record.<span class="hljs-built_in">set_data</span>(backup_data);<br>        table_-&gt;<span class="hljs-built_in">record_handler</span>()-&gt;<span class="hljs-built_in">update_record</span>(&amp;record);<br>      &#125;<br>      <span class="hljs-keyword">return</span> rc;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>update 算子一般没有上层算子，所以不需要 next 函数，open 函数中调用了子算子的 close 函数，所以也不需要 close 函数。但理论上子算子的 close 函数放到 update 算子的 close 函数中会更好。<br>不过 delete 算子中也是这么写的，所以此处不修改了。</p><h3 id="expression"><a href="#expression" class="headerlink" title="expression"></a>expression</h3><p><img src="/img/expression.png"></p><h4 id="将万物都改成-expression-的过程"><a href="#将万物都改成-expression-的过程" class="headerlink" title="将万物都改成 expression 的过程"></a>将万物都改成 expression 的过程</h4><p>1.将谓词语句的 value&#x2F;field op value&#x2F;field 结构改成 expression op expression<br>2.初始的 FilterObj 中的 expression 只能是 value&#x2F;field，扩展使得 expression 可以是任何类型</p><p>之前提到过，在 select 语句中，会将查询的表达式进行绑定，例如将 UnboundField 绑定为 Field。在 Filter 部分，如果想要支持任何类型的 expression，也需要绑定的环节。miniob 初始的框架只包含了对 UnboundField 的绑定，<br>也即只完成了通过名字寻找特定域的功能。</p><p>理论上，应该模仿 select 语句的绑定，使用 ExpressionBinder 类来完成绑定的行为，但当时写的过于潦草，采用了纯粹的 switch 来完成。例如在下面的代码中完成了对表达式 expr 的绑定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// use_flag 是弃用的(时间关系未删除)，alias_map 为别名部分，table_map 为复杂子查询中的传递情况</span><br><span class="hljs-comment">// expr 是需要绑定的表达式，也是一条谓词语句的一端</span><br><span class="hljs-function">RC <span class="hljs-title">FilterStmt::bind_filter_expr</span><span class="hljs-params">(Db *db, Table *default_table, std::unordered_map&lt;std::string, Table *&gt; *tables, unique_ptr&lt;Expression&gt; &amp;expr,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-type">bool</span> &amp;use_flag, std::unordered_map&lt;string, string&gt; alias_map, std::unordered_map&lt;string, Table *&gt; table_map)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (expr == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br><br>  <span class="hljs-comment">// TODO 直接使用 expression_binder 中的函数进行</span><br><br>  <span class="hljs-comment">// 根据表达式的不同类型需要进行不同的操作</span><br>  <span class="hljs-keyword">switch</span> (expr-&gt;<span class="hljs-built_in">type</span>()) &#123;<br>    <span class="hljs-keyword">case</span> ExprType::VALUE: &#123;<br>      Value value;<br>      RC rc = expr-&gt;<span class="hljs-built_in">try_get_value</span>(value);<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>      <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">attr_type</span>() == AttrType::DATE &amp;&amp; !DateType::<span class="hljs-built_in">check_date</span>(&amp;value)) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ExprType::VALUELIST: &#123;<br>      std::vector&lt;Value&gt; value_list;<br>      RC rc = expr-&gt;<span class="hljs-built_in">get_value_list</span>(value_list);<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : value_list)<br>        <span class="hljs-keyword">if</span> (it.<span class="hljs-built_in">attr_type</span>() == AttrType::DATE &amp;&amp; !DateType::<span class="hljs-built_in">check_date</span>(&amp;it)) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ExprType::SUBQUERY: &#123;<br>      <span class="hljs-keyword">return</span> RC::SUCCESS;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ExprType::UNBOUND_FIELD: &#123;<br>      Table *table = <span class="hljs-literal">nullptr</span>;<br>      <span class="hljs-type">const</span> FieldMeta *field = <span class="hljs-literal">nullptr</span>;<br>      RC rc = <span class="hljs-built_in">get_table_and_field</span>(db, default_table, tables, expr.<span class="hljs-built_in">get</span>(), table, field, use_flag, alias_map, table_map);<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>      expr = std::<span class="hljs-built_in">make_unique</span>&lt;FieldExpr&gt;(table, field);<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ExprType::ARITHMETIC: &#123;<br>      RC rc = RC::SUCCESS;<br>      ArithmeticExpr *arith_expr = <span class="hljs-built_in">static_cast</span>&lt;ArithmeticExpr *&gt;(expr.<span class="hljs-built_in">get</span>());<br>      <span class="hljs-keyword">if</span> (arith_expr-&gt;<span class="hljs-built_in">left</span>() != <span class="hljs-literal">nullptr</span>) &#123;<br>        rc = <span class="hljs-built_in">bind_filter_expr</span>(db, default_table, tables, arith_expr-&gt;<span class="hljs-built_in">left</span>(), use_flag, alias_map, table_map);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>      <span class="hljs-keyword">if</span> (arith_expr-&gt;<span class="hljs-built_in">right</span>() != <span class="hljs-literal">nullptr</span>) &#123;<br>        rc = <span class="hljs-built_in">bind_filter_expr</span>(db, default_table, tables, arith_expr-&gt;<span class="hljs-built_in">right</span>(), use_flag, alias_map, table_map);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ExprType::VECFUNC: &#123;<br>      RC rc = RC::SUCCESS;<br>      VecFuncExpr *vec_func_expr = <span class="hljs-built_in">static_cast</span>&lt;VecFuncExpr *&gt;(expr.<span class="hljs-built_in">get</span>());<br>      <span class="hljs-keyword">if</span> (vec_func_expr-&gt;<span class="hljs-built_in">child_left</span>() != <span class="hljs-literal">nullptr</span>) &#123;<br>        rc = <span class="hljs-built_in">bind_filter_expr</span>(db, default_table, tables, vec_func_expr-&gt;<span class="hljs-built_in">child_left</span>(), use_flag, alias_map, table_map);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>      <span class="hljs-keyword">if</span> (vec_func_expr-&gt;<span class="hljs-built_in">child_right</span>() != <span class="hljs-literal">nullptr</span>) &#123;<br>        rc = <span class="hljs-built_in">bind_filter_expr</span>(db, default_table, tables, vec_func_expr-&gt;<span class="hljs-built_in">child_right</span>(), use_flag, alias_map, table_map);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ExprType::UNBOUND_AGGREGATION: &#123;<br>      RC rc = RC::SUCCESS;<br>      <span class="hljs-keyword">auto</span> unbound_aggregate_expr = <span class="hljs-built_in">static_cast</span>&lt;UnboundAggregateExpr *&gt;(expr.<span class="hljs-built_in">get</span>());<br>      string name = unbound_aggregate_expr-&gt;<span class="hljs-built_in">name</span>();<br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *aggregate_name = unbound_aggregate_expr-&gt;<span class="hljs-built_in">aggregate_name</span>();<br><br>      AggregateExpr::Type aggregate_type;<br>      rc = AggregateExpr::<span class="hljs-built_in">type_from_string</span>(aggregate_name, aggregate_type);<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br><br>      unique_ptr&lt;Expression&gt; &amp;child_expr = unbound_aggregate_expr-&gt;<span class="hljs-built_in">child</span>();<br><br>      <span class="hljs-keyword">if</span> (child_expr == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br><br>      <span class="hljs-keyword">if</span> (child_expr-&gt;<span class="hljs-built_in">type</span>() == ExprType::STAR &amp;&amp; aggregate_type == AggregateExpr::Type::COUNT) &#123;<br>        ValueExpr *value_expr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ValueExpr</span>(<span class="hljs-built_in">Value</span>(<span class="hljs-number">1</span>));<br>        child_expr.<span class="hljs-built_in">reset</span>(value_expr);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        rc = <span class="hljs-built_in">bind_filter_expr</span>(db, default_table, tables, child_expr, use_flag, alias_map, table_map);<br>        <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>      &#125;<br><br>      <span class="hljs-comment">// TODO 校验聚合表达式</span><br>      expr = <span class="hljs-built_in">make_unique</span>&lt;AggregateExpr&gt;(aggregate_type, std::<span class="hljs-built_in">move</span>(child_expr));<br>      expr-&gt;<span class="hljs-built_in">set_name</span>(name);<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，FilterObj 也需要改成 expression，而不是之前的 field&#x2F;value 模式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FilterObj</span> &#123;<br>  std::unique_ptr&lt;Expression&gt; expr;<br>  <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(FilterObj &amp;obj) &#123; <span class="hljs-keyword">this</span>-&gt;expr = std::<span class="hljs-built_in">move</span>(obj.expr); &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(std::unique_ptr&lt;Expression&gt; expr)</span> </span>&#123; <span class="hljs-keyword">this</span>-&gt;expr = std::<span class="hljs-built_in">move</span>(expr); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 yacc 中，也需要进行修改，condition 部分需要改成左右都为 expression。其中虽然我们将子查询也设计成了表达式，但是在解析的时候，子查询并不算为 expression，否则会出现冲突。<br>所以此处我们先通过 sub_select_stmt 来识别，在后面将其转化为 expression，从而和其他 expression 一起处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C++">expression comp_op<br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> ConditionSqlNode;<br>      $$-&gt;left_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;right_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;comp = $<span class="hljs-number">2</span>;<br>      $$-&gt;left_expression = $<span class="hljs-number">1</span>;<br>      $$-&gt;right_expression = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ValueExpr</span>(<span class="hljs-built_in">Value</span>(<span class="hljs-number">114514</span>));<br>    &#125;<br>    | expression comp_op sub_select_stmt<br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> ConditionSqlNode;<br>      $$-&gt;left_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;right_is_sub_query = <span class="hljs-literal">true</span>;<br>      $$-&gt;comp = $<span class="hljs-number">2</span>;<br>      $$-&gt;left_expression = $<span class="hljs-number">1</span>;<br>      $$-&gt;right_sub_query = $<span class="hljs-number">3</span>;<br>      $$-&gt;right_expression = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    | sub_select_stmt comp_op sub_select_stmt<br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> ConditionSqlNode;<br>      $$-&gt;left_is_sub_query = <span class="hljs-literal">true</span>;<br>      $$-&gt;right_is_sub_query = <span class="hljs-literal">true</span>;<br>      $$-&gt;comp = $<span class="hljs-number">2</span>;<br>      $$-&gt;left_sub_query = $<span class="hljs-number">1</span>;<br>      $$-&gt;left_expression = <span class="hljs-literal">nullptr</span>;<br>      $$-&gt;right_sub_query = $<span class="hljs-number">3</span>;<br>      $$-&gt;right_expression = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    | sub_select_stmt comp_op expression<br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> ConditionSqlNode;<br>      $$-&gt;left_is_sub_query = <span class="hljs-literal">true</span>;<br>      $$-&gt;right_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;comp = $<span class="hljs-number">2</span>;<br>      $$-&gt;left_sub_query = $<span class="hljs-number">1</span>;<br>      $$-&gt;left_expression = <span class="hljs-literal">nullptr</span>;<br>      $$-&gt;right_expression = $<span class="hljs-number">3</span>;<br>    &#125;<br>    | expression comp_op expression<br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> ConditionSqlNode;<br>      $$-&gt;left_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;right_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;comp = $<span class="hljs-number">2</span>;<br>      $$-&gt;left_expression = $<span class="hljs-number">1</span>;<br>      $$-&gt;right_expression = $<span class="hljs-number">3</span>;<br>    &#125;<br>    | comp_op sub_select_stmt<br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> ConditionSqlNode;<br>      $$-&gt;left_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;right_is_sub_query = <span class="hljs-literal">true</span>;<br>      $$-&gt;right_sub_query = $<span class="hljs-number">2</span>;<br>      $$-&gt;comp = $<span class="hljs-number">1</span>;<br>      $$-&gt;left_expression = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ValueExpr</span>(<span class="hljs-built_in">Value</span>(<span class="hljs-number">114514</span>));<br>    &#125;<br>    | expression comp_op LBRACE value value_list RBRACE %prec HIGHER_THAN_EXPRESSION<br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> ConditionSqlNode;<br>      $$-&gt;left_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;right_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;comp = $<span class="hljs-number">2</span>;<br>      $$-&gt;left_expression = $<span class="hljs-number">1</span>;<br>      $<span class="hljs-number">5</span>-&gt;<span class="hljs-built_in">push_back</span>(*$<span class="hljs-number">4</span>);<br>      $$-&gt;right_expression = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ValueListExpr</span>(*$<span class="hljs-number">5</span>);<br>    &#125;<br>    ;<br></code></pre></td></tr></table></figure><p>在后面的日子中，我们将能改的都改成了 expression，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 表达式类型</span><br><span class="hljs-comment"> * @ingroup Expression</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">ExprType</span> &#123;<br>  NONE,<br>  STAR,                 <span class="hljs-comment">///&lt; 星号，表示所有字段</span><br>  UNBOUND_FIELD,        <span class="hljs-comment">///&lt; 未绑定的字段，需要在resolver阶段解析为FieldExpr</span><br>  UNBOUND_TABLE,        <span class="hljs-comment">///&lt; 未绑定的表明，需要在resolver阶段提取别名和原名</span><br>  UNBOUND_AGGREGATION,  <span class="hljs-comment">///&lt; 未绑定的聚合函数，需要在resolver阶段解析为AggregateExpr</span><br><br>  ALIAS,        <span class="hljs-comment">///&lt; 别名</span><br>  FIELD,        <span class="hljs-comment">///&lt; 字段。在实际执行时，根据行数据内容提取对应字段的值</span><br>  JOINTABLE,    <span class="hljs-comment">///&lt; join 字段</span><br>  ORDERBY,      <span class="hljs-comment">///&lt; order 字段</span><br>  VALUE,        <span class="hljs-comment">///&lt; 常量值</span><br>  VALUELIST,    <span class="hljs-comment">///&lt; 常量值列表</span><br>  CAST,         <span class="hljs-comment">///&lt; 需要做类型转换的表达式</span><br>  COMPARISON,   <span class="hljs-comment">///&lt; 需要做比较的表达式</span><br>  CONJUNCTION,  <span class="hljs-comment">///&lt; 多个表达式使用同一种关系(AND或OR)来联结</span><br>  ARITHMETIC,   <span class="hljs-comment">///&lt; 算术运算</span><br>  AGGREGATION,  <span class="hljs-comment">///&lt; 聚合运算</span><br>  SUBQUERY,     <span class="hljs-comment">///&lt; 子查询</span><br>  FUNC,         <span class="hljs-comment">///&lt; 函数运算</span><br>  VECFUNC,      <span class="hljs-comment">///&lt; 向量函数运算</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="修改逻辑算子生成器"><a href="#修改逻辑算子生成器" class="headerlink" title="修改逻辑算子生成器"></a>修改逻辑算子生成器</h4><p>在逻辑算子的生成过程中，原始的 miniob 会将 Filter 中的 field&#x2F;value 变成表达式，很明显现在这是多此一举，对此进行修改。</p><p>需要注意的是，当一个 STMT 创建算子之后，原来的全部 unique_ptr 都会被移动走，在子查询里，应该还会看到这句话。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">RC <span class="hljs-title">LogicalPlanGenerator::create_plan</span><span class="hljs-params">(FilterStmt *filter_stmt, unique_ptr&lt;LogicalOperator&gt; &amp;logical_operator)</span> </span>&#123;<br>  RC rc = RC::SUCCESS;<br>  std::vector&lt;unique_ptr&lt;Expression&gt;&gt; cmp_exprs;<br>  ConjunctionExpr::Type conjunction_types = ConjunctionExpr::Type::AND;<br>  <span class="hljs-type">const</span> std::vector&lt;FilterUnit *&gt; &amp;filter_units = filter_stmt-&gt;<span class="hljs-built_in">filter_units</span>();<br>  <span class="hljs-keyword">for</span> (FilterUnit *filter_unit : filter_units) &#123;<br>    FilterObj &amp;filter_obj_left = filter_unit-&gt;<span class="hljs-built_in">left</span>();<br>    FilterObj &amp;filter_obj_right = filter_unit-&gt;<span class="hljs-built_in">right</span>();<br><br>    unique_ptr&lt;Expression&gt; left = std::<span class="hljs-built_in">move</span>(filter_obj_left.expr);<br>    unique_ptr&lt;Expression&gt; right = std::<span class="hljs-built_in">move</span>(filter_obj_right.expr);<br><br>    <span class="hljs-keyword">if</span> (filter_unit-&gt;<span class="hljs-built_in">conjunction_type</span>() == <span class="hljs-number">1</span>)<br>      conjunction_types = ConjunctionExpr::Type::AND;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (filter_unit-&gt;<span class="hljs-built_in">conjunction_type</span>() == <span class="hljs-number">2</span>)<br>      conjunction_types = ConjunctionExpr::Type::OR;<br><br>    <span class="hljs-type">bool</span> need_value_cast = left-&gt;<span class="hljs-built_in">value_type</span>() != AttrType::TUPLES &amp;&amp; right-&gt;<span class="hljs-built_in">value_type</span>() != AttrType::TUPLES &amp;&amp; left-&gt;<span class="hljs-built_in">type</span>() != ExprType::VALUELIST &amp;&amp;<br>                           right-&gt;<span class="hljs-built_in">type</span>() != ExprType::VALUELIST &amp;&amp; filter_unit-&gt;<span class="hljs-built_in">comp</span>() != CompOp::XXX_IS_NULL &amp;&amp;<br>                           filter_unit-&gt;<span class="hljs-built_in">comp</span>() != CompOp::XXX_IS_NOT_NULL;<br><br>    <span class="hljs-comment">// 如果左右两边的类型不一致，需要先计算转换开销，再进行隐式类型转换，同时要排除有子查询的情况</span><br>    <span class="hljs-keyword">if</span> (need_value_cast) &#123;<br>      Value left_value, right_value;<br>      left-&gt;<span class="hljs-built_in">try_get_value</span>(left_value);<br>      right-&gt;<span class="hljs-built_in">try_get_value</span>(right_value);<br>      <span class="hljs-keyword">if</span> (!left_value.<span class="hljs-built_in">get_null</span>() &amp;&amp; !right_value.<span class="hljs-built_in">get_null</span>() &amp;&amp; left-&gt;<span class="hljs-built_in">value_type</span>() != right-&gt;<span class="hljs-built_in">value_type</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> left_to_right_cost = <span class="hljs-built_in">implicit_cast_cost</span>(left-&gt;<span class="hljs-built_in">value_type</span>(), right-&gt;<span class="hljs-built_in">value_type</span>());<br>        <span class="hljs-keyword">auto</span> right_to_left_cost = <span class="hljs-built_in">implicit_cast_cost</span>(right-&gt;<span class="hljs-built_in">value_type</span>(), left-&gt;<span class="hljs-built_in">value_type</span>());<br>        <span class="hljs-keyword">if</span> (left_to_right_cost &lt;= right_to_left_cost &amp;&amp; left_to_right_cost != INT32_MAX) &#123;<br>          ExprType left_type = left-&gt;<span class="hljs-built_in">type</span>();<br><br>          <span class="hljs-comment">// 特殊判断，如果为 INTS 和 CHARS 比较大小，均转换成 FLOATS 类型</span><br>          unique_ptr&lt;CastExpr&gt; cast_expr;<br>          <span class="hljs-keyword">if</span> (left-&gt;<span class="hljs-built_in">value_type</span>() == AttrType::CHARS &amp;&amp; right-&gt;<span class="hljs-built_in">value_type</span>() == AttrType::INTS)<br>            cast_expr = <span class="hljs-built_in">make_unique</span>&lt;CastExpr&gt;(std::<span class="hljs-built_in">move</span>(left), AttrType::FLOATS);<br>          <span class="hljs-keyword">else</span><br>            cast_expr = <span class="hljs-built_in">make_unique</span>&lt;CastExpr&gt;(std::<span class="hljs-built_in">move</span>(left), right-&gt;<span class="hljs-built_in">value_type</span>());<br>          <span class="hljs-keyword">if</span> (left_type == ExprType::VALUE) &#123;<br>            Value left_val;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">OB_FAIL</span>(rc = cast_expr-&gt;<span class="hljs-built_in">try_get_value</span>(left_val))) &#123;<br>              <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to get value from left child&quot;</span>, <span class="hljs-built_in">strrc</span>(rc));<br>              <span class="hljs-keyword">return</span> rc;<br>            &#125;<br>            left = <span class="hljs-built_in">make_unique</span>&lt;ValueExpr&gt;(left_val);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = std::<span class="hljs-built_in">move</span>(cast_expr);<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right_to_left_cost &lt; left_to_right_cost &amp;&amp; right_to_left_cost != INT32_MAX) &#123;<br>          ExprType right_type = right-&gt;<span class="hljs-built_in">type</span>();<br><br>          <span class="hljs-comment">// 特殊判断，如果为 INTS 和 CHARS 比较大小，均转换成 FLOATS 类型</span><br>          unique_ptr&lt;CastExpr&gt; cast_expr;<br>          <span class="hljs-keyword">if</span> (left-&gt;<span class="hljs-built_in">value_type</span>() == AttrType::INTS &amp;&amp; right-&gt;<span class="hljs-built_in">value_type</span>() == AttrType::CHARS)<br>            cast_expr = <span class="hljs-built_in">make_unique</span>&lt;CastExpr&gt;(std::<span class="hljs-built_in">move</span>(right), AttrType::FLOATS);<br>          <span class="hljs-keyword">else</span><br>            cast_expr = <span class="hljs-built_in">make_unique</span>&lt;CastExpr&gt;(std::<span class="hljs-built_in">move</span>(right), left-&gt;<span class="hljs-built_in">value_type</span>());<br><br>          <span class="hljs-keyword">if</span> (right_type == ExprType::VALUE) &#123;<br>            Value right_val;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">OB_FAIL</span>(rc = cast_expr-&gt;<span class="hljs-built_in">try_get_value</span>(right_val))) &#123;<br>              <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to get value from right child&quot;</span>, <span class="hljs-built_in">strrc</span>(rc));<br>              <span class="hljs-keyword">return</span> rc;<br>            &#125;<br>            right = <span class="hljs-built_in">make_unique</span>&lt;ValueExpr&gt;(right_val);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = std::<span class="hljs-built_in">move</span>(cast_expr);<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (filter_unit-&gt;<span class="hljs-built_in">comp</span>() == CompOp::LIKE_XXX || filter_unit-&gt;<span class="hljs-built_in">comp</span>() == CompOp::NOT_LIKE_XXX) &#123;<br>          ExprType right_type = right-&gt;<span class="hljs-built_in">type</span>();<br><br>          <span class="hljs-comment">// 如果执行LIKE运算符，把右边转化成CHARS类型</span><br>          unique_ptr&lt;CastExpr&gt; cast_expr;<br>          cast_expr = <span class="hljs-built_in">make_unique</span>&lt;CastExpr&gt;(std::<span class="hljs-built_in">move</span>(right), AttrType::CHARS);<br><br>          <span class="hljs-keyword">if</span> (right_type == ExprType::VALUE) &#123;<br>            Value right_val;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">OB_FAIL</span>(rc = cast_expr-&gt;<span class="hljs-built_in">try_get_value</span>(right_val))) &#123;<br>              <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to get value from right child&quot;</span>, <span class="hljs-built_in">strrc</span>(rc));<br>              <span class="hljs-keyword">return</span> rc;<br>            &#125;<br>            right = <span class="hljs-built_in">make_unique</span>&lt;ValueExpr&gt;(right_val);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = std::<span class="hljs-built_in">move</span>(cast_expr);<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          rc = RC::UNSUPPORTED;<br>          <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;unsupported cast from %s to %s&quot;</span>, <span class="hljs-built_in">attr_type_to_string</span>(left-&gt;<span class="hljs-built_in">value_type</span>()), <span class="hljs-built_in">attr_type_to_string</span>(right-&gt;<span class="hljs-built_in">value_type</span>()));<br>          <span class="hljs-keyword">return</span> rc;<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    ComparisonExpr *cmp_expr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ComparisonExpr</span>(filter_unit-&gt;<span class="hljs-built_in">comp</span>(), std::<span class="hljs-built_in">move</span>(left), std::<span class="hljs-built_in">move</span>(right));<br><br>    cmp_exprs.<span class="hljs-built_in">emplace_back</span>(cmp_expr);<br>  &#125;<br><br>  unique_ptr&lt;PredicateLogicalOperator&gt; predicate_oper;<br>  <span class="hljs-keyword">if</span> (!cmp_exprs.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-function">unique_ptr&lt;ConjunctionExpr&gt; <span class="hljs-title">conjunction_expr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> ConjunctionExpr(conjunction_types, cmp_exprs))</span></span>;<br>    predicate_oper = <span class="hljs-built_in">unique_ptr</span>&lt;PredicateLogicalOperator&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">PredicateLogicalOperator</span>(std::<span class="hljs-built_in">move</span>(conjunction_expr)));<br>  &#125;<br><br>  logical_operator = std::<span class="hljs-built_in">move</span>(predicate_oper);<br>  <span class="hljs-keyword">return</span> rc;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LogicalPlanGenerator::implicit_cast_cost</span><span class="hljs-params">(AttrType from, AttrType to)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (from == to) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> DataType::<span class="hljs-built_in">type_instance</span>(from)-&gt;<span class="hljs-built_in">cast_cost</span>(to);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="vector-basic"><a href="#vector-basic" class="headerlink" title="vector_basic"></a>vector_basic</h3><p><img src="/img/vector_basic.png"></p><p>相对简单的一道题目，需要添加一种数据类型：VECTOR</p><p>我们采取的方式为，对于 ‘[1, 2, 3, 4]’ 这样的向量，先以字符串的形式输入进来，在 Value 的构造函数中进行格式检验，如果符合向量的格式，那么将其转化为向量存储，否则以字符串的方式存储。</p><p>有些边角的东西没有体现在下面的描述中，包括：插入向量时的长度不匹配问题 + 创建表格时的 VECTOR 长度检验等</p><h4 id="Value-类的完善"><a href="#Value-类的完善" class="headerlink" title="Value 类的完善"></a>Value 类的完善</h4><p>首先，由于向量一定是 float 类型，所以实际的存储形式为 vector<float>。Value 中有个字段 len，表示 Value 的长度，注意这个长度是占用空间的长度，对于 vector 来说，这个长度是 vector.size() * 4。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// vector part</span><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// 判断一个字符串是否为向量形式</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">isValidFormat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *input)</span></span>;<br>  <span class="hljs-comment">// 判断一个字符串是否为数字，避免 [1, a, 2] 这样的例子</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">isValidNumber</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;s)</span></span>;<br>  <span class="hljs-comment">// 将字符串转化为 vector，如果字符串不合法，返回 FAILURE</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> RC <span class="hljs-title">string_to_vector</span><span class="hljs-params">(string str, vector&lt;<span class="hljs-type">float</span>&gt; &amp;result)</span></span>;<br><br>  <span class="hljs-comment">// set and get</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_vector</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">float</span>&gt; value_vector)</span></span>;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">get_vector</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">get_vector_item</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_vector_size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  std::vector&lt;<span class="hljs-type">float</span>&gt; value_vector_;<br></code></pre></td></tr></table></figure><p>isValidFormat, isValidNumber, string_to_vector 的设计如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// vector part</span><br><br><span class="hljs-comment">// 用于检查输入字符串是否符合 vector 的格式</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Value::isValidFormat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *input)</span> </span>&#123;<br>  <span class="hljs-comment">// 检查是否为空或长度小于2（必须至少包含 &quot;[]&quot;)</span><br>  <span class="hljs-keyword">if</span> (input == <span class="hljs-literal">nullptr</span> || <span class="hljs-built_in">strlen</span>(input) &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 检查首尾是否分别为 &#x27;[&#x27; 和 &#x27;]&#x27;</span><br>  <span class="hljs-keyword">if</span> (input[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;[&#x27;</span> || input[<span class="hljs-built_in">strlen</span>(input) - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 剔除 &#x27;[&#x27; 和 &#x27;]&#x27;，从第二个字符开始检查</span><br>  <span class="hljs-function">std::string <span class="hljs-title">content</span><span class="hljs-params">(input + <span class="hljs-number">1</span>, strlen(input) - <span class="hljs-number">2</span>)</span></span>;<br><br>  <span class="hljs-comment">// 删除多余的空格</span><br>  content.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">remove</span>(content.<span class="hljs-built_in">begin</span>(), content.<span class="hljs-built_in">end</span>(), <span class="hljs-string">&#x27; &#x27;</span>), content.<span class="hljs-built_in">end</span>());<br><br>  <span class="hljs-comment">// 使用逗号分割内容</span><br>  <span class="hljs-function">std::istringstream <span class="hljs-title">ss</span><span class="hljs-params">(content)</span></span>;<br>  std::string token;<br>  std::vector&lt;std::string&gt; tokens;<br><br>  <span class="hljs-comment">// 分割内容并检查每个部分</span><br>  <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(ss, token, <span class="hljs-string">&#x27;,&#x27;</span>)) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isValidNumber</span>(token)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 如果某个部分不是有效的数字，返回 false</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 所有部分都是有效的数字</span><br>&#125;<br><br><span class="hljs-comment">// 用于检查一个字符串是否是整数或浮点数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Value::isValidNumber</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;s)</span> </span>&#123;<br>  <span class="hljs-function">std::istringstream <span class="hljs-title">stream</span><span class="hljs-params">(s)</span></span>;<br>  <span class="hljs-type">float</span> number;<br>  stream &gt;&gt; number;<br>  <span class="hljs-comment">// 检查是否成功解析为数字，并且没有多余字符</span><br>  <span class="hljs-keyword">return</span> stream.<span class="hljs-built_in">eof</span>() &amp;&amp; !stream.<span class="hljs-built_in">fail</span>();<br>&#125;<br><br><span class="hljs-function">RC <span class="hljs-title">Value::string_to_vector</span><span class="hljs-params">(string str, vector&lt;<span class="hljs-type">float</span>&gt; &amp;result)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!Value::<span class="hljs-built_in">isValidFormat</span>(str.<span class="hljs-built_in">c_str</span>())) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br><br>  <span class="hljs-comment">// 剔除 &#x27;[&#x27; 和 &#x27;]&#x27;，从第二个字符开始检查</span><br>  str = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, (<span class="hljs-type">int</span>)str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>);<br><br>  <span class="hljs-comment">// 去除多余空格</span><br>  str.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">remove</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>(), <span class="hljs-string">&#x27; &#x27;</span>), str.<span class="hljs-built_in">end</span>());<br><br>  <span class="hljs-comment">// 使用逗号分割内容</span><br>  <span class="hljs-function">std::istringstream <span class="hljs-title">ss</span><span class="hljs-params">(str)</span></span>;<br>  std::string token;<br>  std::vector&lt;std::string&gt; tokens;<br><br>  <span class="hljs-comment">// 分割内容并检查每个部分</span><br>  <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(ss, token, <span class="hljs-string">&#x27;,&#x27;</span>)) &#123;<br>    result.<span class="hljs-built_in">push_back</span>(FloatType::formatFloat(std::<span class="hljs-built_in">stof</span>(token), <span class="hljs-number">2</span>));<br>  &#125;<br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来是 Value 输入为字符串的构造函数，如果发现字符串的格式为数组形式，那么转化为 VECTOR。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">Value::<span class="hljs-built_in">Value</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> len <span class="hljs-comment">/*= 0*/</span>) &#123;<br>  vector&lt;<span class="hljs-type">float</span>&gt; value_vector;<br>  RC rc = Value::<span class="hljs-built_in">string_to_vector</span>(s, value_vector);<br>  <span class="hljs-keyword">if</span> (rc == RC::SUCCESS)<br>    <span class="hljs-built_in">set_vector</span>(value_vector);<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">set_string</span>(s, len);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来是 Value 和 data 的转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Value::set_data</span><span class="hljs-params">(<span class="hljs-type">char</span> *data, <span class="hljs-type">int</span> length)</span> </span>&#123;<br>  <span class="hljs-keyword">switch</span> (attr_type_) &#123;<br>    <span class="hljs-keyword">case</span> AttrType::CHARS: &#123;<br>      <span class="hljs-built_in">set_string</span>(data, length);<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::INTS: &#123;<br>      value_.int_value_ = *(<span class="hljs-type">int</span> *)data;<br>      length_ = length;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::FLOATS: &#123;<br>      value_.float_value_ = *(<span class="hljs-type">float</span> *)data;<br>      length_ = length;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::BOOLEANS: &#123;<br>      value_.bool_value_ = *(<span class="hljs-type">int</span> *)data != <span class="hljs-number">0</span>;<br>      length_ = length;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::DATE: &#123;<br>      value_.int_value_ = *(<span class="hljs-type">int</span> *)data;<br>      length_ = length;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::VECTORS: &#123;<br>      <span class="hljs-type">size_t</span> element_size = <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br>      <span class="hljs-type">size_t</span> num_elements = length / element_size;<br><br>      <span class="hljs-comment">// 使用 memcpy 将数据复制回 vector</span><br>      value_vector_.<span class="hljs-built_in">resize</span>(num_elements);<br>      <span class="hljs-built_in">memcpy</span>(value_vector_.<span class="hljs-built_in">data</span>(), data, length);<br>      length_ = length;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::TEXT: &#123;<br>      <span class="hljs-built_in">set_text</span>(data);<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>: &#123;<br>      <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;unknown data type: %d&quot;</span>, attr_type_);<br>    &#125; <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">Value::data</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">switch</span> (attr_type_) &#123;<br>    <span class="hljs-keyword">case</span> AttrType::TEXT: &#123;<br>      <span class="hljs-keyword">return</span> value_.pointer_value_;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::CHARS: &#123;<br>      <span class="hljs-keyword">return</span> value_.pointer_value_;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::VECTORS: &#123;<br>      <span class="hljs-keyword">return</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)(value_vector_.<span class="hljs-built_in">data</span>());<br>    &#125;<br>    <span class="hljs-keyword">default</span>: &#123;<br>      <span class="hljs-keyword">return</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)&amp;value_;<br>    &#125; <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="VECTOR-的各种运算"><a href="#VECTOR-的各种运算" class="headerlink" title="VECTOR 的各种运算"></a>VECTOR 的各种运算</h4><p>在 common&#x2F;type 中，还需要完成有关 VECTOR 的各种计算、比较等。由于比较简单这里直接放上来了，不过需要注意的是，比赛要求向量的乘法是逐位相乘，也即两个向量的乘积仍为向量：[1, 2, 3] * [4, 5, 6] &#x3D; [4, 10, 18]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">VectorType::compare</span><span class="hljs-params">(<span class="hljs-type">const</span> Value &amp;left, <span class="hljs-type">const</span> Value &amp;right)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (left.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || right.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || left.<span class="hljs-built_in">get_vector_size</span>() != right.<span class="hljs-built_in">get_vector_size</span>())<br>    <span class="hljs-keyword">return</span> INT32_MAX;<br>  <span class="hljs-type">int</span> size = (<span class="hljs-type">int</span>)left.<span class="hljs-built_in">get_vector_size</span>();<br>  <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>    <span class="hljs-keyword">if</span> (left.<span class="hljs-built_in">get_vector</span>()[i] &gt; right.<span class="hljs-built_in">get_vector</span>()[i]) &#123;<br>      result = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left.<span class="hljs-built_in">get_vector</span>()[i] &lt; right.<span class="hljs-built_in">get_vector</span>()[i]) &#123;<br>      result = <span class="hljs-number">-1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function">RC <span class="hljs-title">VectorType::add</span><span class="hljs-params">(<span class="hljs-type">const</span> Value &amp;left, <span class="hljs-type">const</span> Value &amp;right, Value &amp;result)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (left.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || right.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || left.<span class="hljs-built_in">get_vector_size</span>() != right.<span class="hljs-built_in">get_vector_size</span>())<br>    <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>  <span class="hljs-type">int</span> size = (<span class="hljs-type">int</span>)left.<span class="hljs-built_in">get_vector_size</span>();<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">answer</span><span class="hljs-params">(size, <span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) answer[i] = left.<span class="hljs-built_in">get_vector</span>()[i] + right.<span class="hljs-built_in">get_vector</span>()[i];<br>  result.<span class="hljs-built_in">set_vector</span>(answer);<br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br><span class="hljs-function">RC <span class="hljs-title">VectorType::subtract</span><span class="hljs-params">(<span class="hljs-type">const</span> Value &amp;left, <span class="hljs-type">const</span> Value &amp;right, Value &amp;result)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (left.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || right.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || left.<span class="hljs-built_in">get_vector_size</span>() != right.<span class="hljs-built_in">get_vector_size</span>())<br>    <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>  <span class="hljs-type">int</span> size = (<span class="hljs-type">int</span>)left.<span class="hljs-built_in">get_vector_size</span>();<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">answer</span><span class="hljs-params">(size, <span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) answer[i] = left.<span class="hljs-built_in">get_vector</span>()[i] - right.<span class="hljs-built_in">get_vector</span>()[i];<br>  result.<span class="hljs-built_in">set_vector</span>(answer);<br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br><span class="hljs-function">RC <span class="hljs-title">VectorType::multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Value &amp;left, <span class="hljs-type">const</span> Value &amp;right, Value &amp;result)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (left.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || right.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || left.<span class="hljs-built_in">get_vector_size</span>() != right.<span class="hljs-built_in">get_vector_size</span>())<br>    <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>  <span class="hljs-type">int</span> size = (<span class="hljs-type">int</span>)left.<span class="hljs-built_in">get_vector_size</span>();<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">answer</span><span class="hljs-params">(size, <span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) answer[i] = left.<span class="hljs-built_in">get_vector</span>()[i] * right.<span class="hljs-built_in">get_vector</span>()[i];<br>  result.<span class="hljs-built_in">set_vector</span>(answer);<br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br><br><span class="hljs-function">RC <span class="hljs-title">VectorType::to_string</span><span class="hljs-params">(<span class="hljs-type">const</span> Value &amp;val, string &amp;result)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (val.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br><br>  result = <span class="hljs-string">&quot;[&quot;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : val.<span class="hljs-built_in">get_vector</span>()) &#123;<br>    it = FloatType::formatFloat(it, <span class="hljs-number">2</span>);<br>    string str = std::<span class="hljs-built_in">to_string</span>(it);<br>    str = FloatType::formatFloat_s(it, <span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// 去除后导零</span><br>    str.<span class="hljs-built_in">erase</span>(str.<span class="hljs-built_in">find_last_not_of</span>(<span class="hljs-string">&#x27;0&#x27;</span>) + <span class="hljs-number">1</span>, std::string::npos);<br>    <span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">back</span>() == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>      str.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    result += str;<br>    result += <span class="hljs-string">&#x27;,&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">int</span>)result.<span class="hljs-built_in">length</span>() &gt; <span class="hljs-number">1</span>) result.<span class="hljs-built_in">pop_back</span>();<br>  result += <span class="hljs-string">&quot;]&quot;</span>;<br><br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="vector-format"><a href="#vector-format" class="headerlink" title="vector_format"></a>vector_format</h3><p><img src="/img/vector_format.png"></p><p>题目要求不仅要识别字符串类型的向量数据，还需要识别不带引号的向量数据。我在写的时候偷懒了，直接采取 [ + value + value_list + ]，所以只需要在 yacc 中添加这一条规则即可。</p><h4 id="lex-和-yacc-完善"><a href="#lex-和-yacc-完善" class="headerlink" title="lex 和 yacc 完善"></a>lex 和 yacc 完善</h4><p>lex 需要添加左右中括号的词语：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-string">&quot;[&quot;</span>                                     <span class="hljs-built_in">RETURN_TOKEN</span>(LBRACKET);<br><span class="hljs-string">&quot;]&quot;</span>                                     <span class="hljs-built_in">RETURN_TOKEN</span>(RBRACKET);<br></code></pre></td></tr></table></figure><p>yacc 需要添加对向量变量的识别：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">value:<br>    LBRACKET value value_list RBRACKET &#123;<br>      std::vector&lt;<span class="hljs-type">float</span>&gt; nums;<br>      nums.<span class="hljs-built_in">emplace_back</span>($<span class="hljs-number">2</span>-&gt;<span class="hljs-built_in">get_float</span>());<br>      <span class="hljs-keyword">if</span>($<span class="hljs-number">3</span> != <span class="hljs-literal">nullptr</span>) &#123;<br>        std::<span class="hljs-built_in">reverse</span>($<span class="hljs-number">3</span>-&gt;<span class="hljs-built_in">begin</span>(), $<span class="hljs-number">3</span>-&gt;<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (Value value : *$<span class="hljs-number">3</span>) &#123;<br>          nums.<span class="hljs-built_in">emplace_back</span>(value.<span class="hljs-built_in">get_float</span>());<br>        &#125;<br>      &#125;<br>      $$ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Value</span>(nums);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="join-tables"><a href="#join-tables" class="headerlink" title="join-tables"></a>join-tables</h3><p><img src="/img/join_tables.png"></p><p>join-tables 所涉及的算子在初始工程已经很完善了。简单来说，对于一条 select 语句可能有多个目标表格，其中第一个目标表格为主表格，后面的表格会跟主表格一并做笛卡尔积。创建算子的时候，第一个表格会创建 TableGet 相关算子，后面的表格会创建 JoinTable 相关算子。</p><p>对于 INNERJOIN，ON 中定义的谓词逻辑和 WHERE 中定义的谓词逻辑是完全平等的，所以，对于 ON 中的全部谓词逻辑，我们只需要将其视作 WHERE 中通过 AND 连结词连在一起的即可。</p><p>对于 join 部分，将其视作一个表达式，原因见 expression。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// *********************************************************</span><br><span class="hljs-comment">// * 表格连接表达式</span><br><span class="hljs-comment">// *</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JoinTableExpr</span> : <span class="hljs-keyword">public</span> Expression &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">JoinTableExpr</span>(std::vector&lt;ConditionSqlNode&gt; conditions, unique_ptr&lt;Expression&gt; child) : <span class="hljs-built_in">conditions_</span>(conditions), <span class="hljs-built_in">child_</span>(std::<span class="hljs-built_in">move</span>(child)) &#123;&#125;<br>  <span class="hljs-built_in">JoinTableExpr</span>(std::vector&lt;ConditionSqlNode&gt; conditions, Expression *child) : <span class="hljs-built_in">conditions_</span>(conditions), <span class="hljs-built_in">child_</span>(child) &#123;&#125;<br><br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">JoinTableExpr</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-function">ExprType <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> ExprType::JOINTABLE; &#125;<br>  <span class="hljs-function">AttrType <span class="hljs-title">value_type</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> AttrType::UNDEFINED; &#125;<br><br>  <span class="hljs-function">RC <span class="hljs-title">get_value</span><span class="hljs-params">(<span class="hljs-type">const</span> Tuple &amp;tuple, Value &amp;value)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> RC::INTERNAL; &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">const</span> std::vector&lt;ConditionSqlNode&gt; <span class="hljs-title">conditions</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> conditions_; &#125;<br>  <span class="hljs-function"><span class="hljs-type">const</span> std::unique_ptr&lt;Expression&gt; &amp;<span class="hljs-title">child</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> child_; &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  std::vector&lt;ConditionSqlNode&gt; conditions_;<br>  std::unique_ptr&lt;Expression&gt; child_;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="lex-和-yacc-的完善"><a href="#lex-和-yacc-的完善" class="headerlink" title="lex 和 yacc 的完善"></a>lex 和 yacc 的完善</h4><p>lex 需要完善对 JOIN&#x2F;INNER JOIN&#x2F;ON 的识别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">JOIN|INNER[ \t]+<span class="hljs-function">JOIN                    <span class="hljs-title">RETURN_TOKEN</span><span class="hljs-params">(INNER_JOIN)</span></span>;<br><span class="hljs-function">ON                                      <span class="hljs-title">RETURN_TOKEN</span><span class="hljs-params">(ON)</span></span>;<br></code></pre></td></tr></table></figure><p>对于 join 子句的部分，创建一个 expression 数组，数组的 expression 类型为 JoinTableExpr，每一个 JoinTableExpr 包含 join 的表格以及谓词逻辑语句。</p><p>select_stmt 也需要加入 join_list 部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++">join_list:<br>    <span class="hljs-comment">/* empty */</span><br>    &#123;<br>      $$ = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    | INNER_JOIN relation ON condition_list join_list &#123;<br>      <span class="hljs-keyword">if</span> ($<span class="hljs-number">5</span> != <span class="hljs-literal">nullptr</span>) &#123;<br>        $$ = $<span class="hljs-number">5</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        $$ = <span class="hljs-keyword">new</span> std::vector&lt;std::unique_ptr&lt;Expression&gt;&gt;;<br>      &#125;<br>      $$-&gt;<span class="hljs-built_in">emplace_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">JoinTableExpr</span>(*$<span class="hljs-number">4</span>, $<span class="hljs-number">2</span>));<br>    &#125;<br>    ;<br></code></pre></td></tr></table></figure><h4 id="select-stmt-的完善"><a href="#select-stmt-的完善" class="headerlink" title="select_stmt 的完善"></a>select_stmt 的完善</h4><p>在创建 SelectStmt 时，需要将 join 的表格和谓词语句添加到 select 语句中的表格列表和谓词语句列表中。谓词语句顺序无所谓，但是表格的顺序会影响输出表头的顺序，所以需要严格按照 JOIN 出现的顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// *****************************************************************************</span><br>  <span class="hljs-comment">// * 将节点中的 join 添加到 conditions 以及 relations 当中</span><br>  <span class="hljs-comment">// *    在之后的处理中，如果查询的表格有多个，就会计算全部表格的笛卡尔积</span><br>  <span class="hljs-comment">// *    join 等价于先求笛卡尔积，然后进行选择运算</span><br>  <span class="hljs-comment">// *    所以需要将选择条件也加进 conditions 中(目前全是 AND 运算，所以可以这么处理)</span><br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; select_sql.join.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    JoinTableExpr *join_table_expr = <span class="hljs-built_in">static_cast</span>&lt;JoinTableExpr *&gt;(select_sql.join[i].<span class="hljs-built_in">get</span>());<br>    UnboundTableExpr *table_expr = <span class="hljs-built_in">static_cast</span>&lt;UnboundTableExpr *&gt;(join_table_expr-&gt;<span class="hljs-built_in">child</span>().<span class="hljs-built_in">get</span>());<br>    unique_ptr&lt;Expression&gt; temp = <span class="hljs-built_in">make_unique</span>&lt;UnboundTableExpr&gt;(table_expr-&gt;<span class="hljs-built_in">table_name</span>(), table_expr-&gt;<span class="hljs-built_in">table_alias</span>());<br>    select_sql.relations.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">move</span>(temp));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> condition : join_table_expr-&gt;<span class="hljs-built_in">conditions</span>()) select_sql.conditions.<span class="hljs-built_in">emplace_back</span>(condition);<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p><img src="/img/null.png"></p><p>题目要求支持一种特殊的数据类型：null，它不属于任何普通类型，却又能匹配任何普通类型。</p><p>整体来说，需要完成以下内容：</p><ol><li>支持识别关键字 NULL IS NOT 等</li><li>支持创建表格时对特定域声明 NULL or NOT NULL &#x3D; default</li><li>Value 类中添加对 NULL 的管理</li><li>支持插入数据时插入 NULL，并判断合法性</li><li>支持更新数据时更新 NULL，并判断合法性</li><li>支持谓词逻辑普通运算符对 NULL 计算，以及谓词逻辑新增运算 IS NULL and IS NOT NULL</li></ol><p>额外需要考虑的一点为，Value 会被转换成 Record 写入内存，也即实际写入内存的是 01 串，而通过 01 串并不能知道这是什么类型。假设某个域类型为 INT，它可以通过表头信息知道：从该列拿出来的数据一定是 INT 类型，所以可以将 01 串按照 INT 的存储规则还原，但是对于 NULL 类型，由于其可以匹配任意类型，所以并不能通过某处记录的信息来得知拿出来的数据为 NULL 类型。</p><p>我们的处理是 bitmap 或者 写入特殊字符，使用 bitmap 会导致后面的并发 update 报错，至比赛结束仍不知道原因。不过 bitmap 无疑是最优美的解决方案。</p><blockquote><p>—- WARING  下文有狗屎 —-</p></blockquote><p>所以我们的处理方法是，对于一个 x 字节的数据，如果它的类型为 NULL，则向内存写入数据时，写入 x 字节的 ÿ，就是如此抽象。拿出数据时，首先检验 01 串是否为 x 字节的 ÿ 的 ASCII 码，<br>如果是则还原成 NULL，不是则根据表头信息等还原。</p><h4 id="支持识别关键字-NULL-IS-NOT-等"><a href="#支持识别关键字-NULL-IS-NOT-等" class="headerlink" title="支持识别关键字 NULL IS NOT 等"></a>支持识别关键字 NULL IS NOT 等</h4><p>lex 中需要添加新的词语解析</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">NULL                                    <span class="hljs-built_in">RETURN_TOKEN</span>(NULLABLE);<br>NOT<span class="hljs-selector-attr">[ \t]</span>+NULL                           <span class="hljs-built_in">RETURN_TOKEN</span>(UNNULLABLE);<br>IS<span class="hljs-selector-attr">[ \t]</span>+NULL                            <span class="hljs-built_in">RETURN_TOKEN</span>(IS_NULL);<br>IS<span class="hljs-selector-attr">[ \t]</span>+NOT+<span class="hljs-selector-attr">[ \t]</span>+NULL                  <span class="hljs-built_in">RETURN_TOKEN</span>(IS_NOT_NULL);<br></code></pre></td></tr></table></figure><h4 id="支持创建表格时对特定域声明-NULL-or-NOT-NULL-default"><a href="#支持创建表格时对特定域声明-NULL-or-NOT-NULL-default" class="headerlink" title="支持创建表格时对特定域声明 NULL or NOT NULL &#x3D; default"></a>支持创建表格时对特定域声明 NULL or NOT NULL &#x3D; default</h4><p>yacc 中需要添加新的语法解析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 运算符</span><br>comp_op:<br>    ...<br>    | IS_NULL &#123; $$ = XXX_IS_NULL; &#125;<br>    | IS_NOT_NULL &#123; $$ = XXX_IS_NOT_NULL; &#125;<br>    | NOT_LIKE &#123; $$ = NOT_LIKE_XXX; &#125;<br>    ...<br>    ;<br><span class="hljs-comment">// 创建表格时的声明</span><br>attr_def:<br>    ID type LBRACE number RBRACE null_def <br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> AttrInfoSqlNode;<br>      $$-&gt;type = (AttrType)$<span class="hljs-number">2</span>;<br>      $$-&gt;name = $<span class="hljs-number">1</span>;<br>      $$-&gt;length = $<span class="hljs-number">4</span>;<br>      $$-&gt;can_be_null = $<span class="hljs-number">6</span>;<br><br>      ...<br><br>      <span class="hljs-built_in">free</span>($<span class="hljs-number">1</span>);<br>    &#125;<br><span class="hljs-comment">// null</span><br>null_def:<br>    &#123;<br>      $$ = <span class="hljs-literal">false</span>;<br>    &#125;<br>    | NULLABLE &#123;<br>      $$ = <span class="hljs-literal">true</span>;<br>    &#125;<br>    | UNNULLABLE &#123;<br>      $$ = <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="Value-类中添加对-NULL-的管理"><a href="#Value-类中添加对-NULL-的管理" class="headerlink" title="Value 类中添加对 NULL 的管理"></a>Value 类中添加对 NULL 的管理</h4><p>Value 中添加标志位 is_null_，用于判断 Value 是否为 NULL。同时还需要维护各种构造函数，拷贝函数，运算符重载有关 NULL 的问题。同时 NULL 数据转化为 char * 写入内存的<br>时候要转换成若干个 ÿ。</p><h4 id="支持插入数据时插入-NULL，并判断合法性"><a href="#支持插入数据时插入-NULL，并判断合法性" class="headerlink" title="支持插入数据时插入 NULL，并判断合法性"></a>支持插入数据时插入 NULL，并判断合法性</h4><p>在将 Value 转化为 Record 时，需要额外做一步判断。如果插入的数据为 NULL 且该域不允许为 NULL，返回 FAILURE。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">RC <span class="hljs-title">Table::make_record</span><span class="hljs-params">(<span class="hljs-type">int</span> value_num, <span class="hljs-type">const</span> Value *values, Record &amp;record)</span> </span>&#123;<br>  RC rc = RC::SUCCESS;<br>  <span class="hljs-comment">// 检查属性数量是否一致</span><br>  <span class="hljs-keyword">if</span> (value_num + table_meta_.<span class="hljs-built_in">sys_field_num</span>() != table_meta_.<span class="hljs-built_in">field_num</span>()) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;Input values don&#x27;t match the table&#x27;s schema, table name:%s&quot;</span>, table_meta_.<span class="hljs-built_in">name</span>());<br>    <span class="hljs-keyword">return</span> RC::SCHEMA_FIELD_MISSING;<br>  &#125;<br><br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> normal_field_start_index = table_meta_.<span class="hljs-built_in">sys_field_num</span>();<br>  <span class="hljs-comment">// 复制所有字段的值</span><br>  <span class="hljs-type">int</span> record_size = table_meta_.<span class="hljs-built_in">record_size</span>();<br>  <span class="hljs-type">char</span> *record_data = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(record_size);<br>  <span class="hljs-built_in">memset</span>(record_data, <span class="hljs-number">0</span>, record_size);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; value_num &amp;&amp; <span class="hljs-built_in">OB_SUCC</span>(rc); i++) &#123;<br>    <span class="hljs-type">const</span> FieldMeta *field = table_meta_.<span class="hljs-built_in">field</span>(i + normal_field_start_index);<br>    Value value = values[i];<br><br>    <span class="hljs-comment">// 当插入数据 NULL 时，做一次检验</span><br>    <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">get_null</span>()) &#123;<br>      <span class="hljs-keyword">if</span> (field-&gt;<span class="hljs-built_in">can_be_null</span>() == <span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to insert NULL to NOT_NULL field&quot;</span>);<br>        <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>      &#125;<br>      rc = <span class="hljs-built_in">set_value_to_record</span>(record_data, value, field, i);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (field-&gt;<span class="hljs-built_in">type</span>() != value.<span class="hljs-built_in">attr_type</span>()) &#123;<br>      Value real_value;<br>      rc = Value::<span class="hljs-built_in">cast_to</span>(value, field-&gt;<span class="hljs-built_in">type</span>(), real_value);<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">OB_FAIL</span>(rc)) &#123;<br>        <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to cast value. table name:%s,field name:%s,value:%s &quot;</span>, table_meta_.<span class="hljs-built_in">name</span>(), field-&gt;<span class="hljs-built_in">name</span>(), value.<span class="hljs-built_in">to_string</span>().<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      rc = <span class="hljs-built_in">set_value_to_record</span>(record_data, real_value, field, i);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      rc = <span class="hljs-built_in">set_value_to_record</span>(record_data, value, field, i);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">OB_FAIL</span>(rc)) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to make record. table name:%s&quot;</span>, table_meta_.<span class="hljs-built_in">name</span>());<br>    <span class="hljs-built_in">free</span>(record_data);<br>    <span class="hljs-keyword">return</span> rc;<br>  &#125;<br><br>  record.<span class="hljs-built_in">set_data_owner</span>(record_data, record_size);<br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时转换为 Record 时，也需要考虑 NULL 的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">get_null</span>()) &#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *flag = <span class="hljs-string">&quot;ÿÿÿÿ&quot;</span>;<br>  <span class="hljs-built_in">memcpy</span>(record_data + field-&gt;<span class="hljs-built_in">offset</span>(), flag, std::<span class="hljs-built_in">min</span>(field-&gt;<span class="hljs-built_in">len</span>(), <span class="hljs-number">4</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="支持更新数据时更新-NULL，并判断合法性"><a href="#支持更新数据时更新-NULL，并判断合法性" class="headerlink" title="支持更新数据时更新 NULL，并判断合法性"></a>支持更新数据时更新 NULL，并判断合法性</h4><p>和插入数据区别不大，也是需要额外添加一层判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 检查所有更新字段是否全部有效</span><br><span class="hljs-function">RC <span class="hljs-title">Table::update_records</span><span class="hljs-params">(Record &amp;record, std::vector&lt;std::pair&lt;Value, FieldMeta&gt;&gt; update_map_)</span> </span>&#123;<br>  <span class="hljs-comment">// 遍历表格的全部域，找到目标域</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> sys_field_num = table_meta_.<span class="hljs-built_in">sys_field_num</span>();<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> user_field_num = table_meta_.<span class="hljs-built_in">field_num</span>() - sys_field_num;<br>  FieldMeta *targetFiled = <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : update_map_) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; user_field_num; i++) &#123;<br>      <span class="hljs-type">const</span> FieldMeta *field_meta = table_meta_.<span class="hljs-built_in">field</span>(sys_field_num + i);<br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *field_name = field_meta-&gt;<span class="hljs-built_in">name</span>();<br><br>      <span class="hljs-comment">// 找到目标域</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(field_name, it.second.<span class="hljs-built_in">name</span>()) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 判断 NULL 值</span><br>        <span class="hljs-keyword">if</span> (it.first.<span class="hljs-built_in">get_null</span>()) &#123;<br>          <span class="hljs-keyword">if</span> (field_meta-&gt;<span class="hljs-built_in">can_be_null</span>() == <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>        &#125;<br>        <span class="hljs-comment">// 类型匹配检查</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (field_meta-&gt;<span class="hljs-built_in">type</span>() != it.first.<span class="hljs-built_in">attr_type</span>()) &#123;<br>          Value real_value;<br>          RC rc = Value::<span class="hljs-built_in">cast_to</span>(it.first, field_meta-&gt;<span class="hljs-built_in">type</span>(), real_value);<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">OB_FAIL</span>(rc)) <span class="hljs-keyword">return</span> rc;<br>        &#125;<br><br>        <span class="hljs-comment">// 拿到目标域</span><br>        targetFiled = (FieldMeta *)field_meta;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 域存在检查</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == targetFiled) &#123;<br>      <span class="hljs-keyword">return</span> RC::SCHEMA_FIELD_NOT_EXIST;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 暂时备份旧数据</span><br>  <span class="hljs-type">char</span> *old_data = record.<span class="hljs-built_in">data</span>();<br>  <span class="hljs-type">char</span> *backup_data = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(record.<span class="hljs-built_in">len</span>());<br>  <span class="hljs-built_in">memcpy</span>(backup_data, old_data, record.<span class="hljs-built_in">len</span>());<br><br>  <span class="hljs-comment">// 所有字段均可更新，开始更新</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : update_map_) &#123;<br>    RC rc = <span class="hljs-built_in">update_record</span>(record, it.second.<span class="hljs-built_in">name</span>(), &amp;it.first);<br>    <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>  &#125;<br><br>  <span class="hljs-comment">// 如果有索引，更新索引，顺便检查如果是唯一索引，那么是否有重复</span><br>  std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span> *&gt; update_fields;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : update_map_) &#123;<br>    update_fields.<span class="hljs-built_in">push_back</span>(it.second.<span class="hljs-built_in">name</span>());<br>  &#125;<br>  Index *index = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">find_index_by_fields</span>(update_fields);<br>  <span class="hljs-comment">// 只检查多索引，单列索引交给 update_record 处理</span><br>  <span class="hljs-keyword">if</span> (index != <span class="hljs-literal">nullptr</span> &amp;&amp; update_fields.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>    RC rc = index-&gt;<span class="hljs-built_in">insert_entry</span>(record.<span class="hljs-built_in">data</span>(), &amp;record.<span class="hljs-built_in">rid</span>());<br>    <span class="hljs-keyword">if</span> (rc != RC::SUCCESS &amp;&amp; <span class="hljs-built_in">strcmp</span>(old_data, backup_data) != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;Failed to update data, recovering. table=%s, rc=%d:%s&quot;</span>, <span class="hljs-built_in">name</span>(), rc, <span class="hljs-built_in">strrc</span>(rc));<br>      <span class="hljs-keyword">return</span> rc;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br><br><span class="hljs-comment">// 更新一个字段</span><br><span class="hljs-function">RC <span class="hljs-title">Table::update_record</span><span class="hljs-params">(Record &amp;record, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *attr_name, Value *value)</span> </span>&#123;<br>  <span class="hljs-comment">// 遍历表格的全部域，找到目标域</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> sys_field_num = table_meta_.<span class="hljs-built_in">sys_field_num</span>();<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> user_field_num = table_meta_.<span class="hljs-built_in">field_num</span>() - sys_field_num;<br>  FieldMeta *targetFiled = <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (; i &lt; user_field_num; i++) &#123;<br>    <span class="hljs-type">const</span> FieldMeta *field_meta = table_meta_.<span class="hljs-built_in">field</span>(sys_field_num + i);<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *field_name = field_meta-&gt;<span class="hljs-built_in">name</span>();<br><br>    <span class="hljs-comment">// 找到目标域</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(field_name, attr_name) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 判断 NULL 值</span><br>      <span class="hljs-keyword">if</span> (value-&gt;<span class="hljs-built_in">get_null</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (field_meta-&gt;<span class="hljs-built_in">can_be_null</span>() == <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>      &#125;<br>      <span class="hljs-comment">// 类型匹配检查</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (field_meta-&gt;<span class="hljs-built_in">type</span>() != value-&gt;<span class="hljs-built_in">attr_type</span>()) &#123;<br>        Value real_value;<br>        RC rc = Value::<span class="hljs-built_in">cast_to</span>(*value, field_meta-&gt;<span class="hljs-built_in">type</span>(), real_value);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">OB_FAIL</span>(rc)) <span class="hljs-keyword">return</span> rc;<br>        *value = std::<span class="hljs-built_in">move</span>(real_value);<br>      &#125;<br><br>      <span class="hljs-comment">// 拿到目标域</span><br>      targetFiled = (FieldMeta *)field_meta;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 域存在检查</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == targetFiled) &#123;<br>    <span class="hljs-keyword">return</span> RC::SCHEMA_FIELD_NOT_EXIST;<br>  &#125;<br><br>  <span class="hljs-type">int</span> field_offset = targetFiled-&gt;<span class="hljs-built_in">offset</span>();<br>  <span class="hljs-type">int</span> field_length = targetFiled-&gt;<span class="hljs-built_in">len</span>();<br><br>  <span class="hljs-comment">// 修改旧数据</span><br>  <span class="hljs-type">char</span> *old_data = record.<span class="hljs-built_in">data</span>();<br><br>  <span class="hljs-comment">// 暂时备份旧数据</span><br>  <span class="hljs-type">char</span> *backup_data = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(record.<span class="hljs-built_in">len</span>());<br>  <span class="hljs-built_in">memcpy</span>(backup_data, old_data, record.<span class="hljs-built_in">len</span>());<br><br>  <span class="hljs-keyword">if</span> (value-&gt;<span class="hljs-built_in">length</span>() &gt; field_length &amp;&amp; targetFiled-&gt;<span class="hljs-built_in">type</span>() != AttrType::VECTORS) &#123;<br>    <span class="hljs-built_in">memcpy</span>(old_data + field_offset, value-&gt;<span class="hljs-built_in">data</span>(), field_length);<br>  &#125;<br>  ...<br>  <span class="hljs-comment">// 对于 CHARS</span><br>  <span class="hljs-comment">// 这种不定长的记录，如果更新的元素小于原来的长度，需要额外抹去原有元素</span><br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">memcpy</span>(old_data + field_offset, value-&gt;<span class="hljs-built_in">data</span>(), value-&gt;<span class="hljs-built_in">length</span>());<br>    <span class="hljs-built_in">memset</span>(old_data + field_offset + value-&gt;<span class="hljs-built_in">length</span>(), <span class="hljs-number">0</span>, field_length - value-&gt;<span class="hljs-built_in">length</span>());<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (value-&gt;<span class="hljs-built_in">get_null</span>()) &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *flag = <span class="hljs-string">&quot;ÿÿÿÿ&quot;</span>;<br>    <span class="hljs-built_in">memcpy</span>(old_data + field_offset, flag, std::<span class="hljs-built_in">min</span>(<span class="hljs-number">4</span>, field_length));<br>  &#125;<br><br>  record.<span class="hljs-built_in">set_data</span>(old_data);<br><br>  Index *index = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">find_index_by_field</span>(targetFiled-&gt;<span class="hljs-built_in">name</span>());<br><br>  <span class="hljs-comment">// 单字段索引更新和检查</span><br>  <span class="hljs-keyword">if</span> (index != <span class="hljs-literal">nullptr</span>) &#123;<br>    RC rc = index-&gt;<span class="hljs-built_in">insert_entry</span>(record.<span class="hljs-built_in">data</span>(), &amp;record.<span class="hljs-built_in">rid</span>());<br>    <span class="hljs-keyword">if</span> (rc != RC::SUCCESS &amp;&amp; <span class="hljs-built_in">strcmp</span>(old_data, backup_data) != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;Failed to update data, recovering. table=%s, rc=%d:%s&quot;</span>, <span class="hljs-built_in">name</span>(), rc, <span class="hljs-built_in">strrc</span>(rc));<br>      <span class="hljs-keyword">return</span> rc;<br>    &#125;<br>  &#125;<br><br>  record_handler_-&gt;<span class="hljs-built_in">update_record</span>(&amp;record);<br>  <span class="hljs-comment">// delete old_data;</span><br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="支持谓词逻辑普通运算符对-NULL-计算，以及谓词逻辑新增运算-IS-NULL-and-IS-NOT-NULL"><a href="#支持谓词逻辑普通运算符对-NULL-计算，以及谓词逻辑新增运算-IS-NULL-and-IS-NOT-NULL" class="headerlink" title="支持谓词逻辑普通运算符对 NULL 计算，以及谓词逻辑新增运算 IS NULL and IS NOT NULL"></a>支持谓词逻辑普通运算符对 NULL 计算，以及谓词逻辑新增运算 IS NULL and IS NOT NULL</h4><p>由于 Compare 部分我们写的比较复杂，这边只展示有关 IS NULL and IS NOT NULL 的函数，对于普通运算符，只需要在最上方判断：如果为 NULL，直接返回 false。不过需要注意，后面涉及到排序题目的时候，不能无脑返回 false，需要特殊考虑 NULL 和 NULL 的比较。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IS_NULL_Compare</span><span class="hljs-params">(CompType type_, <span class="hljs-type">const</span> Value &amp;left, <span class="hljs-type">const</span> Value &amp;right, <span class="hljs-type">const</span> std::vector&lt;Value&gt; left_list, <span class="hljs-type">const</span> std::vector&lt;Value&gt; right_list,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> std::vector&lt;std::vector&lt;Value&gt;&gt; left_tuple_list, <span class="hljs-type">const</span> std::vector&lt;std::vector&lt;Value&gt;&gt; right_tuple_list)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (type_ == CompType::VAL_LIST || type_ == CompType::VAL_VAL || type_ == CompType::VAL_TUPLES) &#123;<br>    <span class="hljs-keyword">return</span> left.<span class="hljs-built_in">get_null</span>();<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!left_list.<span class="hljs-built_in">empty</span>() &amp;&amp; type_ == CompType::LIST_VAL) &#123;<br>    <span class="hljs-keyword">return</span> left_list[<span class="hljs-number">0</span>].<span class="hljs-built_in">get_null</span>();<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!left_tuple_list.<span class="hljs-built_in">empty</span>() &amp;&amp; type_ == CompType::TUPLES_VAL) &#123;<br>    <span class="hljs-keyword">return</span> left_tuple_list[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].<span class="hljs-built_in">get_null</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="update-select"><a href="#update-select" class="headerlink" title="update-select"></a>update-select</h3><p><img src="/img/update_select.png"></p><p>本题要求 update 的更新目标值可以通过子查询得出，子查询第一版本是我的队友完成的，但是在写复杂子查询的时候将整个框架重构了一下。因为在看代码框架的时候发现，用于生成算子的部分是完全独立的，所以完全可以将生成算子的部分改成静态的，从而可以 : “随时随地，STNT -&gt; 算子 -&gt; 结果”。这样设计完之后，想要获取子查询的结果只需要一个 STMT，极大的简化了代码，甚至 update-select 并没有新增什么内容，只是在收集更新的 Value 时，多增一步，如果 Value 是子查询需要转化一下。</p><p>需要注意的是，准确说当时因为这个 debug 了好久，where 子句筛选出来的元组集合为空集时，即便子查询搜出来的结果不合法，也算 SUCCESS。<br>对于子查询，能当作 update 的 Value 的充分必要条件是搜出来的元组数组，或者二维数组，只能是一个元素。如果搜出来是空集，等同于插入 NULL。</p><h4 id="STMT-vector-vector-Value"><a href="#STMT-vector-vector-Value" class="headerlink" title="STMT -&gt; vector&lt; vector&lt; Value&gt;&gt;"></a>STMT -&gt; vector&lt; vector&lt; Value&gt;&gt;</h4><p>更近一步，设计一个函数，输入 STMT，输出为二维 Value 数组，省去中间的部分。函数设计如下：输入 STMT，输出 数据 + 表头信息。其中 main_tuple 为复杂子查询的内容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">RC <span class="hljs-title">OptimizeStage::handle_sub_stmt</span><span class="hljs-params">(Stmt *stmt, std::vector&lt;std::vector&lt;Value&gt;&gt; &amp;tuple_list, TupleSchema &amp;tuple_schema, <span class="hljs-type">const</span> Tuple *main_tuple)</span> </span>&#123;<br>  SelectStmt *select_stmt = <span class="hljs-built_in">static_cast</span>&lt;SelectStmt *&gt;(stmt);<br>  vector&lt;Table *&gt; tables = select_stmt-&gt;<span class="hljs-built_in">tables</span>();<br>  string table_names;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : tables) table_names += it-&gt;<span class="hljs-built_in">name</span>();<br><br>  RC rc = RC::SUCCESS;<br><br>  <span class="hljs-comment">// ? 不存在创建好的逻辑算子</span><br>  <span class="hljs-keyword">if</span> (!sub_expr_and_logical_oper.<span class="hljs-built_in">contains</span>(table_names)) &#123;<br>    unique_ptr&lt;LogicalOperator&gt; logical_oper;<br>    rc = <span class="hljs-built_in">create_logical_plan</span>(stmt, logical_oper);<br><br>    <span class="hljs-keyword">if</span> (rc != RC::SUCCESS &amp;&amp; rc != RC::UNIMPLEMENTED) <span class="hljs-keyword">return</span> rc;<br>    <span class="hljs-built_in">ASSERT</span>(logical_oper, <span class="hljs-string">&quot;logical operator is null&quot;</span>);<br><br>    sub_expr_and_logical_oper.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(table_names, std::<span class="hljs-built_in">move</span>(logical_oper)));<br>  &#125;<br><br>  <span class="hljs-comment">// ? 不存在创建好的物理算子</span><br>  <span class="hljs-keyword">if</span> (!sub_expr_and_physical_oper.<span class="hljs-built_in">contains</span>(table_names)) &#123;<br>    unique_ptr&lt;PhysicalOperator&gt; physical_oper;<br>    rc = <span class="hljs-built_in">generate_physical_plan</span>(sub_expr_and_logical_oper[table_names], physical_oper);<br><br>    <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br><br>    sub_expr_and_physical_oper.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(table_names, std::<span class="hljs-built_in">move</span>(physical_oper)));<br>  &#125;<br><br>  PhysicalOperator *physical_oper = sub_expr_and_physical_oper[table_names].<span class="hljs-built_in">get</span>();<br>  rc = <span class="hljs-built_in">get_tuple_schema</span>(physical_oper, tuple_schema);<br>  <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br><br>  rc = <span class="hljs-built_in">get_tuple_list</span>(physical_oper, tuple_list, main_tuple);<br>  <span class="hljs-keyword">return</span> rc;<br>&#125;<br><br><span class="hljs-function">RC <span class="hljs-title">OptimizeStage::create_logical_plan</span><span class="hljs-params">(Stmt *stmt, unique_ptr&lt;LogicalOperator&gt; &amp;logical_operator)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == stmt) &#123;<br>    <span class="hljs-keyword">return</span> RC::UNIMPLEMENTED;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> LogicalPlanGenerator::<span class="hljs-built_in">create</span>(stmt, logical_operator);<br>&#125;<br><br><span class="hljs-function">RC <span class="hljs-title">OptimizeStage::generate_physical_plan</span><span class="hljs-params">(unique_ptr&lt;LogicalOperator&gt; &amp;logical_operator, unique_ptr&lt;PhysicalOperator&gt; &amp;physical_operator)</span> </span>&#123;<br>  RC rc = PhysicalPlanGenerator::<span class="hljs-built_in">create</span>(*logical_operator, physical_operator);<br><br>  <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to create physical operator. rc=%s&quot;</span>, <span class="hljs-built_in">strrc</span>(rc));<br>  &#125;<br>  <span class="hljs-keyword">return</span> rc;<br>&#125;<br><br><span class="hljs-function">RC <span class="hljs-title">OptimizeStage::get_tuple_schema</span><span class="hljs-params">(PhysicalOperator *physical_operator, TupleSchema &amp;tuple_schema)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> physical_operator-&gt;<span class="hljs-built_in">tuple_schema</span>(tuple_schema);<br>&#125;<br><br><span class="hljs-function">RC <span class="hljs-title">OptimizeStage::get_tuple_list</span><span class="hljs-params">(PhysicalOperator *physical_operator, std::vector&lt;std::vector&lt;Value&gt;&gt; &amp;tuple_list, <span class="hljs-type">const</span> Tuple *main_tuple)</span> </span>&#123;<br>  RC rc = physical_operator-&gt;<span class="hljs-built_in">open</span>(<span class="hljs-literal">nullptr</span>, main_tuple);<br>  <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to open sub physical operator. rc=%s&quot;</span>, <span class="hljs-built_in">strrc</span>(rc));<br>    <span class="hljs-keyword">return</span> rc;<br>  &#125;<br><br>  <span class="hljs-comment">// 将查表结果放入value_list</span><br>  <span class="hljs-keyword">while</span> (RC::SUCCESS == (rc = physical_operator-&gt;<span class="hljs-built_in">next</span>(main_tuple))) &#123;<br>    Tuple *tuple = physical_operator-&gt;<span class="hljs-built_in">current_tuple</span>();<br>    std::vector&lt;Value&gt; single_tuple;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tuple-&gt;<span class="hljs-built_in">cell_num</span>(); i++) &#123;<br>      Value value;<br>      tuple-&gt;<span class="hljs-built_in">cell_at</span>(i, value);<br>      single_tuple.<span class="hljs-built_in">push_back</span>(value);<br>    &#125;<br>    tuple_list.<span class="hljs-built_in">push_back</span>(single_tuple);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (rc != RC::RECORD_EOF) <span class="hljs-keyword">return</span> rc;<br><br>  rc = physical_operator-&gt;<span class="hljs-built_in">close</span>();<br>  <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br><br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="update-中添加有关子查询的部分"><a href="#update-中添加有关子查询的部分" class="headerlink" title="update 中添加有关子查询的部分"></a>update 中添加有关子查询的部分</h4><p>如果发现有子查询，通过函数将其转化为二维 Value 数组，如果数组只有一个元素则合法，拿出来；如果数组为空，则等同于 NULL；如果数组不为空，等同一个非法的 Value，注意这里并没有直接返回 FAILURE，因为如果 where 子句筛选集为空集，即便子查询有误也返回 SUCCESS，所以这里通过特意构造非法 Value，如果 where 子句筛选集不为空集，则会识别非法 Value 并返回 FAILURE；如果 where 子句筛选集为空集，则不会有识别环节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">RC <span class="hljs-title">UpdateStmt::create</span><span class="hljs-params">(Db *db, UpdateSqlNode &amp;update, Stmt *&amp;stmt)</span> </span>&#123;<br>  <span class="hljs-comment">// 拿到目标表格以及名称以及修改域</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *table_name = update.relation_name.<span class="hljs-built_in">c_str</span>();<br>  Table *table = db-&gt;<span class="hljs-built_in">find_table</span>(table_name);<br><br>  <span class="hljs-comment">// 目标表格不存在检查</span><br>  <span class="hljs-keyword">if</span> (table == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;no such table. db=%s, table_name=%s&quot;</span>, db-&gt;<span class="hljs-built_in">name</span>(), table_name);<br>    <span class="hljs-keyword">return</span> RC::SCHEMA_TABLE_NOT_EXIST;<br>  &#125;<br>  <span class="hljs-comment">// 参数非法检查</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == db || <span class="hljs-literal">nullptr</span> == table_name) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;invalid argument. db=%p, table_name=%p&quot;</span>, db, table_name);<br>    <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>  &#125;<br><br>  <span class="hljs-comment">// 拿到全部修改域</span><br>  std::vector&lt;FieldMeta&gt; field_metas;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : update.update_targets) &#123;<br>    FieldMeta *field_meta = (FieldMeta *)table-&gt;<span class="hljs-built_in">table_meta</span>().<span class="hljs-built_in">field</span>(it.attribute_name.<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-comment">// 修改域检查</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == field_meta) &#123;<br>      <span class="hljs-keyword">return</span> RC::SCHEMA_FIELD_NOT_EXIST;<br>    &#125;<br>    field_metas.<span class="hljs-built_in">push_back</span>(*field_meta);<br>  &#125;<br><br>  <span class="hljs-comment">// 创建筛选 STMT 对象</span><br>  std::unordered_map&lt;std::string, Table *&gt; table_map;<br>  table_map.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">pair</span>&lt;std::string, Table *&gt;(std::<span class="hljs-built_in">string</span>(table_name), table));<br>  FilterStmt *filter_stmt = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-type">bool</span> flag;<br>  RC rc = FilterStmt::<span class="hljs-built_in">create</span>(db, table, &amp;table_map, update.conditions.<span class="hljs-built_in">data</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(update.conditions.<span class="hljs-built_in">size</span>()), filter_stmt, flag);<br><br>  <span class="hljs-comment">// 谓词语句合法检查</span><br>  <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to create filter statement. rc=%d:%s&quot;</span>, rc, <span class="hljs-built_in">strrc</span>(rc));<br>    <span class="hljs-keyword">return</span> rc;<br>  &#125;<br><br>  <span class="hljs-comment">// 创建子查询的 STMT 对象</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">int</span>)update.update_targets.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (update.update_targets[i].is_value == <span class="hljs-literal">false</span>) &#123;<br>      Stmt *temp;<br>      rc = SelectStmt::<span class="hljs-built_in">create</span>(db, update.update_targets[i].sub_select-&gt;selection, temp, flag);<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>      vector&lt;vector&lt;Value&gt;&gt; tuple_list;<br>      TupleSchema tuple_schema;<br>      OptimizeStage::<span class="hljs-built_in">reset</span>();<br>      RC rc = OptimizeStage::<span class="hljs-built_in">handle_sub_stmt</span>(temp, tuple_list, tuple_schema);<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>      <span class="hljs-comment">// 子查询为空值，等同于插入 NULL</span><br>      <span class="hljs-keyword">if</span> (tuple_list.<span class="hljs-built_in">empty</span>()) &#123;<br>        update.update_targets[i].value.<span class="hljs-built_in">set_null</span>(<span class="hljs-literal">true</span>);<br>      &#125;<br>      <span class="hljs-comment">// 子查询非法，等同于插入非法 Value，如果筛选出来没有更新目标，则无视，否则报错</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tuple_list.<span class="hljs-built_in">size</span>() != <span class="hljs-number">1</span> || tuple_list[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() != <span class="hljs-number">1</span>) &#123;<br>        update.update_targets[i].value.<span class="hljs-built_in">set_type</span>(AttrType::UNDEFINED);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        update.update_targets[i].value = tuple_list[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>      &#125;<br>      update.update_targets[i].is_value = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// check date validity</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : update.update_targets) &#123;<br>    Value value = it.value;<br>    <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">attr_type</span>() == AttrType::DATE) &#123;<br>      <span class="hljs-keyword">if</span> (!DateType::<span class="hljs-built_in">check_date</span>(value.<span class="hljs-built_in">get_date</span>())) &#123;<br>        <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">attr_type</span>() == AttrType::CHARS) &#123;<br>      <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">get_string</span>().<span class="hljs-built_in">size</span>() &gt; BP_MAX_TEXT_SIZE) &#123;<br>        <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">attr_type</span>() == AttrType::VECTORS) &#123;<br>      <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">get_vector_size</span>() &gt; BP_MAX_VECTOR_SIZE) &#123;<br>        <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 创建 update 的 STMT 对象</span><br>  stmt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">UpdateStmt</span>(table, filter_stmt, field_metas, update.update_targets);<br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p><img src="/img/alias.png"></p><h3 id="order-by"><a href="#order-by" class="headerlink" title="order-by"></a>order-by</h3><p><img src="/img/order_by.png"></p><h3 id="aggregation-and-groupby"><a href="#aggregation-and-groupby" class="headerlink" title="aggregation_and_groupby"></a>aggregation_and_groupby</h3><p><img src="/img/aggregation_and_groupby.png"></p><h3 id="create-table-select"><a href="#create-table-select" class="headerlink" title="create-table-select"></a>create-table-select</h3><p><img src="/img/create_table_select.png"></p><h3 id="vector-rewrite"><a href="#vector-rewrite" class="headerlink" title="vector_rewrite"></a>vector_rewrite</h3><p><img src="/img/vector_rewrite.png"></p><h3 id="vector-search"><a href="#vector-search" class="headerlink" title="vector_search"></a>vector_search</h3><p><img src="/img/vector_search.png"></p><h3 id="complex-sub-query"><a href="#complex-sub-query" class="headerlink" title="complex-sub-query"></a>complex-sub-query</h3><p><img src="/img/complex_sub_query.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Competition</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
