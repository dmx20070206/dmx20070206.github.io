<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>miniob 初赛参赛总结</title>
    <link href="/2024/11/11/miniob/"/>
    <url>/2024/11/11/miniob/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>参加这个比赛其实主要目的是赚钱（感谢赵师姐的校友基金，最后含泪收下 7000￥ ），所以以下很多内容可能并不专业。</p><p>最终的结果是全国第 40 名，进决赛一共有 50 个队伍，不过由于加权压力（目前估计加权相较于大二上要掉 6 分左右），决赛不一定会付出太多心血去打了。</p><p>感谢我的队友 Sazikk 和我一起熬夜肝代码，并且忍耐我的屎山代码长达 21 天之久。</p><blockquote><p>Sazikk 个人博客：<a href="https://sazikk.github.io/">https://sazikk.github.io</a>  目前已有数十万的观看量</p></blockquote><h2 id="个人心得"><a href="#个人心得" class="headerlink" title="个人心得"></a>个人心得</h2><p>参加这个比赛需要什么能力：</p><ol><li>较强的 C++ 开发能力</li><li>一定的 SQL 语言理解能力</li><li>对 miniob 内核有较好的理解</li></ol><h2 id="miniob-框架解析"><a href="#miniob-框架解析" class="headerlink" title="miniob 框架解析"></a>miniob 框架解析</h2><h2 id="我负责的题目"><a href="#我负责的题目" class="headerlink" title="我负责的题目"></a>我负责的题目</h2><h3 id="drop-table"><a href="#drop-table" class="headerlink" title="drop table"></a>drop table</h3><p><img src="/../../themes/fluid/source/img/miniob/drop_table.png"></p><p>题目要求删除某个表格，一个表格的信息包括三种：数据信息 + 索引信息 + 表格元数据</p><ol><li>数据信息：真实存放到表格当中的数据</li><li>索引信息：一个索引对应一棵 B+ 树</li><li>表格元数据：各种表格的描述信息</li></ol><p>drop table 不需要算子，需要执行器</p><h4 id="前端-lex-yacc-完善"><a href="#前端-lex-yacc-完善" class="headerlink" title="前端 lex yacc 完善"></a>前端 lex yacc 完善</h4><p>lex 加入关键字 DROP</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">DROP                                    <span class="hljs-title">RETURN_TOKEN</span><span class="hljs-params">(DROP)</span></span>;<br></code></pre></td></tr></table></figure><p>yacc 加入语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">drop_table_stmt:<br>    DROP TABLE ID &#123;<br>      $$ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ParsedSqlNode</span>(SCF_DROP_TABLE);<br>      $$-&gt;drop_table.relation_name = $<span class="hljs-number">3</span>;<br>      <span class="hljs-built_in">free</span>($<span class="hljs-number">3</span>);<br>    &#125;;<br></code></pre></td></tr></table></figure><h4 id="STMT-设计"><a href="#STMT-设计" class="headerlink" title="STMT 设计"></a>STMT 设计</h4><p>删除表格只需要表格的表名，当然正常来说在 STMT 级就应该通过表格名称获取到实际的 Table 了，但是当时写的时候放到了 Db 的删除表格函数中。</p><h4 id="EXECUTE-设计"><a href="#EXECUTE-设计" class="headerlink" title="EXECUTE 设计"></a>EXECUTE 设计</h4><p>在执行器中通过调用 db 的删除表格函数或者 table 的自毁函数。表格的自毁函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">RC <span class="hljs-title">Table::drop</span><span class="hljs-params">()</span> </span>&#123;<br><br>  <span class="hljs-comment">// 删除数据文件 data_file</span><br>  string data_file = <span class="hljs-built_in">table_data_file</span>(base_dir_.<span class="hljs-built_in">c_str</span>(), table_meta_.<span class="hljs-built_in">name</span>());<br>  <span class="hljs-built_in">unlink</span>(data_file.<span class="hljs-built_in">c_str</span>());<br><br>  <span class="hljs-comment">// 删除索引文件 index_file</span><br>  <span class="hljs-type">int</span> indexNum = table_meta_.<span class="hljs-built_in">index_num</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; indexNum; i++) &#123;<br>    <span class="hljs-keyword">auto</span> *index_meta = table_meta_.<span class="hljs-built_in">index</span>(i);<br>    string index_file = <span class="hljs-built_in">table_index_file</span>(base_dir_.<span class="hljs-built_in">c_str</span>(), table_meta_.<span class="hljs-built_in">name</span>(), index_meta-&gt;<span class="hljs-built_in">name</span>());<br>    <span class="hljs-built_in">unlink</span>(index_file.<span class="hljs-built_in">c_str</span>());<br>  &#125;<br><br>  <span class="hljs-comment">// 删除元文件 meta_file</span><br>  string meta_file = <span class="hljs-built_in">table_meta_file</span>(base_dir_.<span class="hljs-built_in">c_str</span>(), table_meta_.<span class="hljs-built_in">name</span>());<br>  <span class="hljs-built_in">unlink</span>(meta_file.<span class="hljs-built_in">c_str</span>());<br><br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p><img src="/../../themes/fluid/source/img/miniob/update.png"></p><p>虽然题目只要求单字段的更新，但是由于后面很快就要扩充，所以下面直接放完整版。</p><p>需要注意的有两点，如何将 在某些字段修改为某值 推得 在内存某些位置修改二进制数据；以及对于多个字段的更新，必须同时成功或失败，也即先判断后修改（或回滚），不仅有单个字段间的回滚，还有单个元组间的回滚。</p><p>update 语句不需要执行器，需要算子</p><h4 id="前端-lex-yacc-完善-1"><a href="#前端-lex-yacc-完善-1" class="headerlink" title="前端 lex yacc 完善"></a>前端 lex yacc 完善</h4><p>lex 加入关键字 DROP</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">UPDATE                                  <span class="hljs-title">RETURN_TOKEN</span><span class="hljs-params">(UPDATE)</span></span>;<br></code></pre></td></tr></table></figure><p>yacc 加入语句<br>其中 update_target 为一个字段的更新，update_target_list 为若干字段的更新，where 为谓词表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++">update_stmt:      <span class="hljs-comment">/*  update 语句的语法解析树*/</span><br>    UPDATE ID SET update_target update_target_list where <br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ParsedSqlNode</span>(SCF_UPDATE);<br>      $$-&gt;update.relation_name = $<span class="hljs-number">2</span>;<br><br>      <span class="hljs-keyword">if</span> ($<span class="hljs-number">6</span> != <span class="hljs-literal">nullptr</span>) &#123;<br>        $$-&gt;update.conditions.<span class="hljs-built_in">swap</span>(*$<span class="hljs-number">6</span>);<br>        <span class="hljs-keyword">delete</span> $<span class="hljs-number">6</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span>($<span class="hljs-number">5</span> != <span class="hljs-literal">nullptr</span>)<br>        $$-&gt;update.update_targets.<span class="hljs-built_in">swap</span>(*$<span class="hljs-number">5</span>);<br>      $$-&gt;update.update_targets.<span class="hljs-built_in">emplace_back</span>(*$<span class="hljs-number">4</span>);<br>      std::<span class="hljs-built_in">reverse</span>($$-&gt;update.update_targets.<span class="hljs-built_in">begin</span>(), $$-&gt;update.update_targets.<span class="hljs-built_in">end</span>());<br>    &#125;<br>    ;<br></code></pre></td></tr></table></figure><p>对于 ParseSqlNode，新增 update 语句对应的 node。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UpdateSqlNode</span> &#123;<br>  std::string relation_name;                <span class="hljs-comment">// 更新表格名称</span><br>  std::vector&lt;UpdateTarget&gt; update_targets; <span class="hljs-comment">// 更新字段集合</span><br>  std::vector&lt;ConditionSqlNode&gt; conditions; <span class="hljs-comment">// 谓词条件</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UpdateTarget</span> &#123;<br>  <span class="hljs-type">bool</span> is_value;                            <span class="hljs-comment">// 是否为简单值，本题视作 true</span><br>  Value value;                              <span class="hljs-comment">// 更新的值</span><br>  std::string attribute_name;               <span class="hljs-comment">// 更新的属性名</span><br>  SubSelectSqlNode *sub_select;             <span class="hljs-comment">// 子查询，后面习题涉及</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="STMT-设计-1"><a href="#STMT-设计-1" class="headerlink" title="STMT 设计"></a>STMT 设计</h4><p>update 语句对应的 STMT 中包含：所有修改域信息(FieldMeta)，目标表格，筛选对应的 STMT(FilterStmt)，以及处理好的 UpdateTarget 数组。</p><p>第一步，拿到表格</p><p>第二步，通过所有修改域的名称，拿到全部修改域，注意顺序是不重要的，因为它们都是同时成功或同时失败的。</p><p>第三步，如果有子查询需要将子查询转化为一个 Value，后面对应的题再解释。</p><h4 id="逻辑算子和物理算子设计"><a href="#逻辑算子和物理算子设计" class="headerlink" title="逻辑算子和物理算子设计"></a>逻辑算子和物理算子设计</h4>]]></content>
    
    
    
    <tags>
      
      <tag>Competition</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
