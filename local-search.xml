<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>三个月过去喽</title>
    <link href="/2025/03/31/2025-3/"/>
    <url>/2025/03/31/2025-3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/css/Happiness.css"><div class="event-card">    <div class="summary-title">还是 rk1</div>    <div class="explanation">只能说完全摆烂的一学期还是不小心拿下了加权第一（嘻嘻），室友和上学期绑定组队大作业的好朋友分别拿下 rk234，只能说跟着轩哥混指定有好果汁吃（嘻嘻）</div></div>]]></content>
    
    
    
    <tags>
      
      <tag>Happiness</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HyperVisor 设计思路</title>
    <link href="/2025/03/02/DMX-Visor/"/>
    <url>/2025/03/02/DMX-Visor/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/css/GPU_TEE.css"><h2 id="框架设计思路"><a href="#框架设计思路" class="headerlink" title="框架设计思路"></a>框架设计思路</h2><blockquote><p>主机和设备交换数据有三种方式：DMA, MMIO, I&#x2F;O ports<br>GPU -&gt; 保护的设备<br>c-device -&gt; 恶意设备<br>c-OS -&gt; 恶意操作系统<br>HV -&gt; HyperVisor<br>untrust-app -&gt; 不受信任的应用进程<br>trust-app -&gt; 受信任的应用进程，需要访问 GPU</p></blockquote><h3 id="设备枚举与初始化-——-保护设备配置空间"><a href="#设备枚举与初始化-——-保护设备配置空间" class="headerlink" title="设备枚举与初始化 —— 保护设备配置空间"></a>设备枚举与初始化 —— 保护设备配置空间</h3><div class="original-text">    A fundamental building block of our prevention mechanisms against I/O port conflicts  and MMIO mapping attacks is protecting the device configuration space.     </br>    </br>    —— 《Building Verifiable Trusted Path on Commodity x86 Computers》</div><p>设备配置空间是保护 MMIO&#x2F;DMA&#x2F;IO-port 的基础，如果无法保证 GPU 的 BARs 寄存器中数据的真实性，对访问设备的数据通路的任何加强都没有意义。</p><div class="original-text">    This address information is only correlated with the targeted device’s static geographic position in the system hierarchy where the targeted PCI/PCIe device is hard-wired or plugged. I/O ports and MMIO memory remapping cannot manipulate device hierarchic positions, and thus cannot cause the manipulated devices to claim the configuration space cycles of other devices.    </br>    </br>    —— 《Building Verifiable Trusted Path on Commodity x86 Computers》</div><p>对于设备配置空间的访问一般通过 MMIO&#x2F;IO-port 方式，看似出现了依赖环路，但由于 PCIe RC 转发设备配置空间访问事务包根据设备的 BDF 以及在系统架构中的物理位置进行路由，故 HV 首要目标是正确初始化设备配置空间并防止任何非法修改。</p><h3 id="主机-设备通信的三种途径-——-I-O-Ports-MMIO-DMA"><a href="#主机-设备通信的三种途径-——-I-O-Ports-MMIO-DMA" class="headerlink" title="主机-设备通信的三种途径 —— I&#x2F;O Ports | MMIO | DMA"></a>主机-设备通信的三种途径 —— I&#x2F;O Ports | MMIO | DMA</h3><blockquote><p>I&#x2F;O Ports 传输方式几乎不会被使用</p></blockquote><div class="threat-module">    <ul>        <li>c-OS/untrust-app 直接访问 GPU I/O ports | DMA | MMIO</li>        <li>c-OS 恶意篡改 c-device 的 I/O ports | DMA | MMIO 地址信息</li>    </ul></div><div class="original-text">    <div style="font-weight: bold;">26.6.4 I/O-Bitmap Addresses</div>    The VM-execution control fields include the 64-bit physical addresses of I/O bitmaps A and B (each of which are 4 KBytes in size). I/O bitmap A contains one bit for each I/O port in the range 0000H through 7FFFH; I/O bitmap B contains bits for ports in the range 8000H through FFFFH. A logical processor uses these bitmaps if and only if the 'use I/O bitmaps' control is 1. If the bitmaps are used, execution of an I/O instruction causes a VM exit if any bit in the I/O bitmaps corresponding to a port it accesses is 1. See Section 27.1.3 for details. If the bitmaps are used, their addresses must be 4-KByte aligned.    </br>    </br>    —— 《Intel® 64 and IA-32 Architectures Software Developer’s Manual》</div><p>对于 I&#x2F;O ports，HV 可以配置 VMCS 中的 I&#x2F;O port-access-interception bitmap，拦截 c-OS&#x2F;untrust-app 访问 GPU 端口。</p><p>对于 MMIO | DMA，其本质是内存地址的一部分，故 HV 可以通过设置 EPT trapping，拦截 c-OS&#x2F;untrust-app 访问相关内存地址。设备配置空间的保护是保证这些内存地址的真实性的基础。</p><div class="original-text">    Specifically, before executing the PE, the HV scans through all I/O port mappings relevant to the chipset hardware (as mentioned in Section 2.3) and enumerates all plug-and-play (PnP) devices to detect their configured I/O ports.    </br>    </br>    —— 《Building Verifiable Trusted Path on Commodity x86 Computers》    </br>    -----------------------------------------------------------------------------------------------------------------------------------    </br>    Before executing a PE, the HV scans through all MMIO memory mappings specified by the chipset hardware, and enumerates    all PnP devices to discover their MMIO memory ranges (e.g., check the PCI Base Address Registers in the PCI    configuration space).    </br>    </br>    —— 《Building Verifiable Trusted Path on Commodity x86 Computers》</div><p>HV 在 G-enclave 运行前可以进行一次检查，遍历所有设备的 I&#x2F;O ports，防止和 GPU 的 I&#x2F;O ports 重叠；遍历所有设备的 MMIO region，防止和 GPU 的 MMIO region 重叠。</p><div class="original-text">    GEVISOR maintains memory region mapping tables (MRtable) containing the virtual and physical address pairs of both MMIO and DMA memory regions per enclave within a reserved memory region, and traps accesses to these regions for access control.    </br>    </br>    —— 《Building GPU TEEs using CPU Secure Enclaves with GEVisor》    <br>    -----------------------------------------------------------------------------------------------------------------------------------    <br>    GECS contains the control information regarding the GPU enclave including the hardware GPU number and GPU enclave ID. TGMR contains the virtual and physical address mapping information of the GPU MMIO region.    <br>    <br>    —— 《Heterogeneous Isolated Execution for Commodity GPUs》</div><p>使用数据结构存储 GPU MMIO 信息（例如 HIX 的 GECS&#x2F;TGMR，GEVisor 的 MRTable），并在 EPT 中将这些内存区域设置为触发 EPT trapping，防止 c-OS&#x2F;untrust-app 直接访问 GPU MMIO region。原本的地址信息存在 Driver 中，HV 会根据数据结构中的信息进行验证。</p><p>DMA Buffer 和 MMIO Buffer 不同，DMA Buffer 是由驱动动态分配的：</p><ul>    <li>DMA 请求通过写入设备寄存器完成，写入过程使用 MMIO | I/O ports 方式，使用之前的方法可拦截 DMA 请求</li>    <li>设置 EPT trapping => HV 可以保证 c-OS 无法访问 DMA Buffer</li>    <li>设置数据结构 => HV 可以保证 c-OS 无法通过篡改 DMA 地址信息来攻击</li>    <li>设置 IOMMU => 可以保证 c-device 无法访问 GPU DMA Buffer</li></ul> <h3 id="G-Enclave-GPU-Driver"><a href="#G-Enclave-GPU-Driver" class="headerlink" title="G-Enclave | GPU-Driver"></a>G-Enclave | GPU-Driver</h3><blockquote><p>借助 Intel SGX 的功能</p></blockquote><img src="/img/GEVisor/F3.png" alt=""><p>将 GPU Runtime 分成两部分：UNTRUSTED RUNTIME 和 ENCLAVE GPU RUNTIME，前者存放在非 enclave 内存区域，负责和 GPU Driver 交互来创建 GPU 上下文以及分配 MMIO&#x2F;DMA Buffer 等；后者存放在 enclave 内存区域，负责和 GPU 通信，将数据从 enclave 复制到 MMIO&#x2F;DMA Buffer 中。</p><img src="/img/HIX/F3.png" alt=""><p>将 GPU Driver 分成两部分，一部分运行在 G-enclave 中，唯一控制 GPU 并提供 GPU 访问接口；另一部分运行在 c-OS 中，提供良性的内核服务。</p><p>本质上都是将 GPU Driver 分割成两部分：</p><ol><li>一部分运行在 SGX enclave 中，负责控制和保护 trust-app 和 GPU 的交互过程</li><li>一部分运行在 c-OS 中，提供良性的内核服务，例如分配 DMA | MMIO buffer 等</li><li>HV 负责转发和管理 trust-app, G-enclave, GPU 之间的通信</li></ol><div class="original-text">    example: trust-app 需要访问 GPU 上的数据，对应 MMIO 地址为 0x1000 - 0x1004    <ul>        <li>trust-app 通过 ENCLAVE GPU RUNTIME 提供的 API 访问内存地址 0x1000 - 0x1004 后触发 EPT trapping 或主动发起 HyperCall，被 HV 拦截</li>        <li>HV 根据数据结构中的信息，判断访问是否合法（根据 Eclave-ID, PA, VA 等），不合法则丢弃</li>        <li>HV 访问 GPU 对应数据，将数据返回给 trust-app</li>        <li>ENCLAVE GPU RUNTIME 和 HV 的通信需要使用加密信道</li>    </ul></div>]]></content>
    
    
    
    <tags>
      
      <tag>GPU TEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【论文】Building Verifiable Trusted Path on Commodity x86 Computers</title>
    <link href="/2025/03/01/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Building%20Verifiable%20Trusted%20Path%20on%20Commodity%20x86%20Computers/"/>
    <url>/2025/03/01/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Building%20Verifiable%20Trusted%20Path%20on%20Commodity%20x86%20Computers/</url>
    
    <content type="html"><![CDATA[<h2 id="论文思路整理"><a href="#论文思路整理" class="headerlink" title="论文思路整理"></a>论文思路整理</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="已有工作缺陷"><a href="#已有工作缺陷" class="headerlink" title="已有工作缺陷"></a>已有工作缺陷</h4><ol><li>These systems employ only a small number of user-oriented I&#x2F;O devices (e.g., a keyboard, mouse, or video display), and a small number of trusted programs (e.g., login commands and administrative commands).</li><li>These mechanisms use a smaller, more trustworthy kernel running with higher privilege than the OS, it does not provide a mechanism that enables isolated modules to communicate with devices without going through the OS</li><li>These work only demonstrates how to isolate device driver address spaces and Direct Memory Access (DMA). It does not fully isolate devices from compromised OS code in other administrative domains (e.g., system-wide configurations for I&#x2F;O ports, Memory-Mapped I&#x2F;O (MMIO), and interrupts remain unprotected).</li></ol><h4 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h4><p>OS 恶意将某个设备的 MMIO 区域和受害设备 MMIO 区域设置为重叠 &#x3D;&gt; MMOIO Mapping Attack</p><p>OS 恶意设置设备的中断向量空间 &#x3D;&gt; Interrupt Spoofing Attack</p><p><img src="/img/TrustPath/F1.png"></p><h4 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h4><ol><li>建立可信路径</li><li>很小的 TCB</li><li>提出对于 x86 平台的建议</li><li>验证</li></ol><h3 id="Threat-Model"><a href="#Threat-Model" class="headerlink" title="Threat Model"></a>Threat Model</h3><p>恶意 OS，可以访问任何系统资源，破坏任何隔离机制</p><p>The adversary can then leverage the compromised OS to actively reconfigure any device (e.g., modify a device’s MMIO region, or change the operating mode of a device) and induce it to perform arbitrary operations (e.g., trigger interrupts, issue DMA write requests) using any I&#x2F;O commands.</p><blockquote><p>OS 指恶意 OS，device 指恶意设备</p></blockquote><h3 id="可信路径的组成部分"><a href="#可信路径的组成部分" class="headerlink" title="可信路径的组成部分"></a>可信路径的组成部分</h3><p>Program Endpoint (PE) – Communication Path (CP) –&gt; Device Endpoint (DE)</p><ol><li>PE Isolation: OS 和 device 无法访问或破坏 PE 的任何有关可信路径的数据</li><li>Device Endpoint Isolation: PE 传输给 DE 的数据不能被 OS 修改或访问，同时 DE 产生的中断必须只能交给 PE</li><li>Communication Path Isolation: 确保可信路径上所有硬件设备都满足 Device Endpoint Isolation 的要求</li></ol><p>论文假设 BIOS 等固件是可靠的，并且硬件都按照规格正常运作</p><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><h4 id="Trusted-Path-Hypervisor"><a href="#Trusted-Path-Hypervisor" class="headerlink" title="Trusted-Path Hypervisor"></a>Trusted-Path Hypervisor</h4><p><img src="/img/TrustPath/F2.png"></p><p>HyperVisor 是一个小型内核，将 OS 视为一个顶端的进程，该进程可以在大多时候管理多数设备。PE 在虚拟机中作为一个被隔离的进程，并将相关驱动放入 PE 中做隔离。</p><h4 id="Program-Endpoint"><a href="#Program-Endpoint" class="headerlink" title="Program Endpoint"></a>Program Endpoint</h4><p>将 DE Driver 防止到 PE 内部的三大原因：</p><ol><li>论文目标是构建一个小型的 HyperVisor</li><li>所有对于 PE code 的保护方式都可以运用到 DE 上</li><li>需要保护的 DE Driver 一般很小，PE 可以只保留其中必须的部分来简化设计</li></ol><p>将 DE Driver 放置于用户&#x2F;内核空间的优点：</p><ol><li>允许驱动更新或修改，而无需调整用户代码</li><li>省去了 OS 和 PE 中驱动版本同步的问题</li></ol><p>将 DE Driver 放置于用户&#x2F;内核空间带来的安全问题：</p><ol><li>PE 和 DE Driver 之间的通信需要新增一条安全的信息通道</li><li>DE Driver 的隔离需要额外的机制来实现</li></ol><h3 id="Device-Isolation-Challenges"><a href="#Device-Isolation-Challenges" class="headerlink" title="Device-Isolation Challenges"></a>Device-Isolation Challenges</h3><p>单纯的驱动隔离和程序隔离不足以实现可信路径，因为系统中存在大量的 “共享设备配置状态”：</p><ol><li>I&#x2F;O 端口：所有设备共享相同的 I&#x2F;O 端口空间，OS 可以恶意的重构 I&#x2F;O 端口映射</li><li>MMIO region：所有设备共享 MMIO region 机制，OS 可以恶意的修改不同设备的 MMIO 映射</li><li>Interrupt Space：所有设备共享软件&#x2F;硬件中断机制，OS 可以恶意向 MSI 寄存器或 LAPIC 寄存器中写入值发送假中断</li></ol><h3 id="Hypervisor-Design"><a href="#Hypervisor-Design" class="headerlink" title="Hypervisor Design"></a>Hypervisor Design</h3><h4 id="Protection-of-I-O-Port-Access"><a href="#Protection-of-I-O-Port-Access" class="headerlink" title="Protection of I&#x2F;O-Port Access"></a>Protection of I&#x2F;O-Port Access</h4><p><strong>Preventing Port-mapping Conflicts</strong></p><p>攻击者手段：将 device I&#x2F;O 端口恶意修改成覆盖 DE I&#x2F;O 端口，所有发往 DE 的数据都会被 device 接收</p><p>方案：执行 PE 前，由 HyperVisor 扫描枚举所有设备，检测它们的 I&#x2F;O 端口。保证所有 I&#x2F;O 端口的映射不会被 OS 或 device 篡改</p><p><strong>Confining I&#x2F;O-port Access</strong></p><p>方案：HyperVisor 通过配置 VMCS region 中的 I&#x2F;O port-access-interception bitmap，防止 PE 访问非 DE 端口，防止 OS 访问 DE 端口</p><h4 id="Protection-of-Device-Memory-Access"><a href="#Protection-of-Device-Memory-Access" class="headerlink" title="Protection of Device-Memory Access"></a>Protection of Device-Memory Access</h4><p><strong>Preventing MMIO Mapping Attacks</strong></p><p><img src="/img/TrustPath/F3.png"></p><p>方案：扫描 PCIe 配置空间，检查不同设备的 MMIO 映射区域，防止 OS 篡改 MMIO 映射</p><p><strong>Preventing Unauthorized Memory Access</strong></p><p>攻击者手段：OS 直接访问 DMA&#x2F;MMIO Buffer</p><p>方案：利用 HyperVisor 的 EPT，将这些区域设置 EPT trapping。同时设立 IOMMU，区分不同设备的 DMA Buffer 不会重叠（前提是，IOMMU 可以正确识别 DMA 请求）</p><h4 id="Protection-of-Device-Configuration-Space"><a href="#Protection-of-Device-Configuration-Space" class="headerlink" title="Protection of Device Configuration Space"></a>Protection of Device Configuration Space</h4><p>保护 MMIO 区域，DMA 区域，I&#x2F;O 端口不被篡改和核心是保护设备配置空间。HyperVisor 保证只有 PE 可以访问 DE 的配置空间并且拒绝一切来自 OS 的访问 DE 配置空间的请求。</p><p>而设备配置空间的访问通过 MMIO 或 I&#x2F;O 端口，看似出现了循环依赖：保护设备配置空间依赖于 MMIO&#x2F;DMA&#x2F;IO ports，保护 MMIO&#x2F;DMA&#x2F;IO ports 依赖于保护设备配置空间。</p><p>但实际上，即便 MMIO 和 I&#x2F;O ports 被 OS 恶意攻击（DE 和 device 的 MMIO 重叠），PCIe 对于设备配置空间的访问也不会受到影响，因为 PCIe 转发事务包是根据设备在架构&#x2F;总线上的地理位置决定的。</p><p>故 HyperVisor 只需要配置 I&#x2F;O ports-access-interception bitmap，EPT，IOMMU 即可保护 MMIO&#x2F;DMA&#x2F;IO ports 配置。</p>]]></content>
    
    
    
    <tags>
      
      <tag>GPU TEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个月过去喽</title>
    <link href="/2025/02/28/2025-2/"/>
    <url>/2025/02/28/2025-2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/css/Happiness.css"><div class="event-card">    <div class="summary-title">18 岁</div>    <div class="explanation">不 知 不 觉 就 成 年 了</div>    <div class="explanation">平时经常因为年龄小被好朋友调侃，聊天一旦涉及时间因素，必有人来一句：“这个时候 dmx 才多大多大”，之前总盼着成年，真到这个时候了反而有些不舍了。还记得小时候和关系好的女生顺路回家的时候，感叹她怎么这么快就 14 岁了，时间过得好快，我对 17 岁这年还算满意，但是再也回不去了...</div>    <div class="explanation">不过往好了想，能用自己的身份证实名打游戏，能在淘宝上买剪刀这种危险物品，也是很爽的</div>    <div class="explanation">不想担起责任，但是不得不担起越来越多的责任...</div></div><div class="event-card">    <div class="summary-title">又玩上王者了</div>    <div class="explanation">上学期因为太忙一度退游了俩月，放假了手痒痒了，好朋友也回归了，王者启动！</div></div><div class="event-card">    <div class="summary-title">拿上金标了</div>    <div class="explanation">半个月复健效果不错，也是拿上金标了，只不过越来越感觉这种 pvp 游戏，当打到一定的高度就渐渐失去玩游戏的本质了，尤其是最后冲分的时候，已经很明显感觉打游戏打得很累了</div></div><div class="event-card">    <div class="summary-title">游戏得最好配置是朋友</div>    <div class="explanation">无论什么类型的游戏和朋友一起玩就会很爽，泰拉瑞亚、森林之子、王者、PUBG、赛博桌游、博德之门..，每次都能在和兄弟们边玩游戏边搞抽象的过程中乐成啥比，过年后窝在家里那几天，最期待的就是群里有人问玩不玩游戏</div></div><div class="event-card">    <div class="summary-title">密码的计组课设还不出分</div>    <div class="explanation">上学期成绩慢慢地都出来了，计组课设这个 12 周结课，出分只需要计算三个两位数加法的课一直拖到了开学还没出，严重怀疑老师是个大懒蛋</div></div><div class="event-card">    <div class="summary-title">荒废的寒假</div>    <div class="explanation"></div></div><div class="event-card">    <div class="summary-title">不顺利的科研</div>    <div class="explanation"></div></div>]]></content>
    
    
    
    <tags>
      
      <tag>Happiness</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【论文】Building GPU TEEs using CPU Secure Enclaves with GEVisor</title>
    <link href="/2025/02/26/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Building%20GPU%20TEEs%20using%20CPU%20Secure%20Enclaves%20with%20GEVisor/"/>
    <url>/2025/02/26/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Building%20GPU%20TEEs%20using%20CPU%20Secure%20Enclaves%20with%20GEVisor/</url>
    
    <content type="html"><![CDATA[<h2 id="论文思路整理"><a href="#论文思路整理" class="headerlink" title="论文思路整理"></a>论文思路整理</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><img src="/img/GEVisor/F1.png"></p><h4 id="已有工作缺陷"><a href="#已有工作缺陷" class="headerlink" title="已有工作缺陷"></a>已有工作缺陷</h4><ol><li>require CPU and&#x2F;or GPU hardware modification</li><li>rely on untrusted system software</li><li>silicon scaling is slowing</li><li>increases the TCB size significantly</li></ol><h4 id="设计的挑战"><a href="#设计的挑战" class="headerlink" title="设计的挑战"></a>设计的挑战</h4><ol><li>Intel SGX was never designed to support I&#x2F;O operations</li><li>A GPU device driver is needed for GPU computation but can easily bloat up the TCB</li><li>Balance between security guarantees and performance overhead</li><li>Without rigorous security verification, a security solution may introduce a new attack surface</li></ol><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><ol><li>可靠 I&#x2F;O 传输：在飞地的 GPU runtime 和 HyperVisor 联合，确保只有对应的飞地可以访问 GPU I&#x2F;O 资源。</li><li>缩小 TCB：将飞地和 GPU 的通信通道和其他系统软件隔离，并在没有驱动参与的情况下完成 GPU 的验证，将 GPU Driver 移除 TCB。通过 dynamic hypervisor measured launch 技术将系统启动引导程序排移除 TCB。</li><li>低开销：在加密保护和 EPT 保护中抉择。</li><li>形式化验证：I&#x2F;O 双重化语义验证</li></ol><h4 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h4><ol><li>HyperVisor 和 CPU enclave 合作，在不需要硬件修改的前提下，实现 GPU 侧 TEE。</li><li>提出全新的异步 hypercall 减少上下文切换消耗；结合 TPM 和 SGX 远程验证实现了一个线性远程验证协议。</li><li>进行了形式化验证。</li><li>评估了 GEVisor 的性能消耗。</li></ol><h3 id="Threat-Modules"><a href="#Threat-Modules" class="headerlink" title="Threat Modules"></a>Threat Modules</h3><p>攻击者：OS，GPU Driver，guest VM<br>信任者：GPU 内存（结构无法被直接读取）、TPM；不考虑 Dos，侧信道攻击。</p><p>论文提出了一种新的攻击模型：创建一个新的 GPU 上下文，将其地址映射到受害 GPU 上下文中，偷取数据。<br><img src="/img/GEVisor/F2.png"></p><ol><li>攻击面 1：利用 DMA Buffer 在主机和 GPU 随意传输数据。</li><li>攻击面 2：利用 MMIO 映射在主机和 GPU 随意传输数据。</li><li>攻击面 3：利用驱动的 API 篡改 GPU 页表，偷取数据。</li></ol><h3 id="动机和目标"><a href="#动机和目标" class="headerlink" title="动机和目标"></a>动机和目标</h3><p>实现 GPU 侧 TEE 的四种流派：</p><ol><li>修改 CPU 硬件，使得 CPU TEE 可以直接和 GPU 通信</li><li>修改 GPU 硬件，强制隔离 GPU 上下文</li><li>把 HyperVisor 加入 TCB，将 GPU Driver 放入 HyperVisor 中</li><li>依靠远程验证减小 TCB</li></ol><p><img src="/img/GEVisor/T1.png"></p><p>五个目标：</p><ol><li>Complete Mediation：覆盖所有 GPU 通道的访问控制，监控所有 MMIO&#x2F;DMA 访问，完全隔离不同 GPU 上下文。</li><li>Tamperproofness：所有 TCB 以外的部件都不能篡改 GPU TEE。</li><li>Verifiability：TCB 足够小，支持形式化验证。</li><li>Deployability：无需硬件修改，可以部署到现成商用服务器。</li><li>Low Overhead：低开销。</li></ol><h3 id="系统架构设计"><a href="#系统架构设计" class="headerlink" title="系统架构设计"></a>系统架构设计</h3><p><img src="/../img/GEVisor/F3.png"></p><p>GEVisor 是一个轻量级 HyperVisor，和 SGX enclave 合作实现 GPU TEE，也即上文提到的五个目标。GPU enclave 由两部分组成：UNTRUSTED RUNTIME 以及 ENCLAVE GPU RUNTIME</p><p><strong>UNTRUSTED RUNTIME</strong></p><ol><li>负责和 GPU Driver 交互，创建 GPU 上下文</li><li>将 DMA 和 MMIO 区域映射到用户进程的虚拟地址空间中</li><li>不可信，可能受到攻击者的攻击</li></ol><p><strong>ENCLAVE GPU RUNTIME</strong></p><ol><li>和 GPU 驱动交互，将数据从 enclave 复制到 DMA&#x2F;MMIO Buffer 中，完成和 GPU 的通信</li><li>GEVisor 作为一个轻量级的 HyperVisor，和 ENCLAVE GPU RUNTIME 协作保护 DMA&#x2F;MMIO Buffer 不受攻击</li><li>ENCLAVE GPU RUNTIME 和 GEVisor 的通信通过 communication channel 完成，CC 是 enclave 和 GEVisor 共享的一段内存空间</li><li>ENCLAVE GPU RUNTIME 将访问请求控制信息通过 CC 传递给 GEVisor</li></ol><p><strong>使用 enclave 构建 GPU TEE 带来的新攻击面</strong></p><p>其他核心上的进程访问 enclave 数据 &#x3D;&gt; </p><ol><li>记录 enclave ID，只有持有对应 ID 的进程才能访问 enclave 的数据，只有持有对应 ID 的 enclave 才能访问对应的 GPU 上下文和 DMX&#x2F;MMIO Buffer</li><li>只有持有对应 ID 的 enclave 才能访问 GPU 对应内核的页表</li><li>GEVisor 保存 enclave ID，GPU context ID，Buffer 地址信息</li><li>加强 ECALL&#x2F;OCALL 退出点的管理</li></ol><h4 id="GEVISOR"><a href="#GEVISOR" class="headerlink" title="GEVISOR"></a>GEVISOR</h4><p>GEVISOR 由三部分组成：memory contraction，IO protection，MRTable</p><p>GEVISOR 启动后，保留一部分 CPU 核心在 VMX-root 模式，这部分核心不需要进行 VMX 切换，不需要运行 enclave，只需要处理 GPU I&#x2F;O 保护任务。通过这种设计，GEVISOR 能够实现 enclave 和 GPU I&#x2F;O 访问控制的并行运行，也即 <strong>Asynchronous Hypercall</strong></p><p>只配置三个区域的 EPT trapping：MMIO&#x2F;DMA 区域、enclave 区域、GPU CC 区域。访问其他内存区域时不触发 EPT trapping，减少性能开销</p><h4 id="Asynchronous-Hypercall-Offloading"><a href="#Asynchronous-Hypercall-Offloading" class="headerlink" title="Asynchronous Hypercall Offloading"></a>Asynchronous Hypercall Offloading</h4><p>当 Guest OS 发出 HyperCall 请求 HyperVisor 处理某些任务时，会停止执行并等待 HyperVisor 处理完毕。而异步 HyperCall 使得 Guest OS 在发出 HyperCall 请求后可以继续执行，无需等待。核心原因是针对 I&#x2F;O 的 HyperCall 参数少而且没有返回值。</p><p><img src="/../img/GEVisor/F4.png"></p><p>Guest OS 将 HyperCall 请求发送至 Ring Buffer，其中 HyperCal 请求被修改为统一的格式（HyperCall ID, Status, num of para, para1, para2, para3）。Ring Buffer 中包含一个 status 标志位，Free or Busy，Guest OS 向 free 的栏目写入 HyperCall 参数，并将 status 修改成 busy；GEVisor 执行结束后将 status 恢复成 free。</p><p>软件 IPI handler 负责管理 remote core 并处理 HyperCall。</p><h4 id="Communication-Channel-Protection"><a href="#Communication-Channel-Protection" class="headerlink" title="Communication Channel Protection"></a>Communication Channel Protection</h4><p>CC 是 enclave 发送 HyperCall 到 GEVisor 的通道，是固定的一段内存区域。GEVisor 将 CC 对应的内存区域设置为 EPT trap 模式，也即访问这部分区域将触发 VMExit 并交给 GEVisor 处理。</p><p>一般使用 CR3 寄存器存放当前进程的页表基地址，但是 CR3 无法区分来自普通进程的访问和 enclave 的访问。故 GEVisor 还会拦截 enclave 指令，在 EINIT, EEXIT, EREMOVE 命令时撤销对 CC 的访问权限，只有当 enclave 的状态是正在执行时（EENTER, ERESUME）才重新授权。</p><h4 id="Linear-Remote-Attestation-Protocol"><a href="#Linear-Remote-Attestation-Protocol" class="headerlink" title="Linear Remote Attestation Protocol"></a>Linear Remote Attestation Protocol</h4><p>一种线性远程验证协议，用于验证 Enclave 和 GEVisor 的可信性</p><p><img src="/../img/GEVisor/F5.png"></p><h3 id="GPU-PROTECTION"><a href="#GPU-PROTECTION" class="headerlink" title="GPU PROTECTION"></a>GPU PROTECTION</h3><h4 id="Unified-GPU-I-O-Protection"><a href="#Unified-GPU-I-O-Protection" class="headerlink" title="Unified GPU I&#x2F;O Protection"></a>Unified GPU I&#x2F;O Protection</h4><p>GEVisor 可以保护 GPU 侧的 DMA Buffer 和 Command Buffer 不受攻击者的访问</p><p><img src="/img/GEVisor/F6.png"></p><p>GEVisor 使用 MRtable 来存储每个 enclave 拥有的 MMIO&#x2F;DMA 的 gva -&gt; gpa 的映射，当 enclave 执行的时候，对于 GPU I&#x2F;O 页面的访问，GEVisor 可以使用 EPT 或 异步 HyperCall 来控制。</p><p>GEVisor 移除了 MRtable 中每个页面的读写权限，任何访问请求来源都会被捕获并经过验证：进程包含 enclave ID &amp;&amp; VA 对应 &amp;&amp; PA 对应</p><h4 id="Asynchronous-Hypercall"><a href="#Asynchronous-Hypercall" class="headerlink" title="Asynchronous Hypercall"></a>Asynchronous Hypercall</h4><p>正常情况：EPT 中设置 DMA 页面为不可访问，enclave 访问时触发 EPT trapping。GEVisor 允许 enclave 通过 HyperCall 主动发起 MMIO&#x2F;DMA 访问请求，维护一个 access-list 存储所有的 I&#x2F;O 访问请求，将请求中的地址参数，enclave ID 等和 MRtable 中的项进行比较。</p><p>GEVisor 需要确保在 enclave 因为各种原因停止运行时，需要将敏感区域立即保护起来，防止同一个 CPU 核心非法访问。</p><p>在存在其他非法设备时，OS 可能将其他设备的 MMIO&#x2F;DMA 区域映射到 GPU 对应位置，可以使用 IOMMU 来避免该攻击面。通过配置 VMCS 来截获全部的 IN&#x2F;OUT 指令，对于非法设备的 MMIO 访问，GEVisor 负责检查 PCI 配置空间和 BAR 寄存器来验证其合法性。</p><h4 id="GPU-Context-Isolation"><a href="#GPU-Context-Isolation" class="headerlink" title="GPU Context Isolation"></a>GPU Context Isolation</h4><p>GEVisor 维护了一种数据结构 OM，每一行存储 上下文 ID，enclave ID，物理地址，虚拟地址，大小，其中物理地址&#x2F;虚拟地址是 GPU 侧的。</p><p>创建上下文时会通知 GEVisor 创建对应的 OM 项，当驱动试图访问 OM 中的页面时，GEVisor 会通过 EPT 拦截并根据 OM 检查权限。</p><p><img src="/img/GEVisor/F7.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>GPU TEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【论文】Heterogeneous Isolated Execution for Commodity GPUs</title>
    <link href="/2025/02/18/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Heterogeneous%20Isolated%20Execution%20for%20Commodity%20GPUs/"/>
    <url>/2025/02/18/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91Heterogeneous%20Isolated%20Execution%20for%20Commodity%20GPUs/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/css/GPU_TEE.css"><h2 id="论文思路整理"><a href="#论文思路整理" class="headerlink" title="论文思路整理"></a>论文思路整理</h2><h3 id="Threat-Module"><a href="#Threat-Module" class="headerlink" title="Threat Module"></a>Threat Module</h3><h3 id="HIX-Architecture"><a href="#HIX-Architecture" class="headerlink" title="HIX Architecture"></a>HIX Architecture</h3><h4 id="Architecture-Overview"><a href="#Architecture-Overview" class="headerlink" title="Architecture Overview"></a>Architecture Overview</h4><p><img src="/img/HIX/F3.png"></p><p>目标：保护主机和 GPU 的数据通路，将 Driver 运行在 enclave 中，OS 无法修改 MMIO 映射和 PCIe 路由。</p><p>必须的硬件&#x2F;软件修改：</p><ol><li>Isolated GPU management with GPU enclave: 将 GPU Driver 运行在 GPU enclave 中，只有 GPU enclave 可以访问 MMIO 区域</li><li>Secure hardware I&#x2F;O path: 对 SGX 做硬件扩展，OS 无法修改 GPU MMIO region，OS 无法修改 PCIe 路由，保护通过 MMIO&#x2F;DMA 传输的命令&#x2F;代码&#x2F;数据</li><li>Trusted application-to-GPU communication: U-enclave 发起的 GPU 命令要先通过对称加密的密钥保护的信道传递给 G-enclave，由其作为代表发送</li></ol><p><img src="/img/HIX/T1.png"></p><h4 id="GPU-Enclave"><a href="#GPU-Enclave" class="headerlink" title="GPU Enclave"></a>GPU Enclave</h4><p>G-Enclave 的目标：对 GPU 的单一控制 + 用户访问 GPU 的唯一接口</p><p>HIX 将 GPU Driver 的核心功能转移至 G-enclave，其他良性内核功能仍保留在内核中。需要对 SGX 做扩展，使有且仅有 G-enclave 可以访问 GPU MMIO 区域。</p><h5 id="GPU-MMIO-Registration"><a href="#GPU-MMIO-Registration" class="headerlink" title="GPU MMIO Registration"></a>GPU MMIO Registration</h5><p>HIX 扩展了两条 SGX 指令，EGCREATE, EGADD，用于注册 GPU MMIO regions</p><p>扩展的硬件需要知道：</p><ol><li>哪部分 MMIO region 应该被保护起来</li><li>这部分 MMIO region 应该被映射到 G-enclave 的哪部分地址空间</li><li>哪个 G-enclave 应该被允许访问</li></ol><p>HIX 新增了两种数据结构，存放到 EPC 中</p><ol><li>GPU enclave control structure (GECS): the control information regarding the GPU enclave including the hardware GPU number and GPU enclave ID.</li><li>GPU MMIO region table (TGMR): the virtual and physical address mapping information of the GPU MMIO region, which is used to verify the address mapping for the MMIO region.</li></ol><p><img src="/img/HIX/F4.png"></p><p>（1）通过指令 EGCREATE 创建 G-enclave：将 &lt;GPU-BDF, G-enclave-ID&gt; 存放进 GECS 中，保证同一个 G-enclave 只对应一个 GPU<br>（2）通过指令 EADD 添加 GPU MMIO 区域的 &lt;VA, PA&gt; 存放进 TGMR 中，之后对 MMIO region 的访问会经过验证</p><h5 id="GPU-Initialization-and-Measurement"><a href="#GPU-Initialization-and-Measurement" class="headerlink" title="GPU Initialization and Measurement"></a>GPU Initialization and Measurement</h5><p>G-enclave 创建并加载后，首先验证 GPU BIOS 的完整性，并彻底清空 GPU 的状态</p><h5 id="GPU-Protection-on-GPU-Enclave-Termination"><a href="#GPU-Protection-on-GPU-Enclave-Termination" class="headerlink" title="GPU Protection on GPU Enclave Termination"></a>GPU Protection on GPU Enclave Termination</h5><p>如果 OS 强行杀死 G-enclave 进程，杀死的 G-enclave 进程仍然唯一的拥有 GPU 对应资源，除非系统断电重启，否则任何软件都无法访问这部分资源，而重启时 GECS 和 TGMR 都会重置并清空 GPU 数据。</p><p>如果 OS 优雅的结束 G-enclave 进程，G-enclave 会先清空 GPU 数据并将 GPU 使用权还给 OS，同时通知 U-enclave GPU 不再可信。</p><h4 id="Securing-I-O-Path-MMIO-and-DMA"><a href="#Securing-I-O-Path-MMIO-and-DMA" class="headerlink" title="Securing I&#x2F;O Path: MMIO and DMA"></a>Securing I&#x2F;O Path: MMIO and DMA</h4><p>保护向 GPU 发送的命令和数据，保护以 MMIO&#x2F;DMA 发送的数据得以保护</p><h5 id="MMIO-Access-Protection"><a href="#MMIO-Access-Protection" class="headerlink" title="MMIO Access Protection"></a>MMIO Access Protection</h5><p>发生 TLB Miss 后添加新的 TLB entry 前，硬件 page table walker 会进行四次检查：</p><ol><li>检查 GECS，确保当前进程是 G-enclave</li><li>VA 和 G-enclave 的请求对应</li><li>VA 和 TGMR 中某一项相符</li><li>PA 和 TGMR 对应项相符</li></ol><h5 id="MMIO-Lockdown-and-Securing-PCIe-Routing"><a href="#MMIO-Lockdown-and-Securing-PCIe-Routing" class="headerlink" title="MMIO Lockdown and Securing PCIe Routing"></a>MMIO Lockdown and Securing PCIe Routing</h5><p>HIX 提供 MMIO 锁机制，即 PCIe RC 在收到主机发来的事务包时，会检测其是否为修改 MMIO 映射或修改 PCIe 路由，若是则直接丢弃该包。</p><p>锁机制在 EGCREATE 命令时启用</p><h5 id="Trusted-DMA"><a href="#Trusted-DMA" class="headerlink" title="Trusted DMA"></a>Trusted DMA</h5><p>OS 通过恶意篡改 IOMMU 页表可以将 DMA 数据传送至任何页面。HIX 要求 DMA 数据必须进行加密并通过 message authentication code (MAC) 进行验证。</p><p>通过该机制，只有加密的 DMA 数据才会出现在不安全的缓冲区，并通过 MAC 验证，密钥的传递是安全的（后文），故 DMA 数据得以保护。</p><h4 id="Application-to-GPU-Communication"><a href="#Application-to-GPU-Communication" class="headerlink" title="Application-to-GPU Communication"></a>Application-to-GPU Communication</h4><p><img src="/img/HIX/F5.png"></p><p>G-enclave 对 GPU 有唯一的控制权，故需要向 U-enclave 提供一些获取 GPU 服务的接口，GPU 和不同的 U-enclave 同i性能使用不同的密钥。</p><p><strong>Trusted Runtime User Library</strong></p><p>HIX 为 U-enclave 提供了一套安全的 API，U-enclave 通过这些 API 和 GPU 交互，隐藏 HIX 的硬件细节。</p><h5 id="Secure-Inter-Enclave-Communication"><a href="#Secure-Inter-Enclave-Communication" class="headerlink" title="Secure Inter-Enclave Communication"></a>Secure Inter-Enclave Communication</h5><p>HIX 使用对称加密技术确保 G-enclave，U-enclave，GPU 三方通信，使用 SGX local attestation 技术完成彼此的验证。</p><p>U-enclave 和 G-enclave 中设立了两条通道：message queue 和 shared memory。U-enclave 将发送给 G-enclave 的数据放至 shared memory，然后向 message queue 发送请求，G-enclave 接受并处理数据。</p><h5 id="Secure-Communication-between-the-GPU-Enclave-and-GPU"><a href="#Secure-Communication-between-the-GPU-Enclave-and-GPU" class="headerlink" title="Secure Communication between the GPU Enclave and GPU"></a>Secure Communication between the GPU Enclave and GPU</h5><p>GPU command buffer 在 HIX 保护下的 MMIO region，G-enclave 通过 MMIO 向 GPU 发送 U-enclave 对 GPU 的请求。</p><p>数据传输链：U-enclave -&gt; G-enclave -&gt; GPU，期间涉及两对密钥的加解密过程，性能开销大。HIX 采取 single-copy 方法，使用相同的密钥，G-enclave 可以发送命令将 GPU 数据复制到 shared memory 或将 shared memory 数据复制到 GPU，复制可以通过 MMIO 或 DMA 来完成。</p><h5 id="Communication-Example"><a href="#Communication-Example" class="headerlink" title="Communication Example"></a>Communication Example</h5><p>U-enclave 向 GPU 传递数据&#x2F;命令的流程：</p><ol><li>向 message queue 发送 cuMemcpyHtoD request，同时附带元数据</li><li>向 shared memory 发送加密的实际数据</li><li>G-enclave 将加密数据直接复制给 GPU</li><li>G-enclave 向 GPU 发送一个解密内核任务，用于对加密数据的解密</li></ol><h2 id="论文精读"><a href="#论文精读" class="headerlink" title="论文精读"></a>论文精读</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><div class="original-text">    Traditional CPUs and cloud systems based on them have embraced the hardware-based trusted execution environments to securely isolate computation from malicious OS or hardware attacks. However, GPUs and their cloud deployments have yet to include such support for hardware-based trusted computing. As large amounts of sensitive data are offloaded to GPU acceleration in cloud environments, ensuring the security of the data is a current and pressing need. As deployed today, the outsourced GPU model is vulnerable to attacks from compromised privileged software. To support isolated remote execution on GPUs even under vulnerable operating systems, this paper proposes a novel hardware and software architecture, called HIX (Heterogeneous Isolated eXecution). HIX does not require modifications to the GPU architecture to offer protections: Instead, it offers security by modifying the I/O interconnect between the CPU and GPU, and by refactoring the GPU device driver to work from within the CPU trusted environment. A result of the architectural choices behind HIX is that the concept can be applied to other offload accelerators besides GPUs. This work implements the proposed HIX architecture on an emulated machine with KVM and QEMU. Experimental results from the emulated security support with a real GPU show that the performance overhead for security is curtailed to 26% on average for the Rodinia benchmark, while providing secure isolated GPU computing.</div><div class="analysis-section">    研究背景（2019 年）：GPU 侧的 TEE 尚未实现，而大量敏感数据被卸载到 GPU 上运行（例如外包 GPU 模型），亟需完成 GPU 上的 TEE 部署 <br>    <br>    论文提出了一个软硬件架构：HIX，HIX 不需要修改 GPU 的硬件，但需要调整 CPU 和 GPU 之间的 I/O 数据传输模块，并将 GPU Driver 运行在 CPU 可信执行环境中。 <br>    HIX 架构适用于多种加速器，不局限于 GPU</div><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h3><div class="original-text">    In conventional CPU-based computation, hardware-based trusted execution environments (TEE) such as Intel SGX and ARM    TrustZone have been providing trusted and isolated computing environments to user applications. Such hardware-based TEEs    reduce the trusted computing base (TCB) of the computation to the processor and critical code running in TEE. With the    TEE support, security-critical applications can be protected from compromised privileged software as well as    hardware-based attacks to the memory and system buses, to provide secure computation running on untrusted remote cloud    servers.</div><div class="analysis-section">    当今基于硬件实现的 TEE 将 TCB 缩小到处理器和可信代码，提供在不可信云服务器上的可信计算</div><div class="original-text">    With increasing use of general purpose GPU computing from traditional high performance computing to data center    acceleration and machine learning applications, securing the GPU computation has become critical to protect security    sensitive data [34, 45, 56, 57]. However, although even more and more critical data are processed in GPUs, trusted    computing is yet to be supported in GPU computation. In the current system architecture, high performance discrete GPUs    communicate with CPUs through I/O interconnects such as PCI Express (PCIe) buses, and the GPU driver which is part of    the operating system controls the GPUs [25]. As the privileged operating system can fully control the hardware I/O    interconnects and GPU driver, computing in GPUs is vulnerable to potential attacks on the operating system [8]. Beyond    the GPU-based computing, the proliferation of various accelerator-based computing models has been increasing the demands for higher-level of security supports for accelerators under the vulnerable privileged software.</div><div class="analysis-section">    GPU 和 CPU 通过 PCIe 总线进行通信，驱动负责控制通信，OS 完全管理驱动和 PCIe 总线，故 GPU 侧数据很容易受到攻击</div><div class="original-text">    In existing architectures, both of the code and data in GPUs can be compromised by a privileged adversary. Recent work    has demonstrated that the integrity of GPU code can be subverted by disrupting and replacing the code at runtime with an    off-the-shelf reverse engineering tool [13]. In addition to code, data in GPU can potentially be uncovered and leaked    [45]. GPU data vulnerable to confidentiality attacks comprises both the communication data being transferred to and from    a GPU, and the data being processed within a GPU. The susceptibility of GPUs to confidentiality and integrity attacks    stems from the lack of access control to their interfaces such as the I/O interconnects and memory-mapped I/O addresses.    To support secure computing in GPUs, this paper proposes a novel hardware and software architecture for isolating GPUs    even from the potentially malicious privileged software (OS and hypervisor). The proposed architecture, called    Heterogeneous Isolated eXecution (HIX), requires minor extensions to the current PCIe interconnect implementation and    the TEE support in CPUs. The goal of HIX is to extend the security guarantees, namely confidentiality and integrity of    user data, of TEE technologies to heterogeneous computing environments. At the time of writing, none of these    technologies protect accelerators in heterogeneous systems from privileged software attacks; they only protect the code    and data in trusted “enclaves” running on the processors. In this work, we expand the scope of a widely used trusted    isolation technology, Intel SGX, to secure general purpose accelerators, in particular GPUs.</div><div class="analysis-section">    目标：保护 GPU 数据（通信路径上的数据、GPU 内运行的数据）的完整性和机密性 <br>    产生攻击面的原因：I/O 接口和 MMIO 的控制过少 <br>    HIX 需要扩展 PCIe interconnect 和 CPU 侧 TEE（扩展 SGX）</div><div class="original-text">    Our proposed architecture consists of four main hardware and software changes. First, key functions of the GPU driver    are removed from the operating system (OS) and relocated in a separate process in its own GPU enclave. The GPU enclave    is an extension of the current SGX enclave, designed to exclusively manage the GPU. Second, the PCIe interconnect    architecture is slightly modified to prevent the OS from changing the routing configuration of the interconnect, once    the GPU enclave is completely initialized. Third, the memory management unit (MMU) is augmented to protect the memory    mapped GPU I/O region from unauthorized accesses. Fourth, the CPU counterpart process of a GPU application runs on an    SGX enclave, and the SGX enclave sets up a trusted communication path to the GPU enclave, which is robust even against    privileged adversaries.    To support the secure execution environments for GPUs without any GPU modification, HIX does not provide the protection    against direct hardware-based attacks, as PCIe buses and the memory of GPUs are exposed to such hardware attacks in the    current architecture. Although the security level is lower compared to the hardware TEEs for CPUs, HIX can be extended    to other accelerators without requiring any modification of the accelerators themselves, if the accelerator is connected via I/O interconnects.</div><div class="analysis-section">    HIV 的核心功能需要四个主要的硬件/软件修改：    <ul>        <li>GPU 驱动的核心函数从内核空间中转移到单独的 GPU enclave</li>        <li>PCIe 互连组件需要修改，防止 OS 恶意修改其路由配置</li>        <li>MMU 加强，保护 GPU MMIO 区域被无权限者访问</li>        <li>和 GPU 进程相对应的主机侧进程在 enclave 中运行</li>    </ul>    HIX 不需要修改 GPU 硬件，可以扩展到其他加速器设备上，但防御深度弱于 CPU TEE</div><div class="original-text">    We evaluate the proposed architecture in terms of security and performance. We have implemented a prototype for HIX on    KVM and QEMU, adding extra instructions for the GPU enclave and separating the GPU driver from the operating system. The    prototype using the emulation connected to a real GPU shows that the performance degradation introduced by HIX secure    GPU computation is 26% compared to the conventional unsecure GPU computation for the benchmarks from the Rodinia suite.    We summarize the main contributions of this work as follows:    <ul>        <li>We provide an attack surface assessment of GPU computation. We identify key GPU components that can be attacked from        privileged software: PCIe interconnect, memory mapped I/O region, and GPU driver.</li>        <li>We augment the design of the PCIe interconnect to block any routing change after the GPU initialization, and to further        guarantee the address mapping immutability of the memory mapped I/O region to the GPU.</li>        <li>We extend the current SGX interface to support the GPU enclave, which runs the GPU driver in a secure way. The MMU        design is extended to protect the GPU memory mapped I/O region from unauthorized accesses.</li>        <li>We implement a prototype on an emulated system with KVM and QEMU to evaluate the performance overhead of HIX. Although        it is implemented in the emulated system due to the required changes in hardware, it faithfully reflects necessary        changes in hardware interfaces and software architectures.</li>    </ul>    The rest of the paper is organized as follows. Section 2 describes the current architecture of SGX, PCIe, and GPU    driver. Section 3 discusses the threat model. Section 4 presents the proposed architecture. Section 5 discusses the    security analysis and shows performance results. Section 6 presents the prior work and Section 7 concludes the paper.</div><div class="analysis-section">    HIX 的四大贡献：    <ul>        <li>特权软件可能会攻击的三大 GPU 组件：PCIe 互连设备、MMIO 区域、GPU 驱动</li>        <li>加强 PCIe 互连设备，保证 MMIO 映射、PCIe RC 路由无法被非法修改</li>        <li>扩展 SGX 以支持 GPU enclave，将 GPU 驱动的关键函数以一种安全的方式运行，加强 MMU 防止无权限者访问 GPU MMIO 区域</li>        <li>完成了性能评估</li>    </ul></div><h3 id="2-Background"><a href="#2-Background" class="headerlink" title="2 Background"></a>2 Background</h3><div class="original-text">    HIX is designed on top of Intel SGX architecture and the PCI Express standard. We provide a brief overview of these    technologies in this section.</div><div class="analysis-section">    这部分进行 SGX、PCIe 的简述</div><h4 id="2-1-Intel-Software-Guard-Extensions-SGX"><a href="#2-1-Intel-Software-Guard-Extensions-SGX" class="headerlink" title="2.1 Intel Software Guard Extensions (SGX)"></a>2.1 Intel Software Guard Extensions (SGX)</h4><div class="original-text">    Intel SGX is a hardware-based protection technology that provides a trusted execution environment (TEE) called an    enclave, protected even from the privileged software and direct hardware attacks. SGX protects the enclave memory and    execution contexts to support the strong isolated execution. The SGX hardware-based isolated execution is augmented by an attestation service that verifies the integrity of the code running on the enclave [1, 35].    The main memory is untrusted under the SGX threat model, and thus, SGX provides memory encryption and access restriction    mechanisms to protect a small region of main memory for enclaves, called the enclave page cache (EPC). Although SGX uses    the virtual memory support provided by the untrusted OS, it protects EPC pages from unauthorized accesses with    hardware-based verification. Figure 1 illustrates the structure of SGX address space. In the figure, ELRANGE (Enclave    Linear Address Range) is the protected virtual address range in the enclave, and the pages in the range are guaranteed    to be mapped to EPC pages. When an enclave is created, the system software registers the virtual address and    corresponding EPC physical address of a page in the protected memory using EADD SGX instruction. During handling of the    EADD instruction, the hardware stores the mapping information in the enclave page cache map (EPCM) to verify future    accesses to the page during address translation in MMU [9].    <img src="/img/HIX/F1.png" alt="" style="width: 75%;"></div><div class="analysis-section">    SGX 架构中：    <ul>        <li>飞地对应的内存空间是加密的，并集中在内存的 EPC 区域中</li>        <li>一个进程虚拟地址中的用户空间被分为可信和不可信部分，可信部分对应的连续虚拟地址段叫做 ELRANGE</li>        <li>飞地的页表存储在硬件中，叫做 EPCM，飞地的地址映射由 MMU 处理</li>    </ul></div><h4 id="2-2-PCI-Express-Architecture"><a href="#2-2-PCI-Express-Architecture" class="headerlink" title="2.2 PCI Express Architecture"></a>2.2 PCI Express Architecture</h4><div class="original-text">    Modern GPUs are connected to the system via the PCI Express (PCIe) interface. The PCIe interface facilitates    memorymapped I/O (MMIO) access to PCIe devices for software. Since the MMIO mechanism maps the hardware registers and    memory of a device to the system memory address space for software, this enables the software to transparently access    the PCIe devices using regular memory addresses. Figure 2 illustrates how the system routes device access requests to    the device by using the system memory address map [49]. CPU is responsible for distinguishing accesses to the MMIO    regions from main memory accesses. It uses its internal hardware registers which are initialized by BIOS at system boot    time, to route access requests for MMIO appropriately [19]. When the address of a memory access is for the MMIO region,    the PCIe root complex takes the request. As PCIe devices are attached to the system as a tree, where the PCIe root    complex is its root, the root complex creates a PCIe transaction packet and routes it to the desired device, using the    hardware routing registers [5, 43]. These registers are also initialized by the BIOS at system boot time to cover the    entire physical address ranges of attached devices.    Modern PCIe devices use direct memory access (DMA) to directly read or write the main memory without CPU intervention.    The DMA arrows in Figure 2 show how the system routes the DMA request. An input/output memory management unit (IOMMU) can be used to translate device addresses to physical addresses for DMAs [42].</div><div class="analysis-section">    主机进程利用 MMIO 机制，可以像访问普通内存一样访问设备寄存器，CPU 根据内部寄存器（BIOS 初始化）判断访问的内存地址是普通内存还是 MMIO 区域 <br>    当访问 MMIO 区域时，PCIe RC 会接受请求，创建一个 PCIe 业务包并将其路由到目标设备（通过硬件路由寄存器） <br></div>]]></content>
    
    
    
    <tags>
      
      <tag>GPU TEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【论文】HyperEnclave：An Open and Cross-platform Trusted Execution Environment</title>
    <link href="/2025/02/17/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91HyperEnclave%EF%BC%9AAn%20Open%20and%20Cross-platform%20Trusted%20Execution%20Environment/"/>
    <url>/2025/02/17/%E3%80%90%E8%AE%BA%E6%96%87%E3%80%91HyperEnclave%EF%BC%9AAn%20Open%20and%20Cross-platform%20Trusted%20Execution%20Environment/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/css/GPU_TEE.css"><h2 id="论文思路整理"><a href="#论文思路整理" class="headerlink" title="论文思路整理"></a>论文思路整理</h2><h3 id="Threat-Module"><a href="#Threat-Module" class="headerlink" title="Threat Module"></a>Threat Module</h3><ul>    <li>page-table-based attacks</li>    <li>enclave malware attacks</li>    <li>memory mapping attacks</li>    <li>controlled-channel attacks</li></ul><h2 id="论文精读"><a href="#论文精读" class="headerlink" title="论文精读"></a>论文精读</h2><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><div class="original-text">    A number of trusted execution environments (TEEs) have been proposed by both academia and industry. However, most of them require specific hardware or firmware changes and are bound to specific hardware vendors (such as Intel, AMD, ARM,    and IBM). In this paper, we propose HyperEnclave, an open and cross-platform process-based TEE that relies on the    widely-available virtualization extension to create the isolated execution environment. In particular, HyperEnclave is    designed to support the flexible enclave operation modes to fulfill the security and performance demands under various    enclave workloads. We provide the enclave SDK to run existing SGX programs on HyperEnclave with little or no source code    changes. We have implemented HyperEnclave on commodity AMD servers and deployed the system in a world-leading FinTech    company to support real-world privacy-preserving computations. The evaluation on both micro-benchmarks and application    benchmarks shows the design of HyperEnclave introduces only a small overhead.</div><div class="analysis-section">    现存 TEE 需要特定的硬件、固件修改，绑定硬件厂商 <br> <br>    论文提出 HyperEnclave 的设计，其特点如下：<br>    1. 开源 + 跨平台 + 基于进程 + 广泛虚拟化 <br>    2. 支持灵活的飞地运行模式</div><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h3><div class="original-text">    In recent years, trusted execution environments (TEEs) are emerging as a new form of computing paradigm, known as    confidential computing, due to the high demand for privacypreserving data processing technologies that can handle    massive data samples. TEEs provide hardware-enforced memory partitions where sensitive data can be securely processed.    Existing TEE designs support different levels of TEE abstractions, such as process-based (Intel’s Software Guard    eXtensions (SGX) [55]), VM-based (AMD SEV [45]), separate worlds (ARM TrustZone [16]), and hybrid (Keystone [49]).    Currently, the most prominent example of TEEs is Intel SGX, which is widely available in commercial off-the-shelf (COTS)    desktop and server processors.</div><div class="analysis-section">    TEE 的需求日益增长，为私密数据提供硬件隔离 <br>    现有 TEE 提供不同级别的抽象：基于进程、基于虚拟机、独立世界、混合等</div><div class="original-text">    <p style="font-weight: bold;">Motivations.</p>     Most of today’s TEE technologies are closesourced and require specific hardware or firmware changes that are difficult to audit, slow to evolve, and thus are inferior to cryptographic alternatives (such as homomorphic    encryption), which are based upon public algorithms and widely available hardware. Moreover, most existing TEE designs    restrict the enclaves (i.e., the protected TEE regions) to run only in fixed mode.1 It is difficult to support the    performance and security requirements of various types of applications that need to be protected by TEEs. For example,    Intel SGX enclaves run in the user mode and cannot access privileged resources (such as the file system, the IDT, and    page tables) and process privileged events (interrupt and exceptions). As a result, running I/O-intensive and    memory-demanding tasks leads to significant performance degradation.</div><div class="analysis-section">    现有 TEE 大多闭源、需要硬固件修改、发展缓慢 <br>    同时只支持飞地运行在固定模式，不适应多种机密计算场景</div><div class="original-text">    To fill the gap, in this paper we propose the design of HyperEnclave to support confidential cloud computing that can    run securely on both legacy servers readily available in the cloud, and on the rising ARM (or RISC-V in the future)    servers, without requiring specific hardware features. For this purpose, our design provides a process-based TEE    abstraction using the widely available virtualization extension (for isolation) and TPM (for root of trust and    randomness etc.). To better fulfill the needs for specific enclave workloads, HyperEnclave supports the flexible enclave    operation modes, i.e., the enclaves can run at different privilege levels and can have access to certain privileged    resources (see Sec. 4 for more details).</div><div class="analysis-section">    应用场景：安全云计算 <br>    通过 虚拟化技术、TPM 建立基于进程抽象的 TEE <br>    飞地可以运行在多种特权模式下，访问特定特权资源</div><div class="original-text">    <p style="font-weight: bold;">Design details.</p>    In our design, the system runs in three modes. A trusted software layer, called RustMonitor (security monitor written in    Rust), runs in the monitor mode, which is mapped to the VMX root mode. RustMonitor is responsible for enforcing the    isolation and is part of the trusted computing base (TCB). The untrusted OS (referred to as the primary OS) provides an    execution environment for the untrusted part of applications; the untrusted OS and application parts run in the normal    mode, which is mapped to the VMX non-root mode. The trusted part of application (i.e., enclave) runs in the secure mode,    which can be mapped flexibly to ring-3 or ring-0 of the VMX non-root mode, or ring-3 of the VMX root mode.</div><div class="analysis-section">    HyperEnclave 在三种模式下运行：<br>    1. monitor mode：RustMonitor，可信软件（属于 TCB）<br>    2. normal mode：OS 和 untrusted application <br>    3. secure mode：enclave（trusted application）<br>    <br>    monitor mode 映射到 VMX-root-r0 <br>    normal mode 映射到 VMX-non-root-r0~3 <br>    secure mode 映射到 VMX-non-root-r3 | VMX-non-root-r0 | VMX-root-r3（对应三种飞地运行模式）</div><div class="original-text">    Memory isolation is enforced with hardware-based memory protection of the memory-management unit (MMU). As we observe    that existing process-based TEEs (e.g., Inktag [38] and Intel SGX [55]) are vulnerable to page-table-based attacks [74],    our memory isolation scheme chooses to manage the enclave’s page table and page fault events entirely by the trusted    code, removing the involvement of the primary OS. The design also prevents certain types of enclave malware attacks    (Sec. 3.2).</div><div class="analysis-section">    地址映射和隔离是由硬件 MMU 完成的，现有 TEE 的设计中，飞地的页表和也错误均由 OS 处理，可能会遭到基于页表的攻击。在 HyperEnclave 中，将页表和也错误完完全全交给可信代码管理（消除了 OS 的参与）</div><div class="original-text">    To minimize the attack surface, we adopt an approach called measured late launch: the primary OS kernel is first booted;    then a chunk of special kernel code, implemented as a kernel module in the primary OS, runs to initiate RustMonitor in    the most privileged level (i.e., the monitor mode) and demotes the primary OS to the normal mode. All booted components    during the booting process are measured and extended to the TPM Platform Configuration Registers (PCRs). Since the TPM    attestation guarantees that PCRs cannot be rolled back, the design ensures that RustMonitor is securely launched;    otherwise, a violation of the TPM quote would be detected during remote attestation.</div><div class="analysis-section">    为了最小化攻击面，HyperEnclave 采取 measured late launch 的策略 <br>    启动顺序：OS 内核 -> 特定内核代码（初始化 RustMonitor，将其变成 monitor mode，将 OS 变成 normal mode） <br>    <br>    所有启动组件都会被测量并记录到 TPM PCR 寄存器中（只允许扩展），用于远程验证</div><div class="original-text">    We have implemented HyperEnclave on commodity AMD servers. In total RustMonitor consists of about 7,500 lines of Rust    code. The APIs of our enclave SDK are compatible with the official SGX SDK. As a result, code written for SGX could be    easily ported to run on HyperEnclave by recompiling the code with little (or no) source code changes. We have ported a    number ofSGX applications, as well as the Rust SGX SDK [71] and the Occlum library OS [64] to HyperEnclave. The    micro-benchmarks show that the overheads for ECALLs and OCALLs are < 9,700 and < 5,260 cycles respectively (14,432 and    12,432 cycles respectively on Intel SGX). The evaluation on a suite of real-world applications shows that the    overhead is small (e.g., the overhead on SQLite is only 5%).</div><div class="analysis-section">    在商用 AMD 服务器上实现等内容</div><div class="original-text">    <p style="font-weight: bold;">Contributions.</p>    In summary, the paper proposes the design of HyperEnclave, with the following contributions:    <ul>        <li>An open2 and cross-platform processed-based TEE with minimum hardware requirements (virtualization extensions and TPM)        that can run existing SGX programs with little or no source code changes, which enables the reuse of the rich toolchains        and ecosystem for Intel SGX.</li>        <li>Supporting the flexible enclave operation modes to fulfill the diverse security and performance requirements of enclave        applications without hardware or firmware changes.</li>        <li>A memory isolation scheme that the enclave’s page table and page fault are managed entirely by the trust code, which        mitigates the page-table-based attacks and the enclave malware attacks.</li>        <li>A measured late launch approach, combined with the TPMbased attestation to reduce the attack surface.</li>        <li>An implementation on commodity servers (mostly) using the memory safe language Rust, and an evaluation on real hardware and applications, demonstrating that the proposed design is practical and only has a small overhead</li>    </ul></div><div class="analysis-section">    论文的贡献：    <ul>        <li>设计了一个开源、跨平台、进程抽象层的 TEE </li>        <li>支持灵活的飞地运行模式</li>        <li>提出了内存管理模式：页表和页错误全部由可信代码管理</li>        <li>检测后启动原则</li>        <li>使用 Rust 语言在商用服务器上实现</li>    </ul></div><h3 id="2-Background"><a href="#2-Background" class="headerlink" title="2 Background"></a>2 Background</h3><h4 id="2-1-Trusted-Execution-Environment"><a href="#2-1-Trusted-Execution-Environment" class="headerlink" title="2.1 Trusted Execution Environment"></a>2.1 Trusted Execution Environment</h4><div class="original-text">    A Trusted Execution Environment (TEE) is designed to ensure that sensitive data is stored, processed, and protected in    an isolated and trusted environment. The isolated area could be a separate system apart from the normal operating system    (such as the TrustZone [16] secure world), a part of a process address space (such as an Intel SGX [55] enclave), or a    stand-alone VM (such as a virtual machine protected by AMD SEV [45] or Intel TDX [41]). To resist the privileged    attacker, TEE needs to thwart not only the OS-level adversary but also the malicious party who has physical access to    the platform. To this end, it offers hardware-enforced security features including isolated execution, integrity, and    confidentiality protection of the enclave, along with the ability to authenticate the code running inside a trusted    platform through remote attestation.</div><div class="analysis-section">    TEE 需要保证：    <ul>        <li>隔离执行、完整性保护、机密性保护</li>        <li>远程验证</li>    </ul></div><div class="original-text">    <p style="font-weight: bold;">Isolation.</p>    At the core of a TEE is the memory isolation scheme, which guarantees that code, data, and the runtime state of the    enclave cannot be accessed or tampered with by untrusted parties. For Intel SGX, the protected memory (i.e., the    enclave) is mapped to a special physical memory area called Enclave Page Cache (EPC), which is encrypted and cannot be    directly accessed by other software, firmware, BIOS, and direct memory access (DMA).</div><div class="analysis-section">    TEE 核心是内存隔离模式 <br>    对于 Intel SGX，被保护的内存被映射到内存的特殊区域（EPC），EPC 被加密且不能被其他软件、固件、BIOS、DMA 访问</div><div class="original-text">    <p style="font-weight: bold;">Attestation.</p>    The goal of remote attestation is to generate an attestation quote, which includes the measurement of the software    state, signed with the attestation key embedded in the hardware. The remote user verifies the validity of the quote by    checking the signature (which reflects the hardware identity) and the measurement (which proves the software state).</div><div class="analysis-section">    远程验证的目的是生成一个验证引用 <br>    引用包含软件的测量值和嵌入硬件的私钥签名，用户可以通过引用检查软硬件的合法性</div><h4 id="2-2-Trusted-Platform-Module"><a href="#2-2-Trusted-Platform-Module" class="headerlink" title="2.2 Trusted Platform Module"></a>2.2 Trusted Platform Module</h4><div class="original-text">    Trusted Platform Module (TPM) is both an industrystandard [36] and an ISO/IEC standard [4] for a secure cryptoprocessor.    It is used by nearly all PC and server manufacturers. Firmware TPMs (fTPMs) are firmware-based (e.g. UEFI) TPM    implementations. At the time of this writing, Intel, AMD, and Qualcomm all have implemented fTPMs.</div><div class="analysis-section">    TPM 是安全加密处理器，广泛使用于当代计算机中</div><div class="original-text">    TPM has a set of Platform Configuration Registers (PCRs), which can be used for the measurement of the booted code    during the boot process. PCRs are reset to zero on system reboot or power on-off. During every boot process, the PCRs    can only be extended with the new measurement (called PCR extend), and thus cannot be set to arbitrary values.</div><div class="analysis-section">    TPM 中包含 PCR 寄存器，用于存储启动软件的测量值，开机重置为 0，只能扩展不能重写</div><div class="original-text">    Every TPM ships with a unique asymmetric key, called the Endorsement Key (EK), embedded by the manufacturer as the root    of trust. The TPM can generate a quote of the PCR values, signed using the TPM Attestation Identity Keys (AIK), while the AIK is generated inside TPM and certified using EK. Any modifications of the booted code would be reflected in the quote. Upon receiving the quote, the remote party can validate the signing key comes from an authentic TPM and can be assured that the PCR digest report has not been altered.</div><div class="analysis-section">    TPM 拥有嵌入硬件的密钥 EK <br>    TPM 内部生成并由 EK 认证的密钥 AIK <br>    TPM PCRs 测量值由 AIK 签名，交给用户，用户进行审核</div><h4 id="2-3-Threat-Model"><a href="#2-3-Threat-Model" class="headerlink" title="2.3 Threat Model"></a>2.3 Threat Model</h4><div class="original-text">    Like the other TEE proposals [23, 49], we trust the underlying hardware, including the processor establishing the    virtualization-based isolation, the System Management Mode (SMM) code, as well as the TPM. We assume that the Core Root    of Trust for Measurement (CRTM) is trusted and immutable. HyperEnclave mitigates certain physical memory attacks, such    as cold boot attacks and bus snooping attacks with the hardware support for memory encryption. We don’t fully trust the    operator and assume the attacker cannot mount physical attacks during the boot process, i.e., we assume that the system    is initially benign (during system boot), and the early OS during the boot stage is part of the TCB. This can be    achieved in two ways.    <ul>        <li>Firstly, the power-on event can be secured with a hardware device, such as an HSM (i.e., hardware security module). The        platform enters the boot process only with the engagement and supervision of a trusted party, who owns the HSM. After        that, the operators for maintenance are not trusted.</li>        <li>Secondly, the boot process can be enhanced to defend against adversaries with physical accesses. To prevent I/O attacks,        we can harden the OS to remove unnecessary devices and disable the DMA capability of peripherals before IOMMU is        enabled. We can enable memory encryption at an early stage (e.g., in the BIOS, before any off-chip memory is used) to        prevent physical memory attacks.</li>    </ul></div><div class="analysis-section">    信任软硬件名单：    <ul>        <li>负责提供虚拟化隔离机制的处理器</li>        <li>系统管理模式代码 SMM Code</li>        <li>TPM 和 CRTM</li>    </ul>    额外的假设：    <ul>        <li>攻击者无法在系统启动阶段实施物理攻击</li>        <li>启动初期系统是良态的，初期 OS 属于 TCB</li>    </ul>    论文通过理论描述，证明了额外的假设一定可以实现</div><h3 id="3-Design"><a href="#3-Design" class="headerlink" title="3 Design"></a>3 Design</h3><div class="original-text">    HyperEnclave is designed to support confidential cloud computing without requiring specific hardware features.    Therefore, HyperEnclave is built upon the widely available virtual ization extension. In particular, HyperEnclave is designed to support the process-based TEE model (similar to Intel SGX) for the following reasons.    <ul>        <li>Minimized TCB. To protect an application using the process-based TEE, the TCB includes only the protected code itself,        while in the other forms of TEE, much more code must be included, such as the guest operating system for VM-based TEEs.</li>        <li>Established ecosystem. Since Intel SGX is currently the most prevalent TEE supported in the cloud (major CSPs, including        GCP, Azure, and Aliyun, provide SGX-based instances [9, 62]), a rich set of toolchains and applications have been        developed. Supporting the SGX model reduces the porting effort and makes it easy to deploy confidential computing tasks        in the cloud.</li>        <li>Cloud computing trends. We have witnessed a clear trend towards running container-based serverless applications in the        cloud. Protecting these applications against untrusted clouds using TEEs is important. Considering that such computing        tasks are typically short-lived, and favor a short startup time, maintaining a VM seems to be too heavy-weight.</li>    </ul>    In this section, we introduce HyperEnclave using x86 notations, as we prototyped HyperEnclave on AMD servers.</div><div class="analysis-section">    为什么要模仿 SGX 实现一个进程抽象的 TEE <br>    最小化 PCB + SGX 很火可以借鉴 + 短期云计算畅行（虚拟机管理成本高）</div><h4 id="3-1-System-Overview"><a href="#3-1-System-Overview" class="headerlink" title="3.1 System Overview"></a>3.1 System Overview</h4><div class="original-text">    HyperEnclave supports the following modes: the monitor mode, i.e., VMX root operation mode; the normal mode for the    primary OS and untrusted part of applications, i.e., ring-0 and ring-3 of the VMX non-root operation mode respectively;    and the secure mode for the enclave, which could be ring-3 and ring-0 of the VMX non-root operation mode, or ring-3 of    the VMX root operation mode, depending on the enclave operation mode. We will introduce the flexible operation mode    supported by HyperEnclave in Sec. 4. As illustrated in Figure 1, HyperEnclave consists of the following components:    <ul>        <li>RustMonitor is a lightweight hypervisor running in the monitor mode that manages the enclave memory, enforces the memory        isolation, and controls the enclave state transitions. It works as a resource monitor, while complicated tasks are        offloaded to the primary OS.</li>        <li>RustMonitor creates a unique guest VM (referred to as the normal VM) that runs the primary OS (such as Linux) and hosts        the untrusted part of applications in the normal mode. The primary OS is still in charge of process scheduling and I/O        devices management, but it is not trusted by the RustMonitor and enclaves.</li>        <li>Application is the untrusted part of the application which runs in the primary OS.</li>        <li>The kernel module. We provide a kernel module in the primary OS to load, measure, and launch RustMonitor, as well as to        invoke the emulated privileged operations.</li>        <li>To ease development, HyperEnclave provides an enclave SDK with APIs compatible with the official Intel SGX SDK [12],        including both the untrusted runtime and trusted runtime (i.e., SDK uRTS and SDK tRTS). As such, most SGX programs can        run on HyperEnclave with little or no source code changes.</li>        <li>Enclave is the trusted part of the application running in the secure mode.</li>    </ul>    <img src="/img/HyperEnclave/F1.png" alt="" style="width: 75%;"></div><div class="analysis-section">    HyperEnclave 包括五个组成部分：    <ul>        <li>1. RustMonitor</li>        <li>2. guest VM</li>        <li>3. Application</li>        <li>4. kernel module</li>        <li>5. enclave SDK</li>        <li>6. Enclave</li>    </ul>    一个应用进程调用步骤示例： <br>    使用 SDK 提供的 API 发起 Enclave 调用 -> 内核模块捕获指令 -> RustMonitor 验证合法性 -> 初始化飞地并执行 -> 结果返回给 OS</div><h4 id="3-2-Memory-Management-and-Protection"><a href="#3-2-Memory-Management-and-Protection" class="headerlink" title="3.2 Memory Management and Protection"></a>3.2 Memory Management and Protection</h4><div class="original-text">    <p style="font-weight: bold;">Challenges.</p>    For process-based TEEs, the enclave runs in the user mode and is not able to manage its own page table. Existing designs    (e.g., Intel SGX, TrustVisor [54]) allow the untrusted OS to manage the enclave’s page table. To prevent memory mapping    attacks (i.e., attacks by manipulating the enclave’s address mappings, as shown in Figure 9, Appendix A.1), the design    of SGX extends the Page Missing Handler (PMH) and introduces a new metadata called EPCM for additional security checks    on TLB misses [32]. Without secure hardware support, a prevalent software solution [19, 54, 75] is to make the page    tables write-protected by setting the page table entries (PTEs) for pages holding the page tables, i.e., any update to    the page table traps to the hypervisor and then be verified. However, on x86 platforms the updates of access and dirty    bits of the PTEs also trap into the hypervisor, leading to non-negligible overhead. Even-worse, since the enclave page    fault is also processed by the OS, the above designs are still vulnerable to the page table-basedattacks, such as the    controlled-channel attacks [74].</div><div class="analysis-section">    SGX 的页表由 OS 管理，SGX 将页表设置为只读防止页表映射攻击，但是由于每次更新页表都需要经过管理程序的验证（包括访问位和脏位），开销过大 <br>    页错误仍由 OS 管理，会受到受控通道攻击的影响</div><div class="original-text">    The design becomes more challenging to support enclave dynamic memory management (i.e., EDMM on SGX2 platforms [34]),    i.e, dynamically adding or removing enclave pages, or changing the enclave page attributes or types after the enclave is    initialized. Without EDMM, all physical memory that the enclave might ever use must be committed before enclave    initialization. Therefore, EDMM reduces enclave build time and enables new enclave features, such as on-demand stack and heap growth, and on-demand creation of code pages to support just-in-time (JIT) compilation. On SGX2 platforms, the enclaves need to send the EDMM request to the SGX driver through OCALLs, who then makes the requested changes. Since the driver is untrusted by the enclaves, the changes need to be explicitly checked and accepted by the enclaves to take effect, which involves heavy enclave mode    switches.</div><div class="analysis-section">    另外一大难点是支持动态分配飞地内存（EDMM），即在飞地初始化后动态添加/删除飞地页 <br>    SGX 中飞地发送 OCALL 指令给驱动程序，驱动程序修改后交给飞地管理程序，由于驱动不可信，飞地管理程序需要显示检查后才能接受，这涉及大量安全区模式切换。</div><div class="original-text">    <p style="font-weight: bold;">HyperEnclave memory management.</p>    The design becomes more challenging to support enclave dynamic memory management (i.e., EDMM on SGX2 platforms [34]),    i.e, dynamically adding or removing enclave pages, or changing the enclave page attributes or types after the enclave is    initialized. Without EDMM, all physical memory that the enclave might ever use must be committed before enclave    initialization. Therefore, EDMM reduces enclave build time and enables new enclave features, such as on-demand stack and    heap growth, and on-demand creation of code pages to support just-in-time (JIT) compilation. On SGX2 platforms, the    enclaves need to send the EDMM request to the SGX driver through OCALLs, who then makes the requested changes. Since the    driver is untrusted by the enclaves, the changes need to be explicitly checked and accepted by the enclaves to take    effect, which involves heavy enclave mode switches.</div><div class="analysis-section">    上述问题的本质：飞地页表和页错误由 OS 管理 <br>    HyperEnclave 为飞地设置一个单独的页表，飞地页表和页错误全部由 RustMonitor 管理，但是会带来飞地页表和普通进程页表的同步问题。</div><div class="original-text">    To eliminate the overhead for synchronization, we preallocate a marshalling buffer in the application’s address space,    which is shared with the enclave. The mappings of the marshalling buffer are fixed during the entire enclave life cycle    by pre-populating the physical memory and pinning it in the memory. All data exchanged between the enclave and the    application must be passed through the marshalling buffer. The application’s memory mappings (except those for the    marshalling buffer) are not needed by the enclave and are not included in the enclave’s page table. Such a design also    mitigates the known enclave malware attacks [63], as the enclave cannot access the application’s address space but the    marshalling buffer (Sec. 6 for more details). We remind the attacker may manipulate the marshalling buffer, however it    does not cause additional security issues, since the buffer is untrusted by design where the developer is responsible to    ensure that the data transmitted through the buffer is authentic and protected (same as the SGX model).</div><div class="analysis-section">    为了消除飞地页表和普通进程页表的同步问题，HyperEnclave 引入了 marshalling buffer 用来完成进程用户空间和飞地空间的参数交换，marshalling buffer 的映射是固定的，用户在撰写代码时有责任确保 marshalling buffer 涉及的参数交换是安全的。 <br>    飞地的页表无需存放普通的进程空间映射，应用进程也无法意识到飞地空间的存在</div><div class="original-text">    When the enclave accesses a virtual address that is not committed with a physical page (e.g., due to page swapping or    EDMM), a page fault is raised and the enclave traps to RustMonitor. RustMonitor picks up a free page from the enclave    memory pool, inserts a new mapping to the enclave’s page table, and resumes the enclave’s execution. When the enclave    requests changing the page permissions, the enclave issues a hypercall to RustMonitor to update the permissions in the    enclave’s page table and clear the corresponding TLB entries.4</div><div class="analysis-section">    发生缺页错误时，RustMonitor 响应该错误并在对应飞地内存池中分配一个空闲页，恢复飞地的运行。当飞地希望修改页面权限时，RustMonitor 响应，更新飞地页面权限以及清空 TLB 对应栏目</div><div class="original-text">    <p style="font-weight: bold;">HyperEnclave memory isolation.</p>    Figure 2 shows the memory mappings of the applications within the normal VM and the enclaves. The application’s memory within the normal VM is managed with nested paging, while the enclave’s memory could be managed through nested paging or through normal 1-level address translation, determined by the corresponding operation mode (Sec. 4). As a result, HyperEnclave enforces the    following security requirements.    <ul>        <li>R-1: The primary OS and applications are not allowed to access the physical memory belonging to RustMonitor and the        enclaves.</li>        <li>R-2: The enclave is not allowed to access physical memory belonging to RustMonitor and other enclaves. It is designed to        have access to only a specific memory region shared with the untrusted application for parameter passing (i.e., the        marshalling buffer).</li>        <li>R-3: DMA accesses from malicious peripherals to the physical memory belonging to RustMonitor and the enclaves are not        allowed. In order to prevent such attacks, HyperEnclave restricts the physical memory used by the peripherals with the        support of the Input-Output Memory Management Unit (IOMMU) in modern processors.</li>    </ul>    <img src="/img/HyperEnclave/F2.png" alt="" style="width: 75%;"></div><div class="analysis-section">    OS 和不可信应用进程运行在虚拟机内，访问通过嵌套页表（客户虚拟地址 -> 客户物理地址 -> 主机物理地址），而飞地根据不同的模式通过嵌套页表或 1 级地址转换 <br>    HyperEnclave 的地址隔离原则如下：    <ul>        <li>R-1: OS 和不可信应用不能访问 RustMonitor 和 enclave</li>        <li>R-2: enclave 不能访问 RustMonitor 和其他 enclave</li>        <li>R-3: 外围设备的 DMA 请求地址不能为 RustMonitor 和 enclave，通过 IOMMU 实现</li>    </ul></div><div class="original-text">    <p style="font-weight: bold;">Memory encryption.</p>    To thwart physical memory attacks, such as cold boot and bus snooping attacks, HyperEnclave may leverage hardware memory    encryption (such as AMD SME [44] and Intel MKTME [42]) to encrypt partial physical memory at the page granularity. If    the platform does not support hardware memory encryption, HyperEnclave may consider to apply software approaches [76] to    encrypt the isolated memory. This approach, however, may impose substantial overhead compared with hardware based    solutions.</div><div class="analysis-section">    HyperEnclave 提供硬件和软件的内存加密，防止内存物理攻击</div><h4 id="3-3-Trusted-Boot-Attestation-and-Sealing"><a href="#3-3-Trusted-Boot-Attestation-and-Sealing" class="headerlink" title="3.3 Trusted Boot, Attestation and Sealing"></a>3.3 Trusted Boot, Attestation and Sealing</h4><div class="original-text">    <p style="font-weight: bold;">Measured Late Launch.</p>    The boot process of HyperEnclave is shown in Figure 3. On system boot, a static and immutable piece of code, known as    the Core Root of Trust for Measurement (CRTM), executes first to bootstrap the process of building a measurement chain    for subsequent firmware and software, including the BIOS, grub, the primary OS kernel, and initramfs. The measurements    are stored to TPM PCRs for each boot component, so that any modification will be reflected in the attestation quote.    <img src="/img/HyperEnclave/F3.png" alt="" style="width: 75%;"></div><div class="analysis-section">    系统启动时，首先运行一段固定且无法修改的内核代码 CRTM，这段内核代码会启动一系列测量链，包括 BIOS，grub，初始 OS kernel，initramfs。测量值将写入 TPM 的 PCR 寄存器中，任何修改都将在引用中体现</div><div class="original-text">    To reduce the attack surface from the primary OS, we put the RustMonitor image into the initramfs. The kernel measures    the RustMonitor image and extends the value to TPM PCRs, then it launches RustMonitor in early userspace, i.e., before    any userspace program that relies on the disk file system starts to run. Along with the measured boot, it ensures that    the software state when RustMonitor is loaded is trusted.</div><div class="analysis-section">    initramfs：临时根文件系统，一个压缩的 CPIO 归档文件，在内核启动初期被加载到内存中。在内核完成硬件初始化后，为挂载真正的根文件系统（/）提供必要的工具和驱动。将 RustMonitor 的镜像加载至其中，在 early userspace 阶段启动</div><div class="original-text">    After RustMonitor is loaded, the execution continues at the pre-defined entry. RustMonitor sets up its own running    context (such as the stack, page table, IDT, etc.) and prepares the virtual CPU (vCPU) configurations for each CPU. Then    RustMonitor launches the normal VM and demotes the primary OS to the normal mode. Returning to the kernel module, the    kernel continues to boot in the normal mode and is unaware of the existence of RustMonitor.</div><div class="analysis-section">    RustMonitor 加载后，初始化上下文 -> 准备 vCPU -> 加载 normal VM -> 将 OS 降级为 normal mode 并使其运行在 normal VM 中 -> 回到内核模块继续启动，此时内核无法意识到 RustMonitor 的存在</div><div class="original-text">    HyperEnclave applies the above approach (referred to as measured late launch) so that RustMonitor is loaded as a type2    hypervisor (like KVM) while runs as a type-1 hypervisor (like Xen). In this way, RustMonitor does not need to trust the    primary OS anymore after the primary OS is demoted to the normal mode.</div><div class="analysis-section">    RustMonitor 加载时是 Type-2 虚拟机，运行时是 Type-1 虚拟机 <br>    Type-1 虚拟机：运行在裸机上，无需操作系统 <br>    Type-2 虚拟机：运行在操作系统上</div><div class="original-text">    <p style="font-weight: bold;">Remote Attestation.</p>    With the measured late launch, all booted components are measured and extended to the TPM. After RustMonitor is booted,    it needs to extend the trust to the enclaves. For this purpose, RustMonitor derives an attestation key pair which is    used to sign the enclave measurement. Then RustMonitor extends the derived public key to the TPM PCR, and the private key never leaves RustMonitor which is protected by memory isolation and encryption.</div><div class="analysis-section">    RustMonitor 需要将信任扩展到飞地（用户信任飞地），RustMonitor 内部生成一个密钥，用私钥（永远不离开 RustMonitor）对飞地进行签名</div><div class="original-text">    During enclave creation, all pages added to the enclave (including the corresponding page content, page type, and RWX    permissions) are measured by RustMonitor to generate the enclave measurement. The (intermediate) measurement is stored    in RustMonitor’s memory, which is invisible to the enclaves and the primary OS.</div><div class="analysis-section">    飞地创建时，RustMonitor 会对其所有页面（页面内容、类型、RWX 权限）进行测量，存储在 OS 和飞地不可见的内存中</div><div class="original-text">    Similar to TPM and Intel SGX, HyperEnclave adopts a SIGn-and-MAc (SIGMA) attestation protocol for the remote attestation    flow. As shown in Figure 4, we denote the public key of RustMonitor’s attestation key by the hypervisor attestation    public key (hapk). The enclave measurement is signed using RustMonitor’s attestation key to form the enclave measurement    signature (ems). The TPM quote TMP_Quote, which is signed using the TPM attestation key, includes the PCRs for the    measurement of all booted code, and the measurement of hapk. Upon receiving the attestation report, the remote user can    verify the report by comparing the measurement of booted code (including the CRTM, BIOS, grub, kernel, initramfs, and    hypervisor) and the enclave, as well as verifying the certificate chain for generating the signature.</div><div class="analysis-section">    HyperEnclave 遵循 SIGMA 远程验证协议 <br>    <table style="margin-top: 20px;">        <thead>            <tr>                <th>术语</th>                <th>作用</th>                <th>安全属性</th>            </tr>        </thead>        <tbody>            <tr>                <td>SIGMA 协议</td>                <td>双向认证协议，确保通信双方身份和数据的完整性</td>                <td>防止中间人攻击、数据篡改</td>            </tr>            <tr>                <td>hapk</td>                <td>RustMonitor 的认证公钥，用于签名飞地度量值</td>                <td>私钥受内存隔离和加密保护</td>            </tr>            <tr>                <td>ems</td>                <td>飞地度量值的签名（由 hapk 对应的私钥生成）</td>                <td>证明飞地未被篡改</td>            </tr>            <tr>                <td>TPM_Quote</td>                <td>TPM 签名的报告，包含 PCR 值和 hapk 的度量值</td>                <td>硬件级防伪，证明启动链可信</td>            </tr>            <tr>                <td>PCR（Platform Configuration Register）</td>                <td>TPM 中的寄存器，存储启动过程各阶段的累积哈希值</td>                <td>任何组件篡改将导致 PCR 值变化</td>            </tr>        </tbody>    </table></div><div class="original-text">    <p style="font-weight: bold;">Secret key generation.</p>    When RustMonitor is initialized for the first time, it generates a root key Kroot from the random number generator (RNG)    module of the TPM. Kroot is stored outside the TPM using TPM’s seal operation. During the booting process on system    reset, RustMonitor decrypts Kroot using TPM’s unseal operation, which guarantees that Kroot can only be unsealed with    the exactly same TPM chip with matching PCR configurations. Furthermore, RustMonitor floods the PCRs with a constant    before transferring control to the primary OS to prevent it from retrieving Kroot . All other key materials, including    the enclave’s sealing key and report key are derived from both Kroot and the enclave’s measurement.</div><div class="analysis-section">    TODO</div><h4 id="3-4-The-Enclave-SDK"><a href="#3-4-The-Enclave-SDK" class="headerlink" title="3.4 The Enclave SDK"></a>3.4 The Enclave SDK</h4><div class="original-text">    Porting existing applications to the enclaves can be cumbersome since TEEs usually expose limited hardware and software    interfaces and provide additional security services (e.g., attestation and sealing). For process-based TEEs, the    applications need to be partitioned into the trusted and untrusted parts, and the interfaces need to be carefully    designed to avoid various security pitfalls [27, 46, 69]. A lot of effort has been spent and many tools have been    developed for Intel SGX, due to its dominant position in the market, including library OSes [64, 67], containers [18],    automatic partition and protection tools [50, 68], WebAssembly Micro Runtime [57], and interface protection [65].    Consequently, Intel SGX has supported securely running applications written in C/C++, Rust, Java, Python, etc., without    expensive code refactoring.</div><div class="analysis-section">    进程抽象的 TEE 需要将应用分成可信和不可信部分，将现有应用程序移植到飞地可能很麻烦，但是 SGX 相关工具很充分</div><div class="original-text">    We provide the enclave SDK with APIs compatible with the official Intel SGX SDK to ease the development of applications    on HyperEnclave. The enclave SDK is retrofitting the official SGX SDK. By replacing the SGX user leaf functions (e.g., EENTER, EEXIT, and ERESUME) with hypercalls, SGX programs can run on HyperEnclave with little or no source code changes. Once the enclave executes these user leaf functions, it traps to RustMonitor and RustMonitor emulates the functionalities of the corresponding SGX instructions.</div><div class="analysis-section">    论文为飞地设计了和 SGX SDK 兼容的 API，当应用调用 HyperCall 时，RustMonitor 将其捕获并模拟对应的 SGX 指令</div><div class="original-text">    The enclave is compiled as a trusted library of the application, while the application itself runs in the primary OS.    The enclave life cycle is managed through the emulation of a set of privileged SGX instructions (i.e., ECREATE, EADD,    EINIT, etc.). To this end, the kernel module running in the primary OS provides similar functionalities by invoking    RustMonitor through hypercalls, and exposes the functionalities to the applications by the ioctl() interfaces. By    emulating the privileged SGX instructions, RustMonitor is responsible for the management of the enclave’s life cycle    (Sec. 4).</div><div class="analysis-section">    SGX 中，飞地的生命周期通过一组特权指令管理，RustMonitor 通过模拟特权 SGX 指令完成飞地生命周期的管理任务 </div><div class="original-text">    To be compatible with the official Intel SGX SDK, most data structures involved in HyperEnclave (such as the SIGSTRUCT    structure, the SECS page, and the TCS page) are similar to that of SGX. With the HyperEnclave design, it is    straightforward to support dynamic enclave management in an enclave, since the enclave memory and page fault are all    managed by RustMonitor. Multi-threading within the enclave is supported by associating one TCS page for each enclave    thread within the enclave. Exception handling within the enclave is supported by setting more than 1 SSA page for each    TCS. The details are omitted due to space constraints and we refer the readers to the SGX manual [11] for more details.</div><div class="analysis-section">    为了兼容 SGX，沿用其很多机制和数据结构：    <ul>        <li>SIGSTRUCT：enclave 的数字身份证</li>        <li>SECS：enclave 的元数据</li>        <li>TCS：enclave 的线程控制结构</li>        <li>SSA：enclave 异常时用于保存现场</li>    </ul></div><h3 id="4-Flexible-Enclave-Operation-Mode"><a href="#4-Flexible-Enclave-Operation-Mode" class="headerlink" title="4 Flexible Enclave Operation Mode"></a>4 Flexible Enclave Operation Mode</h3><div class="original-text">    A wide range of existing applications can be offloaded to the TEEs, such as computing-intensive tasks (machine learning    [60]), input and output (IO)-intensive tasks (such as the Apache and Nginx web server [18]), memory-intensive tasks    (Redis and Memcached [18]), and tasks which favor in-enclave exception handling and privilege separation [21]. Most TEEs    support running the enclaves only in fixed mode, Intel SGX (also TrustVisor [54] and Secage [51]) enclaves in    particular, as part of the application address space, run in user mode. As a result, the user mode enclave is not    allowed to access the privileged resources (such as the IDT and page tables) and process the privileged events    (interrupt and exceptions). It must switch to the untrusted code to gain access to privileged resources and handle the    events. The I/O-intensive and memory-intensive tasks essentially involve the frequent world switches which are expensive    and introduce non-negligible performance losses, even though both software and hardware optimizations have been proposed    trying to reduce the context switch latencies [61, 66, 73]. In this section, we introduce the three enclave operation    modes supported by HyperEnclave, as shown in Figure 5. The world switches in different enclave operation modes are shown    in Figure 6.    <br>    <img src="/img/HyperEnclave/F5.png" alt="" style="width: 45%; display: flexbox; margin-right: 70px;">    <img src="/img/HyperEnclave/F6.png" alt="" style="width: 45%; display: flexbox;"></div><div class="analysis-section">    TEE 中执行的应用进程任务种类繁多，计算密集型任务、IO 密集型任务、内存密集型任务等 <br>    现有飞地只支持固定模式运行，例如 SGX 运行在用户模式，对于 IO 密集型任务，需要进行世界切换（切换至不可信部分）才能访问特权资源，带来巨大的性能消耗。</div><h4 id="4-1-Guest-User-Enclaves"><a href="#4-1-Guest-User-Enclaves" class="headerlink" title="4.1 Guest User Enclaves"></a>4.1 Guest User Enclaves</h4><div class="original-text">    Guest user enclave (GU-Enclave) is the basic enclave operation mode which is typically running computing-intensive    tasks. The enclave runs in the guest user mode (i.e., guest ring-3 of the VMX non-root operation mode). During the    enclave creation, RustMonitor prepares a vCPU structure which contains a guest page table (GPT) and a nested page table    (NPT) for GU-Enclave. On entry and exit between the normal VM and the enclave VM, RustMonitor switches the vCPU states    (e.g. the instruction pointer, thread pointer, NPT, and GPT) accordingly. To handle the interrupts and exceptions during    the enclave running, RustMonitor configures the vCPU to trap all interrupts and exceptions to the monitor mode.    RustMonitor then saves the enclave’s context, forwards the interrupt or exception to the normal VM. After the primary OS    completes handling the interrupt or exception, the application invokes the ERESUME hypercall, which traps to RustMonitor    to restore the enclave’s context and resume the execution of the enclave.</div><div class="analysis-section">    GU-Enclave 是最基本的飞地运行模式，用于运行计算密集型任务。飞地在 VMX-non-root-r3 模式下运行 <br>    在飞地创建时，RustMonitor 准备一个 vCPU 结构，包含飞地对应的 GPT 和 NPT。在 normal VM 和 enclave VM 的切换中，RustMonitor 负责切换相应的 vCPU 状态 <br>    当飞地发生中断或异常时，vCPU 捕获并交付给 RustMonitor 进行处理，保存飞地上下文后转交给 OS 处理，处理完毕后再由 RustMonitor 恢复飞地上下文并继续执行</div><h4 id="4-2-Host-User-Enclaves"><a href="#4-2-Host-User-Enclaves" class="headerlink" title="4.2 Host User Enclaves"></a>4.2 Host User Enclaves</h4><div class="original-text">    Host user enclave (HU-Enclave) is running in host user mode. It delivers the optimal world switch efficiency by    substituting the mode switch (hypercalls: ∼ 880 CPU cycles on our platform) with the ring switch (syscalls: ∼ 120 CPU    cycles on our platform) (Figure 6). It further eliminates the extra virtualization overhead (e.g. vCPU context switching and    two-dimensional page walking) in GU-Enclave. HU-Enclave may benefit the I/O-intensive workload according to our    evaluation in Sec 7. By comparison, running enclaves in the guest user mode provides more defensive depth.    When loading the HU-Enclave, RustMonitor prepares a process context, e.g. creates a level-1 page table. On enclave    entry, RustMonitor updates the CPU state and invokes the system call return instruction (i.e., SYSRET on x86 platforms)    to enter the HU-Enclave. Correspondingly, on enclave exit, HU-enclave invokes the system call instruction (i.e., SYSCALL    on x86 platforms) and traps into RustMonitor. The ENCLU leaf instructions (e.g., EGETKEY, EREPORT) are emulated as a    system call. Interrupts and exceptions within the HUEnclaves also trap into the RustMonitor. The procedures are similar    to those for the GU-Enclaves described in Sec. 4.1.</div><div class="analysis-section">    HU-Enclave 用于运行 IO 密集型任务。飞地在 VMX-root-r3 模式下运行 <br>    在飞地创建时，RustMonitor 为飞地准备一级页表，通过系统调用进入和退出飞地，相较于 GU-Enclave 有更好模式切换性能，但是更浅的防御深度</div><h4 id="4-3-Privileged-Enclaves"><a href="#4-3-Privileged-Enclaves" class="headerlink" title="4.3 Privileged Enclaves"></a>4.3 Privileged Enclaves</h4><div class="original-text">    Inspired by the VM-based TEEs, such as AMD SEV [45], HyperEnclave supports privilege enclaves (P-Enclaves) which run in    guest privileged mode. P-Enclave is permitted to access the GDT, IDT, and level-1 page table which benefits a wide    variety of applications, as demonstrated by Dune [21]. One such example is the garbage collector, an essential feature    for Java applications (existing works port the JVM to enclaves [26, 43]). The garbage collector frequently changes page    permissions to trigger page faults in order to track the page status. For user mode enclaves (e.g., GU-Enclaves and    HU-Enclaves), it has to involve the primary OS to update the page table and handle the page fault which suffers huge    performance loss due to world switches. P-Enclaves eliminate the world switch by supporting in-enclave exception    handling and level-1 page table management. More specifically, P-Enclaves configures its own exception handler to handle    certain exceptions (such as page fault). RustMonitor passes through the white-list exceptions to the P-Enclave and forwards others to the primary OS. Furthermore, P-Enclaves can also support page-table-based in-enclave isolation schemes, e.g., sandboxing untrusted third-party libraries.    With the ability to receive interrupts within the enclaves, PEnclaves may also detect abnormal interrupt events by    counting the frequency, before requesting RustMonitor to route them to the primary OS. As such, existing interrupt-based    side channel attacks [24, 37, 40, 58, 59, 70] could be detected and mitigated. We leave further exploration in this    direction to future work due to space constraints.</div><div class="analysis-section">    P-Enclave 运行在 VMX-non-root-r0 模式下，用于例如垃圾收集器的特殊任务 <br>    P-Enclave 可以自己管理页表和白名单内的异常，同时可以通过内部计数来减轻基于不正常中断的测信道攻击</div><h3 id="5-Implementations"><a href="#5-Implementations" class="headerlink" title="5 Implementations"></a>5 Implementations</h3><div class="original-text">    We report our implementation of HyperEnclave on an AMD platform that supports hardware virtualization technology and    memory encryption. In the current implementation, RustMonitor consists of about 7,500 lines of code written mostly in    Rust, and the kernel module for the primary OS has about 3,500 lines of C code. Also, we made about 2,000 lines of code    changes to the official Intel SGX SDK (version 2.13).</div><div class="analysis-section">    RustMonitor 由 7500 行 Rust 代码组成，OS 内核由 3500 行 C 代码组成，同时修改了约 2000 行 SGX 代码</div><h4 id="5-1-RustMonitor"><a href="#5-1-RustMonitor" class="headerlink" title="5.1 RustMonitor"></a>5.1 RustMonitor</h4><div class="original-text">    RustMonitor runs at the highest privilege level and enforces the isolation for the enclaves. To reduce the risks caused    by memory corruption or concurrency bugs, we implemented RustMonitor mostly in Rust, a memory-safe language, with only a    few lines of assembly code used for context switches. Compared with existing hypervisors such as KVM [47] and Xen [29],    RustMonitor is much smaller and thus easier to be formally verified. We are working on the formal verification of    RustMonitor and plan to release the result as a separate report. When the platform is booted, we configure the kernel    command line parameters in the grub to reserve regions of physical memory, which are exclusively used by RustMonitor and    the enclaves. RustMonitor manages the reserved physical memory by maintaining a list of free pages. When an enclave page    is needed, e.g., when adding an enclave page during enclave creation, a free page is retrieved from the pool; when the    enclave page is freed, the page is attached to the list again. Moreover, RustMonitor also manages the enclave’s page    tables and processes the page fault.</div><div class="analysis-section">    RustMonitor 运行在最高特权级，代码量小方便验证 <br>    RustMonitor 通过维护空闲页面列表来管理保留的物理内存，需要飞地页面时从内存池分配一个空闲页面，释放飞地页面时将其重新添加到空闲页面列表。RustMonitor 同时还管理安全区页表并处理页错误</div><h4 id="5-2-The-Kernel-Module"><a href="#5-2-The-Kernel-Module" class="headerlink" title="5.2 The Kernel Module"></a>5.2 The Kernel Module</h4><div class="original-text">    The kernel module is loaded by the primary OS during the booting process. Then it loads, measures, and launches    RustMonitor, with the measurement extended to the TPM PCR as part of the TPM quote. When the kernel module is loaded, a    device file is created and mounted at /dev/hyper_enclave. The application can open it and issue the ioctl() to invoke    the emulated privileged operations.</div><div class="analysis-section">    内核模块在启动过程中由 OS 加载，它负责加载、测量、启动 RustMonitor，将测量值扩展到 TPM PCRs 并体现在 TPM 引用中 <br>    加载内核模块时，将创建一个设备文件并将其装载到 /dev/hyper_enclave 中，应用程序可以打开它并发出 ioctl() 来调用模拟的特权操作</div><h4 id="5-3-The-Enclave-SDK"><a href="#5-3-The-Enclave-SDK" class="headerlink" title="5.3 The Enclave SDK"></a>5.3 The Enclave SDK</h4><div class="original-text">    HyperEnclave retrofits the official SGX SDK as follows.    <p style="font-weight: bold;">Supporting the SGX SDK APIs.</p>    We replace the SGX user leaf functions (e.g. EENTER, EEXIT, ERESUME, etc.) in the SGX SDK with hypercalls or system    calls. Our implementation retains the same parameter semantics and orders as SGX for compatibility purposes.    <p style="font-weight: bold;">Parameters passing with the marshalling buffer.</p>    In HyperEnclave, the enclave can only access its own address space and the marshalling buffer shared with the    application. The size of the marshalling buffer can be configured in the enclave’s configuration file, with a default    size. The data needs to be transmitted to the marshalling buffer before invoking edge calls. We modified SGX SDK to    handle the transitions, which are thus transparent to the developer.</div><div class="analysis-section">    TODO</div><div class="original-text">    We modified the untrusted runtime library in the SDK (i.e., libsgx_urts.so), such that during enclave initialization a    marshalling buffer is allocated using mmap() with MAP_POPULATE flags set. As a result, the GPAs for the marshalling    buffers are pre-populated. Then an ioctl() is issued to request the primary OS not to compact or swap out the physical    pages of the marshalling buffers during the enclave’s lifetime. When the application invokes the emulated EINIT    instruction to mark the initialization of the enclave, the base address and the size of the marshalling buffer are    passed to RustMonitor, who will add the mapping of the marshalling buffer in the enclave’s page table. In this way, the    marshalling buffer is now shared between the enclave and the untrusted application. The base address and the size of the    marshalling buffer are also passed to the trusted runtime library to transmit data from the marshalling buffer to the    enclave.</div><div class="analysis-section">    TODO</div><div class="original-text">    The current OCALL’s implementation in the SGX SDK invokes the sgx_ocalloc() within the enclave to allocate a buffer on    the stack area of the untrusted application, which is then used for cross-enclave data transmission. As such, we only    need to modify the sgx_ocalloc() function to allocate a memory area in the marshalling buffer. To support parameter    passing through the marshalling buffer for ECALLs, we modified SGX’s Edger8r tool to automatically generate code that    copies the transmitted data into the marshalling buffer. The SGX programming model supports passing parameters with the    user_check attribute. For such parameters, the SDK tool will not generate code to check the address range or perform    data movement. Since the enclave code could access the entire process’s address space, some enclave programs may use a    pointer with the user_check attribute to manipulate the data buffer outside the enclave directly, without accounting for    the overhead for copying the data across the enclave boundary. To deal with it, we added an interface for the developer    to allocate the buffer within the marshalling buffer, in the cases when the developer may use parameters with the    user_check attribute.</div><div class="analysis-section">    TODO</div><div class="original-text">    The remote attestation flow is similar to SGX, following the same SIGn-and-MAc (SIGMA) protocol. We extended the sgx_quote_t structure in the SDK to include the HyperEnclave    quote, and the modification is transparent to the enclave code. With the above design, most SGX programs could run on    HyperEnclave without source code changes. Furthermore, to ease the development of HyperEnclave applications, we have    also ported the Rust SGX SDK [71] and the Occlum library OS [64] to HyperEnclave.</div><div class="analysis-section">    TODO</div><h3 id="6-Security-Analysis"><a href="#6-Security-Analysis" class="headerlink" title="6 Security Analysis"></a>6 Security Analysis</h3>]]></content>
    
    
    
    <tags>
      
      <tag>GPU TEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个月过去喽</title>
    <link href="/2025/01/31/2025-1/"/>
    <url>/2025/01/31/2025-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/css/Happiness.css"><blockquote><p>我自认为百分之一百不是一个感性的人，更不是一个没事会写小作文记录生活的人。我个人的语文水平也是相当顶级，高考语文 94 分至今没有找到比我更低的。<br>只不过前几天翻阅友链的时候看到我的老登朋友们写了很多生活博客，在感叹它们越来越唐的同时，也打算自己记录一下试试，所以有了这个系列。</p></blockquote><h2 class="month-title">2025 年 1 月</h2><div class="event-card">    <div class="summary-title">恐怖的期末周</div>    <div class="explanation">整天除了复习就是复习，虽然之前加权不低但是顶着个 rk1 的头衔还是蛮有舆论压力的</div></div><div class="event-card">    <div class="summary-title">编译原理实验</div>    <div class="explanation">历经三天三夜大战 lex 和 yacc，终于做完了北科这个抄别人实验还只抄一部分还打各种补丁的狗屎</div></div><div class="event-card">    <div class="summary-title">崔导的新年祝福</div>    <div class="explanation">辅导员给每个同学定制了一个新年祝福明信片，只能说有这样的辅导员真是我上辈子的福气</div></div><div class="event-card">    <div class="summary-title">人缘的力量</div>    <div class="explanation">自从加入 806 + 当各种课的助教，我认识的人越来越多，认识的老油条也越来越多。先是在同学的引荐下担任了计组课设的助教，白嫖 100 分；又从老登那里拿到了各种往年试卷，像北科这种十年不换题目的考试，只能说奋斗一学期不如考前一天背原题</div>    <div class="explanation">时常会感叹，如果当时没加入 806，我现在的水平是什么样子的，大概率是个究极绩点战神吧，感谢实验室的同学教会了大二上转专业对计算机一无所知的我，加权真的体现不了一个人的实力</div>    <div class="explanation">加入 806 是过的游戏组的面试，如果当时没有把游戏开发当成兴趣，甚至如果高考语文带点脑子去比北科更好的学校，我的人生轨迹都会截然不同。不会煽情，但很喜欢看王者比赛听到的话：永远相信一切都是命运最好的安排</div></div><div class="event-card">    <div class="summary-title">我的牢红</div>    <div class="explanation">一诺换 ＜ 本以为这次挑杯撑死拿个四强了，没想到直接剑指冠军了，不枉我从 15:00 看到 22:00（甚至差点被让四追五）。我是冠军粉丝，开逛！</div></div><div class="event-card">    <div class="summary-title">奖助学金到账</div>    <div class="explanation">到账了国奖和一堆小比赛的奖金，大约有个一万三，还有八千左右没发。有钱的感觉真好，花了点买了新电脑、键鼠、手柄、显示屏、耳机，爽了</div></div><div class="event-card">    <div class="summary-title">不想学习</div>    <div class="explanation">期末全考完一点不想学了，虽然在何老师的帮助下混进去个做 GPU 侧 TEE 的组，但是很明显每天睁眼只想刷哔哩哔哩和打游戏......</div></div><div class="event-card">    <div class="summary-title">回老家过年</div>    <div class="explanation">很喜欢今年的年夜饭氛围，没有一大堆不认识的亲戚；没有那种喝醉了装呗的亲戚；没有大肆宣扬封建迷信、酒桌文化的亲戚；没有经典 “我小时候要是有你们现在的条件，包是上清华北大的孩子” “现在孩子都是被游戏害了” 的傻逼，只有比较亲近的亲戚聚在一起吃个饭。不过我还是觉得，对于平时完全不联系的亲戚，“走亲” 不如 “访友”</div></div>]]></content>
    
    
    
    <tags>
      
      <tag>Happiness</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库八股文——规范化理论</title>
    <link href="/2024/12/20/DataBase4/"/>
    <url>/2024/12/20/DataBase4/</url>
    
    <content type="html"><![CDATA[<h1 id="规范化理论"><a href="#规范化理论" class="headerlink" title="规范化理论"></a>规范化理论</h1><link rel="stylesheet" href="/css/DataBase_RelationModel.css"><script type="text/javascript" async  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script><h2 id="规范化理论的目的"><a href="#规范化理论的目的" class="headerlink" title="规范化理论的目的"></a>规范化理论的目的</h2><h3 id="不恰当的关系设计"><a href="#不恰当的关系设计" class="headerlink" title="不恰当的关系设计"></a>不恰当的关系设计</h3><p>有这样一个关系：in_dep (ID, name, salary, dept_name, building, budget)，其中 ID 为主码。</p><img src="/img/044.png" alt="" style="height: 300px;"><p>现在有以下四个问题：</p><ul>    <li>重复性：属性 building 和 budget 出现了大量重复的值</li>    <li>更新：如果我仅仅更新了一个 building 的 budget，理论上所有对应的 budget 都应该被修改</li>    <li>插入：如果我仅仅插入一个新的 building 信息，则对于 instructor 部分只能取 NULL</li>    <li>删除：如果我删除了 instructor 的信息，building 相关信息也会消失</li></ul><p>为什么会出现这些问题？</p><p><span class="sub_title">因为关系中出现了毫无关系的属性，也即 instructor 和 building 没有关联，却出现在了同一张表格中。</span></p><p>如何解决这些问题？</p><p><span class="sub_title">使用规范化理论约束关系的设计。</span></p><img src="/img/045.png" alt=""><h3 id="有损分解"><a href="#有损分解" class="headerlink" title="有损分解"></a>有损分解</h3><p>上述例子通过拆分关系达到了约束效果，但实际上拆分不是随意的，例如下面这个例子：</p><img src="/img/046.png" alt="" style="height: 500px;"><p>我们发现，拆分之后的表格重新组合后会多出一些不该存在的元组。我们称：如果一个分解不能组合成原来的样子(多元组&#x2F;少元组)，则该分解称为<span class="just_red">有损分解</span>。</p><p>规范化的分解要求：</p><ul>    <li>无损连接，分解后的关系可以拼接会原来的关系</li>    <li>依赖保持，通过规定分解后关系的约束，支持在分解前关系上存在的约束</li></ul><h2 id="规范化规则"><a href="#规范化规则" class="headerlink" title="规范化规则"></a>规范化规则</h2><h3 id="函数依赖-Functional-Dependencies"><a href="#函数依赖-Functional-Dependencies" class="headerlink" title="函数依赖 Functional Dependencies"></a>函数依赖 Functional Dependencies</h3><p>函数依赖反映了一个关系中属性或者属性组之间相互依存、相互制约的关系，即两个列或者列组之间的约束。</p><p>函数依赖起到检测冗余是否存在的作用，通过冗余的检测，就能很容易判断出这个关系是不是存在相应的插入，删除，更新异常。基于函数依赖理论，可以将一个关系分解为几个更小的关系，使之满足规范化程度更高的关系表。</p><p>设关系 R(U) 是一个在 U 属性集上定义的关系，X, Y 为 U 的两个子集：</p><p>若对于 R(U) 的任意一个可能的关系 r，r 中不可能存在两个元组在 X 上的属性值相等， 而在 Y 上的属性值不等。</p><p>则称：<span class="just_red">X → Y</span>，X 称为这个函数依赖的决定属性集(Determinant)</p><img src="/img/047.png" alt="" style="height: 300px;"><p>对于上图的关系，要求是属性 学号 → 姓名，也即只要知道了学号，就能推得姓名。上图中的黄色部分违反了这一规则人，因为相同的学号推得了不同的姓名，说明不能称 学号 → 姓名。</p><h4 id="函数依赖和属性的关系"><a href="#函数依赖和属性的关系" class="headerlink" title="函数依赖和属性的关系"></a>函数依赖和属性的关系</h4><p>对于属性集 X 和 Y，他们的基数约束规则决定了他们之间可能的函数依赖。</p><ul>    <li>一对一，则存在函数依赖 X → Y 和 Y → X</li>    <li>一对多，则存在函数依赖 Y → X</li>    <li>多对多，则不存在依赖</li></ul><h4 id="平凡函数依赖-非平凡函数依赖"><a href="#平凡函数依赖-非平凡函数依赖" class="headerlink" title="平凡函数依赖&#x2F;非平凡函数依赖"></a>平凡函数依赖&#x2F;非平凡函数依赖</h4><p>如果 X → Y 并且 Y ⊆ X，则称 X → Y 是平凡的函数依赖，否则则称非平凡的函数依赖。</p><p>很明显，平凡的函数依赖是一句废话，所以我们一般研究的都是非平凡的函数依赖。</p><h4 id="完全函数依赖-部分函数依赖"><a href="#完全函数依赖-部分函数依赖" class="headerlink" title="完全函数依赖&#x2F;部分函数依赖"></a>完全函数依赖&#x2F;部分函数依赖</h4><p>如果 X → Y，并且对于 X 的任何一个真子集 X’，都有X’ ⇏ Y，则称 Y 完全函数依赖于 X，记作 <span class="just_red">X →f Y</span>，否则称 Y 部分依赖于 X，记作 <span class="just_red">X →P Y</span>。</p><h4 id="传递函数依赖"><a href="#传递函数依赖" class="headerlink" title="传递函数依赖"></a>传递函数依赖</h4><p>如果 X → Y，Y → Z，且 Y 不包含于 X，Y ⇏ X，则称Z传递函数依赖于 X，记作 <span class="just_red">X →T Z</span><br>如果 Y → X， 即 X ←→ Y (X Y 相互依赖)，则 Z 直接依赖于 X </p><h4 id="连接依赖"><a href="#连接依赖" class="headerlink" title="连接依赖"></a>连接依赖</h4><p>关系 R 的每个合法实例 r，都具有一个无损联结分解。也即任何的关系实例，都存在一组属性集上覆盖，使得其求投影后自然连接完全等价于原关系实例。</p><h3 id="规范化设计与范式"><a href="#规范化设计与范式" class="headerlink" title="规范化设计与范式"></a>规范化设计与范式</h3><p>在关系模式中存在函数依赖时就有可能存在数据冗余，进而可能导致数据操作异常。因此，关系表的规范化设计就是要尽可能地减少关系表中列或者列组之间的依赖关系，进而得到简洁独立的关系表。</p><p>关系表的规范程度状态为<span class="just_red">范式(nommalomm,NF)</span>，范式可以用于确保数据库模式中没有各种类型的异常和不一致，不同的规范化范式要求可以设计出几余程度不同的数据库。</p><p><span class="just_red">规范化</span>，就是指一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式集合。</p><img src="/img/048.png" alt=""><h4 id="第一范式-——-属性是不可再分的原子"><a href="#第一范式-——-属性是不可再分的原子" class="headerlink" title="第一范式 —— 属性是不可再分的原子"></a>第一范式 —— 属性是不可再分的原子</h4><p>第一范式(1NF)是指关系 R 的每一属性都是不可再分的基本数据项，同一属性中不能有多个值，即关系表中的某个属性不能有多个值或者不能有重复的属性。</p><p>在关系数据库中，满足最低要求的范式是第一范式，不满足第一范式的不是关系数据库。如果出现重复的属性，则根据第一范式，需要将该属性进行细分。</p><p>将不属于第一范式的关系规范化的方法：</p><ul>    <li>在含有重复数据的那些行的空白列上输入合适的数据，也就是在需要填充的位置复制非重复的数据（对表的平板化处理）</li>    <li>将重复数据单独移动到一个新的关系中，同时也将原来关系中的关键属性（组）复制到这个新的关系中。如果有多个重复组或者重复组里又有重复组，反复使用这种方法，直到不再有重复组为止</li></ul><h4 id="第二范式-——-非主属性完全函数依赖于候选码"><a href="#第二范式-——-非主属性完全函数依赖于候选码" class="headerlink" title="第二范式 —— 非主属性完全函数依赖于候选码"></a>第二范式 —— 非主属性完全函数依赖于候选码</h4><p>每一行数据仅可以被候选码唯一区分</p><img src="/img/050.png" alt=""><p>左侧关系中，候选码为 (Sno, Cno)，有 (Sno, Cno) → Sdept, Sno → Sdept<br>不难发现 Sdept 部分依赖于候选码，该关系不属于第二范式</p><h4 id="第三范式-——-不存在传递依赖"><a href="#第三范式-——-不存在传递依赖" class="headerlink" title="第三范式 —— 不存在传递依赖"></a>第三范式 —— 不存在传递依赖</h4><p>在 2NF 基础上，消除依赖传递，任何非主属性不依赖与其他非主属性。即每个属性都和候选码有直接关系，不存在非主属性间的相互依赖。</p><p>在一个表中，如果一个非主属性依赖于另一个非主属性，那么当更新其中一个属性时，另一个属性可能会出现错误。<br>这可能会导致查询结果出现错误，也可能会使得对数据库的修改出现问题。我们需要保证只有更新候选码的时候才需要大规模的改动其他非主属性。</p><img src="/img/051.png" alt=""><p>例如上图左侧的关系，存在函数依赖 Sno → Sdept, Sdept → Sloc, 故存在传递依赖 Sdept → Sloc，该关系不属于 3NF，但是并没有部分依赖于候选码的情况，故属于 2NF。</p><h4 id="巴斯-科德范式-BCNF-——-依赖关系式左侧必定包含候选码"><a href="#巴斯-科德范式-BCNF-——-依赖关系式左侧必定包含候选码" class="headerlink" title="巴斯-科德范式 BCNF —— 依赖关系式左侧必定包含候选码"></a>巴斯-科德范式 BCNF —— 依赖关系式左侧必定包含候选码</h4><p>对于一个关系的函数依赖集合，BCNF 要求所有左侧的属性集都包含任意一个候选码。</p><img src="/img/052.png" alt=""><p>例如上图左侧的关系，假设每位教师只教一门课程，每门课程可以有若干教师讲授，那么每位学生选修某门课程就对应一位教师。存在函数依赖 Tno → Cno, (Sno, Cno) → Tno, (Sno, Tno) → Cno，候选码是 (Sno, Cno), (Sno, Tno)，不存在非平凡的函数依赖，满足 3NF，但是 Tno 不包含任何一个候选码，不属于 BCNF。</p><ul>    <li>满足 BCNF，一定满足 3NF</li>    <li>满足 3NF 并且只有一个候选码，一定满足 BCNF</li></ul><ul>    <li>所有非主属性都完全函数依赖于每个候选键</li>    <li>所有主属性都完全函数依赖于每个不包含它的候选键</li>    <li>没有任何属性完全函数依赖于非候选键的任何一组属性</li></ul><h2 id="数据依赖的公理系统-Armstrong-System"><a href="#数据依赖的公理系统-Armstrong-System" class="headerlink" title="数据依赖的公理系统 Armstrong System"></a>数据依赖的公理系统 Armstrong System</h2><h3 id="逻辑蕴含定理"><a href="#逻辑蕴含定理" class="headerlink" title="逻辑蕴含定理"></a>逻辑蕴含定理</h3><ul>    <li>如果 Y 包含于 X，则 X → Y</li>    <li>如果 X → Y，则 XZ → YZ</li>    <li>如果 X → Y 并且 Y → X，则 X → Z</li>    <li>如果 X → Y 并且 X → Z，则 X → Z</li>    <li>如果 X → Y 并且 Z 属于 Y，则 X → Z</li>    <li>如果 X → Y 并且 YW → Z，则 XW → Z</li></ul><p>例如依赖集合 {𝑈1 → 𝑈2𝑈3, 𝑈3𝑈4 → 𝑈5𝑈6}，判断 𝑈1𝑈4 → 𝑈6是否正确<br>① 𝑈1 → 𝑈2𝑈3 &#x3D;&gt; 𝑈1 → 𝑈3<br>② 𝑈1 → 𝑈3, 𝑈3𝑈4 → 𝑈5𝑈6 &#x3D;&gt; 𝑈1𝑈4 → 𝑈5𝑈6<br>③ 𝑈1𝑈4 → 𝑈5𝑈6 &#x3D;&gt; 𝑈1𝑈4 → 𝑈6</p><h3 id="属性依赖闭包"><a href="#属性依赖闭包" class="headerlink" title="属性依赖闭包"></a>属性依赖闭包</h3><p>U &#x3D; {A<sub>1</sub>, A<sub>2</sub>, ⋯, A<sub>n</sub>} 是关系模式 R 中所有属性的集合，F 是 U 上的一组函数依赖(即 R 的函数依赖集)，X ⊆ U，Y ⊆ U,<br>X<sub>F</sub><sup>+</sup> &#x3D; {A<sub>i</sub> | X → A<sub>i</sub>}，称为该属性的依赖闭包。</p><img src="/img/053.png" alt=""><img src="/img/054.png" alt=""><p>① 加入 A<sub>1</sub>, A<sub>5</sub><br>② 找到左侧是 A<sub>1</sub>, A<sub>5</sub> 的子集的函数依赖<br>③ 加入 A<sub>3</sub>, A<sub>4</sub><br>④ 找到左侧是 A<sub>1</sub>, A<sub>3</sub>, A<sub>4</sub>, A<sub>5</sub> 的子集的函数依赖<br>⑤ 加入 A<sub>6</sub><br>⑥ 找到左侧是 A<sub>1</sub>, A<sub>3</sub>, A<sub>4</sub>, A<sub>5</sub>, A<sub>6</sub> 的子集的函数依赖<br>⑦ 没有变化，退出循环。结果为 {A<sub>1</sub>, A<sub>3</sub>, A<sub>4</sub>, A<sub>5</sub>, A<sub>6</sub>}</p><h3 id="函数依赖闭包"><a href="#函数依赖闭包" class="headerlink" title="函数依赖闭包"></a>函数依赖闭包</h3><p>在检验范式时，仅考虑给定的函数依赖集是不充分的，还需要考虑在给定的模式上成立的所有函数依赖关系。函数依赖集合 F，称 F<sup>+</sup> 为 F 所能推得的全部函数依赖的集合，一般 F<sup>+</sup> 中会有大量的重复函数依赖规则。</p><p>F &#x3D; {A → B, B → C}, 求 F<sup>+</sup></p><p>① 构造二维表</p><img src="/img/055.png" alt="" style="height: 300px;"><p>② 计算所有属性组合的属性集闭包，将表格中包括在对应属性闭包里的属性都勾选出来</p><img src="/img/056.png" alt="" style="height: 300px;"><p>表格中任何一个 √ 都是一个函数依赖。</p><h3 id="求解关系的候选键"><a href="#求解关系的候选键" class="headerlink" title="求解关系的候选键"></a>求解关系的候选键</h3><ul>    <li><strong>L 类属性：</strong>只在 F 中某个函数依赖的左部出现。</li>    <li><strong>R 类属性：</strong>只在 F 中某个函数依赖的右部出现。</li>    <li><strong>LR 类属性：</strong>在 F 中某个函数依赖的左部和右部均出现。</li>    <li><strong>N 类属性：</strong>在 F 中每个函数依赖左部和右部均不出现。</li></ul><p>求解候选键的核心思路：</p><ul>    <li>求解 L 和 N 类属性</li>    <li>若 (L, N)<sup>+</sup> = U，则 (L, N) 为唯一候选键</li>    <li>若 (L, N)<sup>+</sup> ≠ U，则找 LR 类</li>    <li>若 (L, N, LR)<sup>+</sup> = U，则 (L, N, LR) 为候选键</li></ul><img src="/img/057.png" alt=""><p>① L &#x3D; {A<sub>1</sub>}, N &#x3D; {}, LR &#x3D; {A<sub>2</sub>, A<sub>3</sub>, A<sub>4</sub>}<br>② 令 X &#x3D; L, Y &#x3D; LR<br>③ 计算 X 的闭包: X<sub>F</sub><sup>+</sup> &#x3D; {A<sub>1</sub>} ≠ U<br>④ 遍历 Y 中的单一属性，并与 X 构成属性组，后计算闭包</p><ul>    <li>XA<sub>2</sub><sup>F</sup> = (A1A2)<sup>F</sup> &rarr; A<sub>1</sub>A<sub>2</sub>A<sub>3</sub>A<sub>4</sub>A<sub>5</sub>A<sub>6</sub>，因此 {A<sub>1</sub>, A<sub>2</sub>} 是候选键</li>    <li>XA<sub>3</sub><sup>F</sup> = (A1A3)<sup>F</sup> &rarr; A<sub>1</sub>A<sub>2</sub>A<sub>3</sub>A<sub>4</sub>A<sub>5</sub>A<sub>6</sub>，因此 {A<sub>1</sub>, A<sub>3</sub>} 是候选键</li>    <li>XA<sub>4</sub><sup>F</sup> = (A1A4)<sup>F</sup> &rarr; A<sub>1</sub>A<sub>2</sub>A<sub>3</sub>A<sub>4</sub>A<sub>5</sub>A<sub>6</sub>，因此 {A<sub>1</sub>, A<sub>4</sub>} 是候选键</li></ul><h2 id="关系模式分解"><a href="#关系模式分解" class="headerlink" title="关系模式分解"></a>关系模式分解</h2><h3 id="最小函数依赖集"><a href="#最小函数依赖集" class="headerlink" title="最小函数依赖集"></a>最小函数依赖集</h3><ul>    <li>函数依赖的右侧只有单个属性</li>    <li>没有多余的函数依赖</li>    <li>函数依赖左侧没有多余的属性</li></ul><p>计算最小函数依赖集</p><ul>    <li>右部属性拆开：A → BC => A → B, A → C</li>    <li>左侧属性拆开：如果其他规则可以推得左侧属性集中的属性，删掉</li>    <li>如果有冗余规则，删掉</li></ul><h3 id="关系模式分解的定义"><a href="#关系模式分解的定义" class="headerlink" title="关系模式分解的定义"></a>关系模式分解的定义</h3><ul>    <li>关系不丢失</li>    <li>模式不冗余</li>    <li>依赖不丢失</li></ul><p>数据等价：分解具有无损连接性(lossless join)，无损连接是指分解后的关系通过自然连接可以恢复分解前的关系，即通过自然连接得到的关系与分解前的关系相比，既不多出信息、又不丢失信息。</p><p>语义等价：分解要保持函数依赖(preserve functional dependency)。因此关系模式等价分解既要保持函数依赖，又要具有无损连接性。</p><p>无损的模式分解要求分解后关系<strong>自然连接</strong>的结果完全等同于原关系</p><h3 id="无损分解"><a href="#无损分解" class="headerlink" title="无损分解"></a>无损分解</h3><ul>    <li>构建二维表格，纵向为关系，横向为属性</li>    <li>一行一行看，分解后关系所在行，将包含的属性置为 1，其余为 0</li>    <li>遍历全部函数依赖，对于依赖 A → B，如果 A 所属列全部为 1，则将 B 所属列全部置为 1</li>    <li>如果最后有任意一行全部为 1，说明是无损分解</li></ul><img src="/img/058.png" alt=""><img src="/img/059.png" alt=""><img src="/img/060.png" alt=""><h3 id="函数依赖保持"><a href="#函数依赖保持" class="headerlink" title="函数依赖保持"></a>函数依赖保持</h3><img src="/img/061.png" alt=""><ul>    <li>若一个分解具有无损连接性，则它能够保证不丢失信息</li>    <li>若一个分解保持了函数依赖，则它可以减轻或者解决各种异常情况</li>    <li>然而，无损分解和保持函数依赖的分解是两个相互独立的标准</li>    <li>具有无损连接性的分解不一定能够保持函数依赖</li>    <li>保持函数依赖的分解也不一定是无损分解</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>DataBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库八股文——E-R模型</title>
    <link href="/2024/12/18/DataBase3/"/>
    <url>/2024/12/18/DataBase3/</url>
    
    <content type="html"><![CDATA[<h1 id="E-R-模型"><a href="#E-R-模型" class="headerlink" title="E-R 模型"></a>E-R 模型</h1><link rel="stylesheet" href="/css/DataBase_RelationModel.css"><h2 id="数据模型概述"><a href="#数据模型概述" class="headerlink" title="数据模型概述"></a>数据模型概述</h2><p>数据库结构的基础是数据模型，它是描述数据(数据结构)、数据之间的联系，<span class="just_red">数据语义</span>即<span class="just_red">数据操作</span>，以及一致性(完整性)约束的概念和工具的集合。</p><img src="/img/040.png" alt="" style="height: 260px; margin-bottom: 20px;"><table>    <tr>        <th>概念数据模型</th>        <th>逻辑数据模型</th>        <th>物理数据模型</th>    </tr>    <tr>        <td>实体(Entity)</td>        <td>实体(Entity)</td>        <td>表(table)</td>    </tr>    <tr>        <td>--</td>        <td>属性(Attribute)</td>        <td>列(Column)</td>    </tr>    <tr>        <td>--</td>        <td>标识符(Primary/Foreign Identifier)</td>        <td>键(Primary/Foreign Key)</td>    </tr>    <tr>        <td>关系</td>        <td>关系(Relation)</td>        <td>参照完整性约束(Reference)</td>    </tr></table><h2 id="E-R-模型的基本元素"><a href="#E-R-模型的基本元素" class="headerlink" title="E-R 模型的基本元素"></a>E-R 模型的基本元素</h2><h3 id="实体-Entity"><a href="#实体-Entity" class="headerlink" title="实体(Entity)"></a>实体(Entity)</h3><p>一个实体(Entity)可以表示对于组织机构的业务非常重要的事物及其相关的信息集合，实体一般用集合名词或名词词组来表示，因此，实体也被称为实体集(Entity Set)。</p><h3 id="实体实例-Entity-Instance"><a href="#实体实例-Entity-Instance" class="headerlink" title="实体实例(Entity Instance)"></a>实体实例(Entity Instance)</h3><p>实体实例是实体的一个具体出现，或者说是实体的一个具体的记录值。</p><div class="just_red">实体对应类，实体示例对应对象。</div><h3 id="属性-Attribute"><a href="#属性-Attribute" class="headerlink" title="属性(Attribute)"></a>属性(Attribute)</h3><p>一个实体的所有实体实例，都具有相同的性质特征。使用属性来描述实体的性质特征，就像类内的属性一样。实体具有哪些属性，是根据用户对信息的需求来决定的。</p><h4 id="实体的标识符"><a href="#实体的标识符" class="headerlink" title="实体的标识符"></a>实体的标识符</h4><p>在描述实体的属性中，存在一组属性(可以是单个属性，也可以是多个属性)，使用这组属性的特征，可以唯一地标识客观世界中的特定实体实例。如果这组属性不可约(减少任何一个属性)，就不能再唯一地标识这个特定实体实例，那么我们说，这组属性是候选的实体的<span class="just_red">标识符(Identifier)</span>。</p><p>一个实体可能有多个候选的实体标识符。选择其中一组作为该实体的<span class="just_red">主实体标识符(Primary Identifier)</span>，其余的候选的实体标识符称为<span class="just_red">辅助的实体标识符(Auxiliary Identifier)</span>。</p><div class="sub_title">在多个候选的实体标识符中选择一个作为主标识符的标准(Bruce1992)</div><ul>    <li>选择在实体实例的生命周期内不会被改变其值的属性作为标识符</li>    <li>选择实体实例中有有效值且不为空(或未知)的属性作为标识符。如果标识符是个复合属性，则    要确保组成标识符的所有属性的属性值都有效</li>    <li>避免使用可以表示分类、位置信息等所谓的智能标识符(或键) </li>    <li>尽量使用单一属性代理标识符替代复合属性标识符</li></ul><h4 id="属性的分类"><a href="#属性的分类" class="headerlink" title="属性的分类"></a>属性的分类</h4><p>E-R 模型中的属性可以不是原子值，原子值指简单属性 + 单值属性。</p><h5 id="简单属性-复合属性-Simple-Attribute-Composite-Attribute"><a href="#简单属性-复合属性-Simple-Attribute-Composite-Attribute" class="headerlink" title="简单属性&#x2F;复合属性 Simple Attribute &#x2F; Composite Attribute"></a>简单属性&#x2F;复合属性 Simple Attribute &#x2F; Composite Attribute</h5><p>简单属性：不能划分为更小部分的属性<br>复合属性：由若干个有意义的详细属性组合成的属性</p><p>例如：<br><span class="sub_title">年龄</span>是一个简单属性，因为其不能再划分为更小的部分<br><span class="sub_title">简历</span>是一个复合属性，因为其可以继续分成姓名、年龄、学历等属性</p><h5 id="单值属性-多值属性-single-valued-multi-valued"><a href="#单值属性-多值属性-single-valued-multi-valued" class="headerlink" title="单值属性&#x2F;多值属性 single-valued &#x2F; multi-valued"></a>单值属性&#x2F;多值属性 single-valued &#x2F; multi-valued</h5><p>单值属性：属性对一个特定实体都只有单独的一个值<br>多值属性：属性对某个特定实体而言，可能对应于一组值</p><p>用 {} 将属性名包起来表示该属性为多值属性</p><p>例如：<br><span class="sub_title">学号</span>是一个单值属性，因为每一个实体实例只能拥有一个学号<br><span class="sub_title">手机号</span>是一个多值属性，因为每一个实体实例可以拥有多个手机号</p><h5 id="必要属性-可选属性-Mandatory-Attribute-Optional-Attribute"><a href="#必要属性-可选属性-Mandatory-Attribute-Optional-Attribute" class="headerlink" title="必要属性&#x2F;可选属性 Mandatory Attribute &#x2F; Optional Attribute"></a>必要属性&#x2F;可选属性 Mandatory Attribute &#x2F; Optional Attribute</h5><p>必要属性：每个实体实例必须存在的属性<br>可选属性：每个实体实例可以为空值的属性</p><p><span class="sub_title">身份证号</span>是一个必要属性，因为身份证号必须填写<br><span class="sub_title">性别</span>是一个可选属性，因为性别可以不填写</p><h5 id="存储属性-派生属性-Stored-Attribute-Derive-Attribute"><a href="#存储属性-派生属性-Stored-Attribute-Derive-Attribute" class="headerlink" title="存储属性&#x2F;派生属性 Stored Attribute &#x2F; Derive Attribute"></a>存储属性&#x2F;派生属性 Stored Attribute &#x2F; Derive Attribute</h5><p>派生属性：值从别的相关属性或实体派生出来<br>存储属性：不属于派生属性</p><p>派生属性可以定期计算并存储，也可以完全不存储，等需要时计算。</p><p><span class="sub_title">出生年份</span>是一个派生属性，因为出生年份可以通过当前日期减去年龄算出<br><span class="sub_title">年龄</span>是一个存储属性，因为它不是派生属性</p><h5 id="复杂属性-Complex-Attribute"><a href="#复杂属性-Complex-Attribute" class="headerlink" title="复杂属性 Complex Attribute"></a>复杂属性 Complex Attribute</h5><p>复杂属性：复合属性和多值属性通过嵌套方式组合构成</p><p>用 () 将复合属性的各个组成部分包起来，用逗号分隔。</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p>联系是客观世界中，事物内部或者事物之间的规则。数据规则表示的是数据间如何关联，行为规则表示当属性为某个特殊值时，应当进行何种操作。E-R模型可以建模数据规则，但不能建模行为规则。</p><h4 id="结构完整性规则-基数约束规则"><a href="#结构完整性规则-基数约束规则" class="headerlink" title="结构完整性规则(基数约束规则)"></a>结构完整性规则(基数约束规则)</h4><h5 id="最大基数约束规则"><a href="#最大基数约束规则" class="headerlink" title="最大基数约束规则"></a>最大基数约束规则</h5><p>一个联系的最大基数是指：实体 B 中的实体实例可以和实体 A 中的实体实例发生关联的最大个数</p><ul>    <li>一对一</li>    <li>一对多/多对一</li>    <li>多对多</li></ul><ul>    <li>一个教师只能指导一个学生，一个学生只能被一个教师所指导</li>    <li>一个教师可以指导多个学生，一个学生只能被一个教师所指导</li>    <li>一个教师可以指导多个学生，一个学生可以被多个教师所指导</li></ul><h5 id="最小基数约束规则"><a href="#最小基数约束规则" class="headerlink" title="最小基数约束规则"></a>最小基数约束规则</h5><p>一个联系的最小基数是指：实体 B 中的实体实例可以和实体 A 中的实体实例发生关联的最小个数。</p><ul>    <li>部分参与</li>    <li>完全参与</li></ul><ul>    <li>一个教师可以指导学生，也可以不指导学生</li>    <li>一个教师至少指导一个学生</li></ul><h4 id="参照完整性约束规则"><a href="#参照完整性约束规则" class="headerlink" title="参照完整性约束规则"></a>参照完整性约束规则</h4><p>参照完整性约束规则确保属性取值的有效性，只能取所参照的实体对应属性中存在的值。</p><p>参照完整性大多是人为规定的，不能在 E-R 模型中表示出来。</p><h4 id="联系实例"><a href="#联系实例" class="headerlink" title="联系实例"></a>联系实例</h4><p>联系和联系实例类似于实体和实体实例</p><ul>    <li>人类是一个实体，陈髋髋是一个实体实例</li>    <li>老师指导学生的指导是一个联系，陈宽宽老师指导陈髋髋学生是一个联系实例</li></ul><h4 id="联系的描述性属性-关联"><a href="#联系的描述性属性-关联" class="headerlink" title="联系的描述性属性(关联)"></a>联系的描述性属性(关联)</h4><p>联系的描述性属性描述联系本身的特征，联系的属性本身不属于任何一个实体，仅仅用来描述联系的特征。</p><p>关联本身没有标识符，关联适合用来建模一次性的联系，而不是多次同类的联系。例如老师和学生之间的指导关系，教师成为学生的导师可以使用关联描述(是导师&#x2F;不是导师)，成为导师后多次指导学生，每次指导过程为同类联系，不能用关联建模。</p><h4 id="联系的度"><a href="#联系的度" class="headerlink" title="联系的度"></a>联系的度</h4><p>联系的度指参与联系的实体的个数，称为 n 元关系。</p><img src="/img/041.png" alt="" style="height: 500px;"><h4 id="关联实体"><a href="#关联实体" class="headerlink" title="关联实体"></a>关联实体</h4><p>联系是一个动词，关联实体是一个动名词。</p><p>教师指导学生做项目是一个三元关系，其中三个实体是教师、学生、项目。<br>将指导行为转变成指导活动，将三元关系转换成三个二元关系。</p><p>本质是将关联提升为一个关联实体，关联实体是由行为动作<span class="just_red">名词化</span>而抽象出来的实体。此时，关联实体具有一个自己的标识符。</p><h4 id="实体参与联系的角色"><a href="#实体参与联系的角色" class="headerlink" title="实体参与联系的角色"></a>实体参与联系的角色</h4><p>当参与一个联系的多个实体名字不同时，角色是隐含的<br>当参与一个联系的多个实体名字相同时，需要为实体集指定参与联系的角色名</p><ul>    <li>递归联系：课程和课程的先修/后修关系</li>    <li>同一组实体之间的多种联系：员工和企业的工作/股份关系</li></ul><h3 id="强实体和弱实体"><a href="#强实体和弱实体" class="headerlink" title="强实体和弱实体"></a>强实体和弱实体</h3><p>弱实体集是指在数据库中不能独立存在的实体集，它的存在依赖于另一个称为“强实体集”的实体集。弱实体集没有主键属性(Primary Key)，而是通过与强实体集的关系以及自身的部分属性(称为部分键)来唯一标识其实体。</p><img src="/img/042.png" alt="" style="width: 100%;"><p>弱实体集特点：</p><ul>    <li>依赖性：弱实体集依赖于强实体集存在。每个弱实体都<span class="just_red">必须与一个强实体关联</span>，才能存在。</li>    <li>部分键：弱实体集使用<span class="just_red">部分键(Partial Key)</span>来区分不同的弱实体。部分键在弱实体集内部是唯一的，但不能单独作为唯一标识符，需要结合强实体集的主键一起使用。</li>    <li>标识关系：弱实体集和强实体集之间存在一种称为<span class="just_red">标识关系(Identifying Relationship)</span>的特殊关系。这种关系帮助弱实体集通过引用强实体集的主键来唯一标识自身的实例。</li></ul><p>E-R 图中，用双矩形框表示弱实体，标识关系用双菱形标识，部分键用虚线下划线表示。</p><img src="/img/043.png" alt="" style="width: 100%;"><p>在关系数据库中，弱实体集通常通过外键约束来实现，确保弱实体集中的实体只能在与强实体集关联时存在。</p><h2 id="E-R-模型和关系模型的转换"><a href="#E-R-模型和关系模型的转换" class="headerlink" title="E-R 模型和关系模型的转换"></a>E-R 模型和关系模型的转换</h2>]]></content>
    
    
    
    <tags>
      
      <tag>DataBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库八股文——关系代数</title>
    <link href="/2024/12/16/DataBase2/"/>
    <url>/2024/12/16/DataBase2/</url>
    
    <content type="html"><![CDATA[<h2 id="简单专门关系代数"><a href="#简单专门关系代数" class="headerlink" title="简单专门关系代数"></a>简单专门关系代数</h2><link rel="stylesheet" href="/css/DataBase_RelationModel.css"><p>关系代数是施加于关系之上的一组集合代数运算，每个运算都以一个或多个关系作为运算对象，并生成另外一个关系作为该关系运算的结果。</p><h3 id="选择运算"><a href="#选择运算" class="headerlink" title="选择运算"></a>选择运算</h3><img src="/img/007.png" alt="" style="height: 50px; border: 3px solid skyblue;"><p>选择运算为一元运算，其中 p 为谓词语句，R 为输入的关系，结果是 R 中所有符合谓词语句 p 的元组构成的新关系。</p><h3 id="投影运算"><a href="#投影运算" class="headerlink" title="投影运算"></a>投影运算</h3><img src="/img/009.png" alt="" style="height: 50px; border: 3px solid skyblue;"><p>投影运算为一元运算，其中 (A<sub>1</sub>, A<sub>2</sub>, …, A<sub>n</sub>) 为输入的属性列表，R 为输入的关系，结果是 R 中所有元组的 A<sub>1</sub>, A<sub>2</sub>, …, A<sub>n</sub> 列构成的新关系。</p><h2 id="复杂专门关系代数"><a href="#复杂专门关系代数" class="headerlink" title="复杂专门关系代数"></a>复杂专门关系代数</h2><h3 id="重命名运算"><a href="#重命名运算" class="headerlink" title="重命名运算"></a>重命名运算</h3><img src="/img/013.png" alt="" style="height: 44px; border: 3px solid skyblue;"><p>重命名运算为一元运算，其中 R 为输入的关系，S 为要修改的关系名，(A<sub>1</sub>, A<sub>2</sub>, …, A<sub>n</sub>) 为依次要修改的属性名。<br>也可以不传入 (A<sub>1</sub>, A<sub>2</sub>, …, A<sub>n</sub>) 参数，表示只需要修改关系名。</p><p>有点巧妙，放这里了<br>查找最高工资的关系代数表达式：</p><img src="/img/014.png" alt="" style="height: 100px;"><p>通过位置标记也可以获取第 i 个属性，使用关键字 $。</p><img src="/img/015.png" alt="" style="height: 45px;"><h3 id="连接运算"><a href="#连接运算" class="headerlink" title="连接运算"></a>连接运算</h3><img src="/img/017.png" alt="" style="height: 50px; border: 3px solid skyblue;"><h4 id="第一种连接"><a href="#第一种连接" class="headerlink" title="第一种连接"></a>第一种连接</h4><img src="/img/018.png" alt="" style="height: 40px; border: 3px solid skyblue;"><p>先求笛卡尔积，再进行选择运算，其中选择运算的谓词语句和连接的谓词语句相同。</p><h4 id="第二种连接"><a href="#第二种连接" class="headerlink" title="第二种连接"></a>第二种连接</h4><img src="/img/019.png" alt="" style="height: 40px; border: 3px solid skyblue;"><p>先求笛卡尔积，再进行选择运算，其中选择运算的谓词语句和连接的谓词语句相同。</p><h4 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h4><img src="/img/020.png" alt="" style="height: 50px; border: 3px solid skyblue;"><p>先求笛卡尔积，再找到 R 和 S 的<span style="color: red;">公共属性</span>，例如为 (A<sub>1</sub>, A<sub>2</sub>, …, A<sub>n</sub>)，通过谓词语句 R.A<sub>1</sub> &#x3D; S.A<sub>1</sub> … R.A<sub>n</sub> &#x3D; S.A<sub>n</sub> 筛选出符合要求的元组。</p><p>对于两个关系 R, S，我们称 R 的悬浮元组为不满足 R.A<sub>1</sub> &#x3D; S.A<sub>1</sub> … R.A<sub>n</sub> &#x3D; S.A<sub>n</sub> 的元组，S 同理。</p><p><span style="color: red;">外连接</span> 可以将悬浮元组保留表中，在其他属性上填写 NULL。<br><span style="color: red;">左外连接</span> 可以将左关系 R 悬浮元组保留表中，在其他属性上填写 NULL。<br><span style="color: red;">右外连接</span> 可以将右关系 S 悬浮元组保留表中，在其他属性上填写 NULL。</p><p>自然连接结果属性出现的顺序为：相同属性 &gt; 只属于第一个关系的属性 &gt; 只属于第二个关系的属性。</p><p>代数运算表示，但是我不想看：</p><img src="/img/021.png" alt="" style="height: 300px;"><h3 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h3><img src="/img/022.png" alt="" style="height: 35px; border: 3px solid skyblue;"><p>E 为关系代数表达式，T 为临时关系变量，通过赋值运算可以分解复杂的关系代数表达式，使查询变得简单。</p><img src="/img/023.png" alt="" style="height: 60px;"><h3 id="除运算"><a href="#除运算" class="headerlink" title="除运算"></a>除运算</h3><img src="/img/024.png" alt="" style="height: 50px; border: 3px solid skyblue;"><p>假设有两个关系 R(X, Y), S(Z) 其中，Y 和 Z 有相容性。</p><p>则 R(X, Y) ÷ S(Z) 为：<br>1 结果的属性集为 X，且是 R 中 X 的一个子集<br>2 保留下来的元组和 S(Z) 求笛卡尔积，得到的结果必须包含于 R(X, Y)<br>3 S 中的属性必须包含于 R 中</p><h3 id="去重运算"><a href="#去重运算" class="headerlink" title="去重运算"></a>去重运算</h3><img src="/img/025.png" alt="" style="height: 45px; border: 3px solid skyblue;"><p>去重运算可以去除关系中的重复元组，并返回去重之后的关系。</p><h3 id="广义投影运算"><a href="#广义投影运算" class="headerlink" title="广义投影运算"></a>广义投影运算</h3><img src="/img/026.png" alt="" style="height: 45px; border: 3px solid skyblue;"><p>允许在投影列表中使用算术运算和字符串函数等来对投影运算进行扩展，写过 miniob 都说好。</p><h3 id="聚集运算"><a href="#聚集运算" class="headerlink" title="聚集运算"></a>聚集运算</h3><img src="/img/027.png" alt="" style="height: 45px; border: 3px solid skyblue;"><p>其中 A<sub>1</sub>, A<sub>2</sub>, …, A<sub>k</sub> 为 R 中的属性列，F 为作用在属性 A 上的聚集函数，例如 count, sum, avg, min, max 等。</p><p>通过书法体 G 还可以完成 SQL 语句中的 GROUP BY 功能。</p><p>通过 distinct 关键字也可以完成去重功能，例如聚集函数 count-distionct。</p><img src="/img/029.png" alt="" style="height: 50px; border: 3px solid skyblue;">   <p>其中 G<sub>1</sub>, G<sub>2</sub>, …, G<sub>n</sub> 为属性集合，要求根据属性集合分组后，同一组的属性集合取值一样，不同组的属性集合取值不一样。也即，各组属性可以通过 G<sub>1</sub>, G<sub>2</sub>, …, G<sub>n</sub> 来唯一区分。</p><p>G<sub>1</sub>, G<sub>2</sub>, …, G<sub>n</sub> 为可选参数，如果不填写该参数，将所有元组视作一个组别。</p><h3 id="排序运算"><a href="#排序运算" class="headerlink" title="排序运算"></a>排序运算</h3><img src="/img/030.png" alt="" style="height: 50px; border: 3px solid skyblue;"><p>其中 A<sub>1</sub>, A<sub>2</sub>, …, A<sub>k</sub> 为 R 中的属性列，按照顺序依次对元组进行排序。</p><h2 id="传统集合运算"><a href="#传统集合运算" class="headerlink" title="传统集合运算"></a>传统集合运算</h2><h3 id="关系的相容性"><a href="#关系的相容性" class="headerlink" title="关系的相容性"></a>关系的相容性</h3><p>关系 R 和 关系 S 相容的充分必要条件是：</p><ol><li>R 和 S 中的属性个数相同</li><li>R 和 S 中属性存在一一对应关系</li><li>R 和 S 中的对应属性的域相同</li></ol><h3 id="并运算"><a href="#并运算" class="headerlink" title="并运算"></a>并运算</h3><img src="/img/010.png" alt="" style="height: 40px; border: 3px solid skyblue;"><p>并运算为二元运算，其中 R, S 为输入的两个<span style="color: red;">相容</span>关系，结果是 R 和 S 的并集。</p><h3 id="交运算"><a href="#交运算" class="headerlink" title="交运算"></a>交运算</h3><img src="/img/015.png" alt="" style="height: 45px; border: 3px solid skyblue;"><p>交运算为二元运算，其中 R, S 为输入的两个<span style="color: red;">相容</span>关系，结果是 R 和 S 的交集。</p><h3 id="差运算"><a href="#差运算" class="headerlink" title="差运算"></a>差运算</h3><img src="/img/011.png" alt="" style="height: 45px; border: 3px solid skyblue;"><p>差运算为二元运算，其中 R, S 为输入的两个<span style="color: red;">相容</span>关系，结果是 R 和 S 的差集。</p><h3 id="笛卡儿积运算"><a href="#笛卡儿积运算" class="headerlink" title="笛卡儿积运算"></a>笛卡儿积运算</h3><img src="/img/012.png" alt="" style="height: 42px; border: 3px solid skyblue;"><p>笛卡儿积运算为二元运算，其中 R, S 为输入的两个关系，结果是 R 和 S 的笛卡尔积。<br>若关系 R 是 m 度关系，有 x 个元组；关系 S 是 n 度关系，有 y 个元组；则笛卡尔积为 m + n 度关系，元组个数为 x × y。</p><p>换句话说，一个关系一定是：其所有属性的域的笛卡儿积的一个子集。</p><h2 id="关系演算语言"><a href="#关系演算语言" class="headerlink" title="关系演算语言"></a>关系演算语言</h2><h3 id="元组关系演算语言"><a href="#元组关系演算语言" class="headerlink" title="元组关系演算语言"></a>元组关系演算语言</h3><img src="/img/031.png" alt="" style="height: 42px; border: 3px solid skyblue;"><p>P 是原子公式，有以下三种形式：</p><img src="/img/032.png" alt="" style="height: 42px; border: 3px solid skyblue;"> <p>其中 t 为元组变量，R 为关系。</p><img src="/img/033.png" alt="" style="height: 42px; border: 3px solid skyblue;"> <p>其中 t, s 为元组变量，x, y 为关系中在元组 t, s 下的属性。</p><img src="/img/034.png" alt="" style="height: 42px; border: 3px solid skyblue;"> <p>其中 c 是属于 x 域中的常量。</p><h3 id="域关系演算语言"><a href="#域关系演算语言" class="headerlink" title="域关系演算语言"></a>域关系演算语言</h3><img src="/img/035.png" alt="" style="height: 42px; border: 3px solid skyblue;"><p>其中 x<sub>1</sub>, x<sub>2</sub>, …, x<sub>k</sub> 是域变量或者域常量。</p><blockquote><p>元组关系演算语言和域关系演算语言不是很好理解，下面附上一道例题</p></blockquote><img src="/img/036.png" alt="" style="height: 400px;"><img src="/img/037.png" alt="" style="height: 250px;"><p>感觉不太好用言语形容为什么做出来的答案是这样（尤其是域关系演算），多做题吧。</p><p>同时，关系代数表达式也有自己的优先级：</p><img src="/img/038.png" alt="" style="width: 100%;">]]></content>
    
    
    
    <tags>
      
      <tag>DataBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库八股文——关系模型的基本概念</title>
    <link href="/2024/12/15/DataBase1/"/>
    <url>/2024/12/15/DataBase1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/css/DataBase_RelationModel.css"><h2 id="关系、关系模式、关系实例的定义"><a href="#关系、关系模式、关系实例的定义" class="headerlink" title="关系、关系模式、关系实例的定义"></a>关系、关系模式、关系实例的定义</h2><p>一个 <span class="important">关系</span> 对应一张 <span class="important">表格</span></p><p>引入关系的目标是更数学化，规范化的描述一张表格</p><p>例如对于下面的表格：</p><img src="/img/001.png" alt="" style="height: 300px;"><p><span class="sub_title">① 关系的属性和属性值</span></p><p>关系中的每一列中的数据都属于某个域中（域是属性的取值范围），并有一个独特的名字称为属性名，关系中具体的值是属性值。ID 是属性名，该列的域为无符号整数域，10101为属性值。</p><p>域是一个集合，集合的个数成为域的基数。</p><p><span class="sub_title">② 关系的元组</span></p><p>关系的每一行称为属于关系的一个元组，关系包含的元组集合是所有域笛卡尔积的子集。元组的每一个值叫做一个分量。(12121, Wu, Finance, 90000) 为一个元组</p><p><span class="sub_title">③ 关系的度&#x2F;目</span></p><p>关系的属性个数称为关系的度/目。上述关系是一个四度关系。</p><p><span class="important">关系模式</span></p><p>关系可用 <span class="important">R(A<sub>1</sub>:D<sub>1</sub>, A<sub>2</sub>:D<sub>2</sub>, ..., A<sub>n</sub>:D<sub>n</sub>)</span> 来表示，这种描述又被称为关系模式。</p><p>其中 R 是关系的名字，A 是属性，D 是属性所对应的域，n 是关系的度或目， 关系中元组的数目称为关系的基数。</p><p>上述表格的描述为：table_name(ID: unsigned int, name: string, dept_name: string, salary: int)</p><p><span class="important">关系实例</span></p><p>关系模式是在关系模式下的一组元组，或者称一个确定的表格。</p><p>上述表格就是在关系模式 table_name(ID: unsigned int, name: string, dept_name: string, salary: int) 下的一个关系实例</p><h2 id="关系的特性"><a href="#关系的特性" class="headerlink" title="关系的特性"></a>关系的特性</h2><ul>    <li> <span class="sub_title">列的同质性：</span> 每一列的属性值属于同一个域</li>    <li> <span class="sub_title">行/列的互换等价性：</span>关系中区分行和列通过元组值与属性名，和顺序无关</li>    <li> <span class="sub_title">元组的不重复性：</span>不能存在两个完全一致的元组</li>    <li> <span class="sub_title">属性不可再分性（关系第一范式）：</span>属性不能再分成子属性，一个元组的各个分量的值只能为一个</li></ul><h2 id="关系的重要概念——码"><a href="#关系的重要概念——码" class="headerlink" title="关系的重要概念——码"></a>关系的重要概念——码</h2><h3 id="超码-Super-Key"><a href="#超码-Super-Key" class="headerlink" title="超码 Super Key"></a>超码 Super Key</h3><p><span class="sub_title">能够唯一标识一条记录的属性或属性集</span></p><p>标识性 + 非空性</p><img src="/img/002.png" alt="" style="height: 300px;"><p>超码：(学号, 课程名)，(学号，课程名，成绩)，(学号，课程名，性别，姓名)</p><h3 id="候选码-Candicate-Key"><a href="#候选码-Candicate-Key" class="headerlink" title="候选码 Candicate Key"></a>候选码 Candicate Key</h3><p><span class="sub_title">能够唯一标识一条记录的最小属性集（不含多余属性）</span></p><p>标识性 + 非空性 + 最小性</p><img src="/img/002.png" alt="" style="height: 300px;"><p>候选码：(学号, 课程名)，(课程名, 姓名)</p><h3 id="主码-Primary-Key"><a href="#主码-Primary-Key" class="headerlink" title="主码 Primary Key"></a>主码 Primary Key</h3><p><span class="sub_title">人为选择的候选码中的一个</span></p><p>标识性 + 非空性 + 最小性 + 唯一性</p><img src="/img/002.png" alt="" style="height: 300px;"><p>主码：(学号, 课程名)</p><h3 id="主属性-非主属性"><a href="#主属性-非主属性" class="headerlink" title="主属性&#x2F;非主属性"></a>主属性&#x2F;非主属性</h3><p><span class="sub_title">出现在候选码中的属性&#x2F;不出现在候选码中的属性</span></p><img src="/img/002.png" alt="" style="height: 300px;"><p>主属性：{学号，课程名，姓名}</p><p>非主属性：{成绩，性别}</p><h3 id="外码-Foreign-Key"><a href="#外码-Foreign-Key" class="headerlink" title="外码 Foreign Key"></a>外码 Foreign Key</h3><p><span class="sub_title">关系 R 中的一个属性组，它不是 R 的候选码，但它与另一个关系 S 的候选码相对应，则成这个属性组 R 的外码</span></p><img src="/img/003.png" alt="" style="height: 350px; margin-bottom: 15px;"><p>两个关系通常是靠外码连接起来的</p><p><span class="sub_title">超码，候选码，主码的关系</span></p><img src="/img/004.png" alt="" style="height: 300px;"><h2 id="关系中的数据约束"><a href="#关系中的数据约束" class="headerlink" title="关系中的数据约束"></a>关系中的数据约束</h2><h3 id="实体完整性约束——主码约束"><a href="#实体完整性约束——主码约束" class="headerlink" title="实体完整性约束——主码约束"></a>实体完整性约束——主码约束</h3><p>一个关系的主码不能取空值、重复值。</p><p>一个复合主码中的每一个属性均不能取空值。</p><p>只有关系才有实体完整性约束，对于查询结果（例如 SQL 语句的输出），不需要满足该约束。</p><h3 id="参照完整性约束——外码约束"><a href="#参照完整性约束——外码约束" class="headerlink" title="参照完整性约束——外码约束"></a>参照完整性约束——外码约束</h3><p>一个关系的外码可以取空值。</p><p>一个关系的外码如果是有效值，则必须包含于其对应另一个关系的主码的实际取值集合。</p><img src="/img/005.png" alt="" style="display: inline-block; height: 300px;"><img src="/img/006.png" alt="" style="display: inline-block; height: 200px;"><h3 id="用户完整性约束"><a href="#用户完整性约束" class="headerlink" title="用户完整性约束"></a>用户完整性约束</h3><p>用户针对具体的应用环境定义的完整性约束条件。</p><p>例如要求年龄在 0 ~ 100 之间，工资在 3000 ~ 6000 之间等。</p><h3 id="其他约束"><a href="#其他约束" class="headerlink" title="其他约束"></a>其他约束</h3><p>自增长约束、默认值约束、检查约束等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>DataBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库八股文——数据库概述</title>
    <link href="/2024/12/14/DataBase0/"/>
    <url>/2024/12/14/DataBase0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/css/DataBase_RelationModel.css"><h1 id="数据库概论"><a href="#数据库概论" class="headerlink" title="数据库概论"></a>数据库概论</h1><h2 id="数据库的功能"><a href="#数据库的功能" class="headerlink" title="数据库的功能"></a>数据库的功能</h2><ol><li>Storage Management: 存储数据</li><li>Query: 构建一条高效的查询路径</li><li>Execution Component: 根据查询所需的执行计划实际执行</li><li>Internal Management and Scheduling: 内部管理和调度</li><li>Management Tools Interfaces: 管理工具接口</li></ol><h2 id="数据库的基本概念"><a href="#数据库的基本概念" class="headerlink" title="数据库的基本概念"></a>数据库的基本概念</h2><h3 id="数据-Data"><a href="#数据-Data" class="headerlink" title="数据 Data"></a>数据 Data</h3><p>数据是指可以记录和存储在计算机介质上的关于对象和事件的事实，数据可以保存在文件系统和数据库中。</p><p>数据分为<span style="color: red;">结构化数据</span>和<span style="color: red;">非结构化数据</span>。</p><p>数据是指可以记录和存储在计算机介质上的关于对象和事件的事实。而信息是人们按照知识的方式处理后得到的数据。数据本身没有任何意义，只有通过某些操作将数据转化为信息才能被人们理解和利用。</p><h3 id="元数据-Metadata"><a href="#元数据-Metadata" class="headerlink" title="元数据 Metadata"></a>元数据 Metadata</h3><p>元数据是“数据的数据”，用于描述数据的特征或性质以及该数据的内容。例如数据的名称、长度、可能的取值；数据的来源、存储位置、使用方式。</p><p>元数据本身与数据独立，只用于描述数据的性质。</p><h3 id="文件系统存储数据的缺陷"><a href="#文件系统存储数据的缺陷" class="headerlink" title="文件系统存储数据的缺陷"></a>文件系统存储数据的缺陷</h3><section class="first_box">    <!-- title -->    <article class="title">Data Issues in Database Systems</article>    <!-- english -->    <article class="content">        <ul class="list">            <li>Data redundancy and inconsistency: Multiple file formats, duplication of information in different files.            </li>            <li>Difficulty in accessing data: Need to write a new program to carry out each new task.</li>            <li>Data isolation — multiple files and formats.</li>            <li>Integrity problems: Integrity constraints (e.g., account balance > 0) become “buried” in program code                rather than being stated explicitly and hard to add new constraints or change existing ones.</li>            <li>Atomicity of updates: Failures may leave database in an inconsistent state with partial updates carried                out. Example: Transfer of funds from one account to another should either complete or not happen at all.            </li>            <li>Concurrent access by multiple users: Concurrent access needed for performance. Uncontrolled concurrent                accesses can lead to inconsistencies. Example: Two people reading a balance (say 100) and updating it by                withdrawing money (say 50 each) at the same time.</li>            <li>Security problems: Hard to provide user access to some, but not all, data.</li>        </ul>    </article>    <!-- divide line -->    <div class="divider"></div>    <!-- chinese -->    <article class="content">        <div class="text">数据库系统中的数据问题</div>        <ul class="list">            <li>数据冗余和不一致：多种文件格式，信息在不同文件中重复。</li>            <li>数据访问困难：需要为每个新任务编写新的程序。</li>            <li>数据隔离 — 多种文件和格式。</li>            <li>完整性问题：完整性约束（例如，账户余额 > 0）被“埋”在程序代码中，而不是明确陈述，且很难添加新的约束或更改现有约束。</li>            <li>更新的原子性：故障可能会导致数据库处于不一致状态，并且部分更新已执行。例如：从一个账户转账到另一个账户应该要么完成，要么完全不发生。</li>            <li>多个用户并发访问：性能需要并发访问，未经控制的并发访问可能导致不一致。例如：两个人同时读取余额（例如100）并分别通过取款（例如每人50）来更新余额。</li>            <li>安全问题：很难为用户提供部分数据的访问权限，而不是全部数据。</li>        </ul>    </article></section><h3 id="数据库-DataBase"><a href="#数据库-DataBase" class="headerlink" title="数据库 DataBase"></a>数据库 DataBase</h3><p>数据库是长期存储在计算机内的、有组织的、可共享的大量数据集合。</p><h3 id="数据库系统-DBS"><a href="#数据库系统-DBS" class="headerlink" title="数据库系统 DBS"></a>数据库系统 DBS</h3><section class="first_box">    <!-- title -->    <article class="title">The Functions of a DBS</article>    <!-- english -->    <article class="content">        <ul class="list">            <li>Schema definition.</li>            <li>Storage structure and access-method definition.</li>            <li>Schema and physical-organization modification.</li>            <li>Granting of authorization for data access.</li>            <li>Routine maintenance.</li>        </ul>    </article>    <!-- divide line -->    <div class="divider"></div>    <!-- chinese -->    <article class="content">        <div class="text">数据库系统的功能</div>        <ul class="list">            <li>模式定义。</li>            <li>存储结构和访问方法定义。</li>            <li>模式和物理组织的修改。</li>            <li>授予数据访问权限。</li>            <li>常规维护。</li>        </ul>    </article></section><h3 id="数据库管理员-DBA"><a href="#数据库管理员-DBA" class="headerlink" title="数据库管理员 DBA"></a>数据库管理员 DBA</h3><section class="first_box">    <!-- title -->    <article class="title">The Functions of a DBA (数据库管理员的职能)</article>    <!-- main points in English and Chinese -->    <ul class="list">        <li>Schema definition. The DBA creates the original database schema by executing a set of data definition            statements in the DDL.            <br><span class="translation">模式定义。数据库管理员通过执行一组数据定义语句（DDL）来创建原始的数据库模式。</span>        </li>        <li>Storage structure and access-method definition.            <br><span class="translation">存储结构和访问方法定义。</span>        </li>        <li>Schema and physical-organization modification. The DBA carries out changes to the schema and physical            organization to reflect the changing needs of the organization, or to alter the physical organization to            improve performance.            <br><span class="translation">模式和物理组织的修改。数据库管理员根据组织需求的变化，或通过更改物理组织来提高性能，进行模式和物理组织的修改。</span>        </li>        <li>Granting of authorization for data access. By granting different types of authorization, the database            administrator can regulate which parts of the database various users can access. The authorization            information is kept in a special system structure that the database system consults whenever someone            attempts to access the data in the system.            <br><span                class="translation">授予数据访问权限。通过授予不同类型的权限，数据库管理员可以控制不同用户访问数据库的不同部分。授权信息存储在一个特殊的系统结构中，每当有人尝试访问系统中的数据时，数据库系统会查阅此信息。</span>        </li>        <li>Routine maintenance.            <br><span class="translation">常规维护。</span>            <ul class="sublist">                <li>Periodically backing up the database, either onto tapes or onto remote servers, to prevent loss of                    data in case of disasters such as flooding.                    <br><span class="translation">定期备份数据库，可以备份到磁带或远程服务器，以防止灾难（如洪水）导致数据丢失。</span>                </li>                <li>Ensuring that enough free disk space is available for normal operations, and upgrading disk space as                    required.                    <br><span class="translation">确保有足够的空闲磁盘空间进行正常操作，并根据需要升级磁盘空间。</span>                </li>                <li>Monitoring jobs running on the database and ensuring that performance is not degraded by very                    expensive tasks submitted by some users.                    <br><span class="translation">监控数据库中运行的作业，确保性能不会因某些用户提交的高消耗任务而受到影响。</span>                </li>            </ul>        </li>    </ul></section><h3 id="数据模型-DataModel"><a href="#数据模型-DataModel" class="headerlink" title="数据模型 DataModel"></a>数据模型 DataModel</h3><p>数据模型的发展历程</p><ol><li>层次模型</li><li>网状模型</li><li>关系模型</li></ol><p>数据处理的三个世界</p><ol><li>现实世界：是对客观存在的世界中的事物及其联系</li><li>信息世界：是现实世界在人们头脑中的反映，是对客观事物及其联系的一种抽象描述</li><li>计算机世界：是在信息世界基础上的进一步抽象</li></ol><p>数据模型应满足以下三个要求：</p><ol><li>比较真实地模拟现实世界（现实世界）</li><li>容易为人所理解（概念世界）</li><li>便于在计算机上实现（机器世界）</li></ol><p>数据模型的分类</p><ol><li>概念数据模型：高层模型</li><li>表示型&#x2F;实现型模型：中间层模型</li><li>物理数据模型：低层模型</li></ol><h3 id="概念数据模型——高层模型"><a href="#概念数据模型——高层模型" class="headerlink" title="概念数据模型——高层模型"></a>概念数据模型——高层模型</h3><p><span style="color: red;">实体联系模型</span>和<span style="color: red;">对象数据模型</span></p><h3 id="实体-联系模型-entity-relation-model"><a href="#实体-联系模型-entity-relation-model" class="headerlink" title="实体-联系模型 entity-relation model"></a>实体-联系模型 entity-relation model</h3><p>实体是一个集合名词，表示真是世界中的对象集合或概念。<br>属性表示进一步描述实体的某个感兴趣的特性。<br>联系表示在两个或多个实体间的关联。</p><h3 id="对象-数据模型-object-data-model"><a href="#对象-数据模型-object-data-model" class="headerlink" title="对象-数据模型 object-data model"></a>对象-数据模型 object-data model</h3><p>类间的关系：</p><ol><li>泛化 (is-a)<ol><li>继承</li></ol></li><li>关联 (has-a)<ol><li>关联 assiaciation</li><li>聚合 aggregation</li><li>组合 composition</li></ol></li><li>依赖 (use-a)<ol><li>在方法接口中使用 use-in-interface</li><li>在实现中使用 use-in-implementation</li></ol></li><li>实现 (implement)<ol><li>实现一个接口</li></ol></li></ol><h3 id="表示型-实现型模型——中间层模型"><a href="#表示型-实现型模型——中间层模型" class="headerlink" title="表示型&#x2F;实现型模型——中间层模型"></a>表示型&#x2F;实现型模型——中间层模型</h3><p>表示型数据模型使用记录结构来表示数据，因此也称为基于记录的数据模型。目前主要的数据库模型是关系数据模型。</p><h3 id="物理数据模型——低层模型"><a href="#物理数据模型——低层模型" class="headerlink" title="物理数据模型——低层模型"></a>物理数据模型——低层模型</h3><p>提供的概念只对计算机专家有意义，而不是最终用户。描述了数据如何在计算机存储介质（硬盘）上存储的细节。</p><h3 id="数据库规范化-Normalization-Theory"><a href="#数据库规范化-Normalization-Theory" class="headerlink" title="数据库规范化 Normalization Theory"></a>数据库规范化 Normalization Theory</h3><p>数据库规范化是将数据库组织成符合一定规则和标准的过程。其核心目标是消除数据冗余、增强数据一致性、提高查询性能。规范化通常分为几个阶段或“范式”，每个范式都有特定的规则和标准。</p><p>1.第一范式（1NF）要求消除重复的列，从而确保每个列都包含原子值。<br>2.第二范式（2NF）在第一范式的基础上，消除非主属性对部分关键字的依赖。<br>3.第三范式（3NF）要求消除非主属性对主关键字的传递依赖。进一步的规范化阶段如BCNF（Boyce Codd范式）。<br>4.第四范式（4NF），则解决了更复杂的依赖和多值依赖问题。</p><h2 id="数据库三层模式体系结构-Three-Schema"><a href="#数据库三层模式体系结构-Three-Schema" class="headerlink" title="数据库三层模式体系结构 Three-Schema"></a>数据库三层模式体系结构 Three-Schema</h2><h3 id="内模式-internal-schema"><a href="#内模式-internal-schema" class="headerlink" title="内模式 internal schema"></a>内模式 internal schema</h3><p>内层对应内模式，用于描述数据库的物理存储结构。内模式使用物理数据模型，描述数据库的从存取路径和数据存储的全部细节。</p><h3 id="概念模式-conceptual-schema"><a href="#概念模式-conceptual-schema" class="headerlink" title="概念模式 conceptual schema"></a>概念模式 conceptual schema</h3><p>简称模式，中间层为概念层，对应概念模式。<br>用于为所有用户描述整个数据库的结构，注重描述实体、数据类型、联系、用户操作和约束，并隐藏了物理存储结构的细节。</p><p>使用表示型数据模型 E-R 模型来描述概念模式。<br>使用实现型数据模型 OO 模型来进行概念模式设计。</p><h3 id="外模式-external-schema"><a href="#外模式-external-schema" class="headerlink" title="外模式 external schema"></a>外模式 external schema</h3><p>外层或者视图层，对应若干位模式或用户视图。</p><p>每个外模式描述了特定用户组感兴趣的一部分数据库，并且对该组用户隐藏数据库的其他部分。</p><blockquote><p>例子：把数据库看作仓库，数据看作货物。内模式描述货物的摆放规则；概念模式描述仓库中货物的分类等信息；外模式实际服务仓库的相关人员。</p></blockquote><p>需要注意的是，三层模式仅仅是对数据的描述，数据实际上仅存储在物理层</p><ol><li>每个用户组只需关注自己的外模式</li><li>DBMS 必须将在外模式中指定的请求转化为针对概念模式的请求，并进而转化为对内模式的请求以实现对存储的数据库进行处理。</li><li>如果是一个数据库检索请求，那么从存储在数据库中提取出的数据必须经过格式转化，来匹配用户外部视图所要求的格式。</li><li>在各层之间完成请求和结果转换的处理过程被称为映射。</li></ol><h3 id="数据独立性"><a href="#数据独立性" class="headerlink" title="数据独立性"></a>数据独立性</h3><p>较低层的修改不会对较高层产生影响</p><ol><li>逻辑数据独立性: 外模式不会受概念模式变化的影响</li><li>物理数据独立性: 概念模式不会受内模式变化的影响</li></ol><h2 id="DBMS-体系结构"><a href="#DBMS-体系结构" class="headerlink" title="DBMS 体系结构"></a>DBMS 体系结构</h2><ol><li>Centralized</li><li>Client-server</li><li>Parallel computer architectures.</li><li>Distributed databases</li></ol><p>数据库是一整套数据管理体系，包括数据存储的模型、数据组织的架构、数据分析的算法、数据管理的工具以及数据访问的接口等等。</p><img src="/img/039.png" alt="" style="height: 400px;"><p>ppt 中有大量的概念，这里直接附上英文原文和翻译，虽然完全记不住：</p><section class="first_box">    <!-- title -->    <article class="title">Storage Manager</article>    <!-- english -->    <article class="content">        <div class="text">Storage manager is a program module that provides the interface between the low-level data            stored in the database and the application programs and queries submitted to the system.</div>        <div class="text">The storage manager is responsible for the following tasks:</div>        <ul class="list">            <li>Interaction with the file manager</li>            <li>Efficient storing, retrieving and updating of data</li>        </ul>        <div class="text">Issues:</div>        <ul class="list">            <li>Storage access</li>            <li>File organization</li>            <li>Indexing and hashing</li>        </ul>    </article>    <!-- divide line -->    <div class="divider"></div>    <!-- chinese -->    <article class="content">        <div class="text">存储管理器是一个程序模块，它提供了数据库中存储的低级数据与提交给系统的应用程序和查询之间的接口。</div>        <div class="text">存储管理器负责以下任务：</div>        <ul class="list">            <li>与文件管理器的交互</li>            <li>数据的高效存储、检索和更新</li>        </ul>        <div class="text">问题：</div>        <ul class="list">            <li>存储访问</li>            <li>文件组织</li>            <li>索引和哈希</li>        </ul>    </article></section><section class="first_box">    <!-- title -->    <article class="title">Query Processor</article>    <!-- english -->    <article class="content">        <ul class="list">            <li>DDL interpreter</li>            <li>DML Compiler</li>            <li>Query Evaluation Engine</li>        </ul>        <div class="text">Alternative ways of evaluating a given query</div>        <ul class="list">            <li>Equivalent expressions</li>            <li>Different algorithms for each operation</li>        </ul>        <div class="text">Cost difference between a good and a bad way of evaluating a query can be enormous</div>        <div class="text">Need to estimate the cost of operations</div>        <ul class="list">            <li>Depends critically on statistical information about relations which the database must maintain</li>            <li>Need to estimate statistics for intermediate results to compute cost of complex expressions</li>        </ul>    </article>    <!-- divide line -->    <div class="divider"></div>    <!-- chinese -->    <article class="content">        <div class="text">查询处理器</div>        <ul class="list">            <li>DDL 解释器</li>            <li>DML 编译器</li>            <li>查询评估引擎</li>        </ul>        <div class="text">评估给定查询的替代方法：</div>        <ul class="list">            <li>等效表达式</li>            <li>每个操作的不同算法</li>        </ul>        <div class="text">评估查询的好方式和坏方式之间的成本差异可能是巨大的，需要估算操作的成本：</div>        <ul class="list">            <li>成本估算严重依赖于数据库必须维护的关系的统计信息。</li>            <li>为了计算复杂表达式的成本，还需要估算中间结果的统计信息。</li>        </ul>    </article></section><section class="first_box">    <!-- title -->    <article class="title">Possible Issues in Databases</article>    <!-- english -->    <article class="content">        <ul class="list">            <li>What if the system fails?</li>            <li>What if more than one user is concurrently updating the same data?</li>            <li>A transaction is a collection of operations that performs a single logical function in a database                application.</li>            <li>Transaction-management component ensures that the database remains in a consistent (correct) state                despite system failures (e.g., power failures and operating system crashes) and transaction failures.            </li>            <li>Concurrency-control manager controls the interaction among the concurrent transactions, to ensure the                consistency of the database.</li>        </ul>    </article>    <!-- divide line -->    <div class="divider"></div>    <!-- chinese -->    <article class="content">        <ul class="list">            <li>如果多个用户同时更新相同的数据怎么办？</li>            <li>事务是一个操作集合，在数据库应用程序中执行一个单一的逻辑功能。</li>            <li>事务管理组件确保数据库在系统故障（例如电力故障和操作系统崩溃）和事务失败的情况下仍保持一致（正确）状态。</li>            <li>并发控制管理器控制并发事务之间的交互，确保数据库的一致性。</li>        </ul>    </article></section><section class="first_box">    <!-- title -->    <article class="title">ACID of A Transaction - Atomicity</article>    <!-- english -->    <article class="content">        <ul class="list">            <li>Often, several operations on the database form a single logical unit of work (Transaction).</li>            <li>An example is a funds transfer.</li>            <li>One department account (say A) is debited.</li>            <li>Another department account (say B) is credited.</li>        </ul>        <div class="text">Clearly, it is essential that either both the credit and debit occur, or that neither occur.            That is, the funds transfer must happen in its entirety or not at all.</div>        <div class="text">This all-or-none requirement is called Atomicity.</div>    </article>    <!-- divide line -->    <div class="divider"></div>    <!-- chinese -->    <article class="content">        <div class="text">事务的ACID——原子性 (Atomicity)</div>        <ul class="list">            <li>通常，多个操作在数据库上形成一个单一的逻辑工作单元（事务）。</li>            <li>例如，一个资金转账操作。</li>            <li>一个部门账户（如A）被扣款。</li>            <li>另一个部门账户（如B）被存款。</li>        </ul>        <div class="text">显然，至关重要的是，扣款和存款要么都发生，要么都不发生。也就是说，资金转账要么完全发生，要么完全不发生。</div>        <div class="text">这种“全有或全无”的要求被称为原子性。</div>    </article></section><section class="first_box">    <!-- title -->    <article class="title">ACID of A Transaction - Consistency</article>    <!-- english -->    <article class="content">        <ul class="list">            <li>It is essential that the execution of the funds transfer preserve the consistency of the database.</li>            <li>That is, the value of the sum of the balances of A and B must be preserved.</li>            <li>This correctness requirement is called consistency.</li>        </ul>    </article>    <!-- divide line -->    <div class="divider"></div>    <!-- chinese -->    <article class="content">        <div class="text">事务的ACID —— 一致性 (Consistency)</div>        <ul class="list">            <li>确保资金转账的执行保持数据库的一致性是至关重要的。</li>            <li>也就是说，A和B账户余额的总和必须保持不变。</li>            <li>这种正确性要求被称为一致性。</li>        </ul>    </article></section><section class="first_box">    <!-- title -->    <article class="title">ACID of A Transaction - Durability</article>    <!-- english -->    <article class="content">        <ul class="list">            <li>Finally, after the successful execution of a funds transfer, the new values of the balances of accounts                A and B must persist, despite the possibility of system failure.</li>            <li>This persistence requirement is called durability.</li>        </ul>    </article>    <!-- divide line -->    <div class="divider"></div>    <!-- chinese -->    <article class="content">        <div class="text">事务的ACID —— 持久性 (Durability)</div>        <ul class="list">            <li>最后，在资金转账成功执行后，账户A和B的新余额值必须持久存在，即使系统发生故障也不受影响。</li>            <li>这种持久性要求被称为持久性。</li>        </ul>    </article></section><section class="first_box">    <!-- title -->    <article class="title">ACID of A Transaction - Isolation</article>    <!-- english -->    <article class="content">        <ul class="list">            <li>Even if the consistency and atomicity properties are ensured for each transaction, if several                transactions are executed concurrently, their operations may interleave in some undesirable way,                resulting in an inconsistent state.</li>            <li>For example, as we saw earlier, the database is temporarily inconsistent while the transaction to                transfer funds from A to B is executing, with the deducted total written to A and the increased total                yet to be written to B.</li>            <li>If a second concurrently running transaction reads A and B at this intermediate point and computes A+B,                it will observe an inconsistent value.</li>            <li>Furthermore, if this second transaction then performs updates on A and B based on the inconsistent                values that it read, the database may be left in an inconsistent state even after both transactions have                completed.</li>        </ul>    </article>    <!-- divide line -->    <div class="divider"></div>    <!-- chinese -->    <article class="content">        <div class="text">事务的ACID —— 隔离性 (Isolation)</div>        <ul class="list">            <li>即使每个事务都确保了一致性和原子性属性，如果多个事务并发执行，它们的操作可能会以某种不期望的方式交错，导致数据库处于不一致状态。</li>            <li>例如，如前所述，在从A账户转账到B账户的事务执行期间，数据库是暂时不一致的，因为A账户的扣款已写入，而B账户的增加金额尚未写入。</li>            <li>如果第二个并发运行的事务在这个中间状态下读取A和B，并计算A+B，它将观察到一个不一致的值。</li>            <li>此外，如果这个第二个事务基于读取到的不一致值对A和B进行更新，即使两个事务都已完成，数据库仍可能处于不一致的状态。</li>        </ul>    </article></section><section class="first_box">    <!-- title -->    <article class="title">ACID of A Transaction - Isolation</article>    <!-- english -->    <article class="content">        <ul class="list">            <li>A way to avoid the problem of concurrently executing transactions is to execute transactions                serially—that is, one after the other. However, concurrent execution of transactions provides                significant performance benefits.</li>            <li>Other solutions have therefore been developed; they allow multiple transactions to execute concurrently.                We discuss the problems caused by concurrently executing transactions in Section 14.5.</li>            <li>The isolation property of a transaction ensures that the concurrent execution of transactions results in                a system state that is equivalent to a state that could have been obtained had these transactions                executed one at a time in some order.</li>            <li>Ensuring the isolation property is the responsibility of a component of the database system called the                concurrency-control system.</li>        </ul>    </article>    <!-- divide line -->    <div class="divider"></div>    <!-- chinese -->    <article class="content">        <div class="text">事务的ACID —— 隔离性 (Isolation)</div>        <ul class="list">            <li>避免并发执行事务问题的一种方法是串行执行事务——即一个接一个地执行。然而，并发执行事务能够提供显著的性能提升。</li>            <li>因此，已经开发出其他解决方案，它们允许多个事务并发执行。我们将在第14.5节讨论并发执行事务引发的问题。</li>            <li>事务的隔离性属性确保并发执行的事务结果等同于按某种顺序逐个执行这些事务时所得到的系统状态。</li>            <li>确保隔离性属性是数据库系统中的一个组件——并发控制系统——的责任。</li>        </ul>    </article></section>]]></content>
    
    
    
    <tags>
      
      <tag>DataBase</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust</title>
    <link href="/2024/11/24/Rust/"/>
    <url>/2024/11/24/Rust/</url>
    
    <content type="html"><![CDATA[<h2 id="Chapter2"><a href="#Chapter2" class="headerlink" title="Chapter2"></a>Chapter2</h2><p>let 定义变量，默认不可变，可变变量需要用 mut 关键字。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>强类型推导，会根据等号右边结果或者后文自动推导变量类型。使用冒号可以定义类型。Rust 在编译的时候就必须知道变量的类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span>: <span class="hljs-type">i32</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span>: <span class="hljs-type">u32</span> = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>宏<code>println!</code>用于输出，<code>&#123;&#125;</code>用于填入此参数，在大括号中填数字可以分组。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;cout &#123;0&#125;, &#123;0&#125;, &#123;1&#125;&quot;</span>, a, b);<br></code></pre></td></tr></table></figure><p>有些函数的返回值为<code>Rusult</code>，有<code>Ok</code>, <code>Err</code>两种，使用<code>expect</code>函数可以在错误时输出信息，但是程序仍然会崩溃。使用<code>match</code>可以优美(网上这么说的)的在错误时采取其他的行为从而使程序继续。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-comment">// expect</span><br>io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> num).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Failed to read line&quot;</span>);<br><br><span class="hljs-comment">// match</span><br><span class="hljs-keyword">match</span> io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> num) &#123;<br>  <span class="hljs-title function_ invoke__">Ok</span>(num) =&gt; num,<br>  <span class="hljs-title function_ invoke__">Err</span>(_) =&gt; ...,    <span class="hljs-comment">// _ = not care</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>猜数游戏：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">use</span> rand::Rng;<br><span class="hljs-keyword">use</span> std::cmp::Ordering;<br><span class="hljs-keyword">use</span> std::io;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">secret_number</span> = rand::<span class="hljs-title function_ invoke__">thread_rng</span>().<span class="hljs-title function_ invoke__">gen_range</span>(<span class="hljs-number">1</span>..=<span class="hljs-number">100</span>);<br><br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Please input your guess.&quot;</span>);<br><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">guess</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br><br>        io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> guess).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Failed to read line&quot;</span>);<br><br>        <span class="hljs-comment">// shadow</span><br>        <span class="hljs-comment">// trim : delete &quot; &quot;</span><br>        <span class="hljs-comment">// parse : stoi</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">guess</span>: <span class="hljs-type">u32</span> = <span class="hljs-keyword">match</span> guess.<span class="hljs-title function_ invoke__">trim</span>().<span class="hljs-title function_ invoke__">parse</span>() &#123;<br>            <span class="hljs-title function_ invoke__">Ok</span>(num) =&gt; num,<br>            <span class="hljs-title function_ invoke__">Err</span>(_) =&gt; <span class="hljs-keyword">continue</span>,     <span class="hljs-comment">// _ = not care</span><br>        &#125;;<br><br>        <span class="hljs-keyword">match</span> guess.<span class="hljs-title function_ invoke__">cmp</span>(&amp;secret_number) &#123;<br>            Ordering::Less =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Too small!&quot;</span>),<br>            Ordering::Greater =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Too big!&quot;</span>),<br>            Ordering::Equal =&gt; &#123;<br>                <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;You win!&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Chapter3"><a href="#Chapter3" class="headerlink" title="Chapter3"></a>Chapter3</h2><p>常量不等于不可变的变量，const 声明，必须指定类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">const</span> MAX_NUM: <span class="hljs-type">i64</span> = <span class="hljs-number">20070206</span>;<br></code></pre></td></tr></table></figure><p>Shadow 机制，同名变量后者会隐藏前者。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-comment">// mut</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num1</span> = <span class="hljs-number">10</span>;<br>num1 = <span class="hljs-number">20</span>;<br><br><span class="hljs-comment">// shadow</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num1</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">num1</span> = <span class="hljs-string">&quot;dmx20070206&quot;</span>;<br></code></pre></td></tr></table></figure><p>Rust 的整数类型：</p><table><thead><tr><th>位长度</th><th>有符号</th><th>无符号</th></tr></thead><tbody><tr><td>8 bit</td><td>i8</td><td>u8</td></tr><tr><td>16 bit</td><td>i16</td><td>u16</td></tr><tr><td>32 bit</td><td>i32</td><td>u32</td></tr><tr><td>64 bit</td><td>i64</td><td>u64</td></tr><tr><td>128 bit</td><td>i128</td><td>u128</td></tr><tr><td>arch</td><td>isize</td><td>usize</td></tr><tr><td>不同进制：0x, 0o, 0b。任何进制都可以用 _ 分割。i32 为默认类型。</td><td></td><td></td></tr></tbody></table><p>Rust 的浮点数类型：<br>f32, f64, IEEE-754 标准。f64 为默认类型。</p><p>Rust 的布尔类型：略</p><p>Rust 的字符类型：<br>表示一个 Unicode 字符，占用 4 个字节。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num1</span> = &#x27;😅&#x27;;<br></code></pre></td></tr></table></figure><p>Rust 中的 Tuple：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span>: (<span class="hljs-type">u32</span>, <span class="hljs-type">char</span>, <span class="hljs-type">f32</span>) = (<span class="hljs-number">10</span>, &#x27;😅&#x27;, <span class="hljs-number">1.5</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, num.<span class="hljs-number">0</span>, num.<span class="hljs-number">1</span>, num.<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>Rust 中的 数组:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-comment">// 类型; 长度</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span>: [<span class="hljs-type">f64</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">1.1</span>, <span class="hljs-number">1.2</span>, <span class="hljs-number">1.3</span>];<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, num[<span class="hljs-number">0</span>], num[<span class="hljs-number">1</span>], num[<span class="hljs-number">2</span>]);<br><br><span class="hljs-comment">// 数据; 重复次数</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = [<span class="hljs-number">3</span>; <span class="hljs-number">5</span>];<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, num[<span class="hljs-number">0</span>], num[<span class="hljs-number">1</span>], num[<span class="hljs-number">2</span>], num[<span class="hljs-number">3</span>], num[<span class="hljs-number">4</span>]);<br></code></pre></td></tr></table></figure><p>Rust 中的表达式类型：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-comment">// x = the last expression</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-number">10</span>;<br>        num<br>    &#125;;<br></code></pre></td></tr></table></figure><p>Rust 中的函数，用<code>fn</code>关键字，参数必须声明类型，返回值用<code>-&gt;</code>符号定义，函数默认返回最后一个表达式，可以隐藏<code>return</code>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-comment">// return the last expression</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>(x: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    x + <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>(x: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Rust 中的 if-else：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">condition</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = <span class="hljs-keyword">if</span> condition &#123; <span class="hljs-number">10</span> &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-number">20</span> &#125;;<br></code></pre></td></tr></table></figure><p>Rust 中的 while：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">i</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">while</span> i &gt; <span class="hljs-number">0</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;time: &#123;&#125;&quot;</span>, i);<br>    i = i - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Rust 中的 for：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span> &#123;<br>   <span class="hljs-comment">// 1..5  &lt;=&gt; [1, 5)</span><br>   <span class="hljs-comment">// 1..=5 &lt;=&gt; [1, 5]</span><br>   <span class="hljs-comment">// 1..   &lt;=&gt; [1, +∞)</span><br>   <span class="hljs-comment">// ..=5  &lt;=&gt; (-∞, 5]</span><br>   ...<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Chapter-4"><a href="#Chapter-4" class="headerlink" title="Chapter 4"></a>Chapter 4</h2><p><strong>所有权</strong>是 Rust 中很重要的概念，所有程序在运行时都必须管理它们使用计算机内存的方式。</p><ol><li>有些语言自带 GC，程序运行时会一直搜索已经不用的内存</li><li>有些语言需要程序员显式的申请和释放内存</li><li>Rust 通过一个所有权系统来管理内存，其中包含一组编译器在编译时检测的规则</li></ol><p>Rust 中，可以向 Stack 和 Heap 申请内存。Stack 只能存放<strong>定长</strong>的数据，Heap 可以存放<strong>变长</strong>的数据。很明显，计算机访问 Stack 上的数据快于 Heap，因为从 Stack 获取数据一定是栈顶，并且 Stack 中各个数据离得近。</p><p>String 类型是典型的变长数据类型，它只能存放于 Heap 上。通过<code>from</code>方法可以通过字符串常量创建一个 String 类型，它存放于 Heap 上，所以它是可变的。</p><p><strong>Drop</strong>, <strong>Move</strong>, <strong>Copy</strong>, <strong>Clone</strong></p><p><strong>Drop</strong> 清理规则：</p><ol><li>当一个数据<strong>离开作用域</strong>时，立即释放它占用的内存</li><li>对于失效(Moved)的变量，不会释放它占用的内存</li><li>对于 Stack 上的简单数据，不需要 Drop</li><li>对于 Heap 上的数据，需要 Drop</li></ol><p><strong>Move</strong> 移动规则：</p><ol><li>对于 Stack 数据，等同于 Copy</li><li>对于 Heap 数据，前者将被<strong>失效</strong><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num1</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">num2</span> = num1;    <span class="hljs-comment">// copy</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;dmx&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1;        <span class="hljs-comment">// s1 moved</span><br><br><span class="hljs-comment">// borrow of moved value: `s1`</span><br><span class="hljs-comment">// println!(&quot;&#123;&#125;&quot;, s1);</span><br><br><span class="hljs-comment">// exit, s2 will be destoryed</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>Copy</strong> 拷贝规则：</p><ol><li>如果变量一部分创建了 Drop，那么该变量不能拥有 Copy</li><li>Copy 类型的变量一般存放于 Stack 上，不需要额外的 Drop 操作<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">num1</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">num2</span> = num1;    <span class="hljs-comment">// copy type</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>Clone</strong> 克隆规则：</p><ol><li>使用 clone 方法，可以实现深拷贝？</li><li>在 Heap 上开辟新的一块内存<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;dmx&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1.<span class="hljs-title function_ invoke__">clone</span>();    <span class="hljs-comment">// s1 still valid</span><br></code></pre></td></tr></table></figure></li></ol><p>函数的参数传递中所有权的转移</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-comment">// s 被声明有效</span><br><br>    <span class="hljs-title function_ invoke__">takes_ownership</span>(s);<br>    <span class="hljs-comment">// s 的值被当作参数传入函数</span><br>    <span class="hljs-comment">// 所以可以当作 s 已经被移动，从这里开始已经无效</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-comment">// x 被声明有效</span><br><br>    <span class="hljs-title function_ invoke__">makes_copy</span>(x);<br>    <span class="hljs-comment">// x 的值被当作参数传入函数</span><br>    <span class="hljs-comment">// 但 x 是基本类型，依然有效</span><br>    <span class="hljs-comment">// 在这里依然可以使用 x 却不能使用 s</span><br><br>&#125; <span class="hljs-comment">// 函数结束, x 无效, 然后是 s. 但 s 已被移动, 所以不用被释放</span><br><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">takes_ownership</span>(some_string: <span class="hljs-type">String</span>) &#123; <br>    <span class="hljs-comment">// 一个 String 参数 some_string 传入，有效</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, some_string);<br>&#125; <span class="hljs-comment">// 函数结束, 参数 some_string 在这里释放</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">makes_copy</span>(some_integer: <span class="hljs-type">i32</span>) &#123; <br>    <span class="hljs-comment">// 一个 i32 参数 some_integer 传入，有效</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, some_integer);<br>&#125; <span class="hljs-comment">// 函数结束, 参数 some_integer 是基本类型, 无需释放</span><br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-title function_ invoke__">gives_ownership</span>();<br>    <span class="hljs-comment">// gives_ownership 移动它的返回值到 s1</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-comment">// s2 被声明有效</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span> = <span class="hljs-title function_ invoke__">takes_and_gives_back</span>(s2);<br>    <span class="hljs-comment">// s2 被当作参数移动, s3 获得返回值所有权</span><br>&#125; <span class="hljs-comment">// s3 无效被释放, s2 被移动, s1 无效被释放.</span><br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">gives_ownership</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">some_string</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-comment">// some_string 被声明有效</span><br><br>    <span class="hljs-keyword">return</span> some_string;<br>    <span class="hljs-comment">// some_string 被当作返回值移动出函数</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">takes_and_gives_back</span>(a_string: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123; <br>    <span class="hljs-comment">// a_string 被声明有效</span><br><br>    a_string  <span class="hljs-comment">// a_string 被当作返回值移出函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Rust 中的<strong>引用</strong>和<strong>租借</strong></p><p>引用是一种“借”所有权的过程，例如下面的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = <span class="hljs-title function_ invoke__">calculate_length</span>(&amp;s1);<br><br>    <span class="hljs-comment">// s1 is borrowed</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">calculate_length</span>(s: &amp;<span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">usize</span> &#123;<br>    s.<span class="hljs-title function_ invoke__">len</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>借用后不可以修改原数据，除非用<code>mut</code>关键字修饰，如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;dmx&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = &amp;<span class="hljs-keyword">mut</span> s1;<br><br>    s2.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;20070206&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s2);<br>&#125;<br></code></pre></td></tr></table></figure><p>一个变量的某时刻的全部有效引用必须满足如下规则：</p><ol><li>有至多一个可变引用</li><li>有若干个不可变引用</li><li>引用必须一致有效</li></ol><p>同时，在 Rust 中不允许悬空引用，如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">reference_to_nothing</span> = <span class="hljs-title function_ invoke__">dangle</span>();<br>    <span class="hljs-comment">// null</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dangle</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><br>    &amp;s<br>&#125;<br><span class="hljs-comment">// s will be destoryed</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ENGLISH</title>
    <link href="/2024/11/21/ENGLISH/"/>
    <url>/2024/11/21/ENGLISH/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" href="/css/ENGLISH.css"><h2 id="2024-11-22"><a href="#2024-11-22" class="headerlink" title="2024-11-22"></a>2024-11-22</h2><h3 id="list-1"><a href="#list-1" class="headerlink" title="list 1"></a>list 1</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>account</td><td>benefit</td><td>challenge</td></tr><tr><td>impact</td><td>apply</td><td>focus</td></tr><tr><td>involve</td><td>potential</td><td>promote</td></tr><tr><td>shift</td><td>tend</td><td>access</td></tr><tr><td>resource</td><td>launch</td><td>current</td></tr><tr><td>opportunity</td><td>reflect</td><td>debate</td></tr><tr><td>conduct</td><td>despite</td><td>determine</td></tr><tr><td>purchase</td><td>specific</td><td>senior</td></tr><tr><td>unique</td><td>amount</td><td>agency</td></tr><tr><td>expand</td><td>attitude</td><td>financial</td></tr><tr><td>release</td><td>declare</td><td>institution</td></tr><tr><td>estimate</td><td>pose</td><td>significant</td></tr><tr><td>associate</td><td>assume</td><td>eventually</td></tr><tr><td>replace</td><td>series</td><td>fund</td></tr><tr><td>rank</td><td>respond</td><td>advocate</td></tr><tr><td>boost</td><td>throughout</td><td>define</td></tr><tr><td>establish</td><td>predict</td><td>attach</td></tr><tr><td>campaign</td><td>track</td><td>exchange</td></tr><tr><td>numerous</td><td>expose</td><td>overall</td></tr><tr><td>vehicle</td><td>outcome</td><td>intend</td></tr><tr><td>reveal</td><td>positive</td><td>critical</td></tr><tr><td>survey</td><td>capacity</td><td>enhance</td></tr></tbody></table><h3 id="list-2"><a href="#list-2" class="headerlink" title="list 2"></a>list 2</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>vocal</td><td>officials</td><td>overestimate</td></tr><tr><td>hesitant</td><td>terminate</td><td>invest</td></tr><tr><td>bleak</td><td>inclusiveness</td><td>frontline</td></tr><tr><td>genre</td><td>regulation</td><td>overnight</td></tr><tr><td>distinguish</td><td>money-making</td><td>monolingual</td></tr><tr><td>bilingual</td><td>multilingual</td><td>leather</td></tr><tr><td>substitute</td><td>fierce</td><td>particularly</td></tr><tr><td>obsessed</td><td>cognitive</td><td>elite</td></tr><tr><td>vast</td><td>bulk</td><td>aggressive</td></tr><tr><td>inflation</td><td>cross-country</td><td>church</td></tr><tr><td>dictate</td><td>infant</td><td>struggle</td></tr><tr><td>category</td><td>measure</td><td>interpret</td></tr><tr><td>exotic</td><td>acclaim</td><td>infrastructure</td></tr></tbody></table><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">reg</span> [<span class="hljs-number">7</span>:<span class="hljs-number">0</span>] total = <span class="hljs-number">66</span> + <span class="hljs-number">39</span>;<br></code></pre></td></tr></table></figure><h2 id="2024-11-24"><a href="#2024-11-24" class="headerlink" title="2024-11-24"></a>2024-11-24</h2><h3 id="list-1-1"><a href="#list-1-1" class="headerlink" title="list 1"></a>list 1</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>executive</td><td>confidence</td><td>motivate</td></tr><tr><td>eliminate</td><td>expense</td><td>peer</td></tr><tr><td>responsibility</td><td>ignore</td><td>commit</td></tr><tr><td>complex</td><td>corporate</td><td>bias</td></tr><tr><td>majority</td><td>distinguish</td><td>alternative</td></tr><tr><td>identify</td><td>invest</td><td>consequence</td></tr><tr><td>spot</td><td>combine</td><td>option</td></tr><tr><td>annual</td><td>discount</td><td>negative</td></tr><tr><td>superior</td><td>obtain</td><td>extreme</td></tr><tr><td>attribute</td><td>assess</td><td>identity</td></tr><tr><td>notion</td><td>rely</td><td>perceive</td></tr><tr><td>staff</td><td>vital</td><td>chain</td></tr><tr><td>yield</td><td>enable</td><td>priority</td></tr><tr><td>consist</td><td>embrace</td><td>imply</td></tr><tr><td>refer</td><td>detail</td><td>recommend</td></tr><tr><td>exhibit</td><td>crucial</td><td>talent</td></tr><tr><td>consume</td><td>relate</td><td>construction</td></tr><tr><td>diminish</td><td>emission</td><td>incentive</td></tr><tr><td>remind</td><td>accelerate</td><td>shrink</td></tr><tr><td>counterpart</td><td>medium</td><td>enormous</td></tr><tr><td>giant</td><td>locate</td><td>ongoing</td></tr><tr><td>status</td><td>thrive</td><td>cater</td></tr><tr><td>transfer</td><td>investigate</td><td>encounter</td></tr><tr><td>essential</td><td>necessarily</td><td></td></tr></tbody></table><h3 id="list-2-1"><a href="#list-2-1" class="headerlink" title="list 2"></a>list 2</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>fellow</td><td>agriculture</td><td>entirely</td></tr><tr><td>presense</td><td>intensify</td><td>foster</td></tr><tr><td>talent</td><td>culturally</td><td>competency</td></tr><tr><td>bond</td><td>exaggerate</td><td>entrepreneur</td></tr><tr><td>permission</td><td>principal</td><td>separate</td></tr><tr><td>weird</td><td>willpower</td><td>faculty</td></tr><tr><td>donate</td><td>maintenance</td><td>campus</td></tr><tr><td>utility</td><td>insight</td><td>fertilizer</td></tr><tr><td>impressively</td><td>policymaker</td><td>tongue</td></tr><tr><td>magnify</td><td>split</td><td>depict</td></tr><tr><td>simul-taneously</td><td>endeavour</td><td>restrict</td></tr><tr><td>composition</td><td>inspirational</td><td>peak</td></tr><tr><td>anxiety</td><td>transition</td><td>harsh</td></tr><tr><td>wither</td><td>contract</td><td>curriculum</td></tr><tr><td>inferior</td><td>ladylike</td><td>devour</td></tr><tr><td>object</td><td>species</td><td>chemical</td></tr><tr><td>favor</td><td>sanctuary</td><td>bold</td></tr></tbody></table><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">total</span>: <span class="hljs-type">u32</span> = <span class="hljs-number">71</span> + <span class="hljs-number">51</span>;<br></code></pre></td></tr></table></figure><h2 id="2024-11-25"><a href="#2024-11-25" class="headerlink" title="2024-11-25"></a>2024-11-25</h2><h3 id="list-1-2"><a href="#list-1-2" class="headerlink" title="list 1"></a>list 1</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>previous</td><td>alter</td><td>institute</td></tr><tr><td>engage</td><td>abandon</td><td>transform</td></tr><tr><td>maintain</td><td>preserve</td><td>budget</td></tr><tr><td>assumption</td><td>cooperation</td><td>demonstrate</td></tr><tr><td>inform</td><td>recession</td><td>regulation</td></tr><tr><td>sophisticated</td><td>upgrade</td><td>abuse</td></tr><tr><td>circumstance</td><td>emerge</td><td>function</td></tr><tr><td>generate</td><td>profit</td><td>label</td></tr><tr><td>oppose</td><td>revenue</td><td>adapt</td></tr><tr><td>behave</td><td>cognitive</td><td>collapse</td></tr><tr><td>curriculum</td><td>exert</td><td>stimulate</td></tr><tr><td>stuff</td><td>bother</td><td>brand</td></tr><tr><td>considerable</td><td>contrast</td><td>indicate</td></tr><tr><td>modify</td><td>scale</td><td>absorb</td></tr><tr><td>candidate</td><td>crash</td><td>statistic</td></tr><tr><td>switch</td><td>tuition</td><td>reserve</td></tr><tr><td>breed</td><td>appreciate</td><td>conflict</td></tr><tr><td>implement</td><td>massive</td><td>highlight</td></tr><tr><td>capable</td><td>crime</td><td>explore</td></tr><tr><td>extend</td><td>meanwhile</td><td>regulate</td></tr><tr><td>cultivate</td><td>luxury</td><td>retain</td></tr><tr><td>due</td><td>latter</td><td>reverse</td></tr><tr><td>reject</td><td>virtue</td><td>sufficient</td></tr><tr><td>profound</td><td>reward</td><td>approach</td></tr><tr><td>appropriate</td><td></td><td></td></tr></tbody></table><h3 id="list-2-2"><a href="#list-2-2" class="headerlink" title="list 2"></a>list 2</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>treatment</td><td>relieve</td><td>figure</td></tr><tr><td>maintenance</td><td>pit</td><td>deposit</td></tr><tr><td>stick</td><td>alien</td><td>ecosystem</td></tr><tr><td>noticeable</td><td>witness</td><td>bankruptcy</td></tr><tr><td>phenomenon</td><td>arrest</td><td>charge</td></tr><tr><td>corruption</td><td>destined</td><td>victorious</td></tr><tr><td>sharply</td><td>regardless</td><td>observe</td></tr><tr><td>progress</td><td>rigorous</td><td>endure</td></tr><tr><td>pierce</td><td>elbow</td><td>snobby</td></tr><tr><td>insurance</td><td>commision</td><td>swamp</td></tr><tr><td>dweller</td><td>federal</td><td>drain</td></tr><tr><td>mental</td><td>lottery</td><td>laborious</td></tr><tr><td>ordeal</td><td>milestone</td><td>wheat</td></tr><tr><td>rupture</td><td>diplomatic</td><td>incident</td></tr><tr><td>infrastructure</td><td>peril</td><td>indeed</td></tr><tr><td>prestige</td><td>brand</td><td>former</td></tr><tr><td>reversible</td><td>pity</td><td>assert</td></tr><tr><td>dominance</td><td>companion</td><td>appropriation</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> total = <span class="hljs-number">73</span> + <span class="hljs-number">54</span>;<br></code></pre></td></tr></table></figure><h2 id="2024-11-27"><a href="#2024-11-27" class="headerlink" title="2024-11-27"></a>2024-11-27</h2><h3 id="list-1-3"><a href="#list-1-3" class="headerlink" title="list 1"></a>list 1</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>anticipate</td><td>array</td><td>embed</td></tr><tr><td>expertise</td><td>frame</td><td>grand</td></tr><tr><td>insist</td><td>obstacle</td><td>patent</td></tr><tr><td>peak</td><td>principal</td><td>shed</td></tr><tr><td>prior</td><td>prospect</td><td>remedy</td></tr><tr><td>rigorous</td><td>strengthen</td><td>tackle</td></tr><tr><td>transition</td><td>acknowledge</td><td>deposit</td></tr><tr><td>discourage</td><td>evolve</td><td>fake</td></tr><tr><td>manner</td><td>rival</td><td>severe</td></tr><tr><td>stereotype</td><td>toxic</td><td>vulnerable</td></tr><tr><td>ceremony</td><td>aspect</td><td>capture</td></tr><tr><td>domestic</td><td>endanger</td><td>exaggerate</td></tr><tr><td>indispensable</td><td>passion</td><td>phenomenon</td></tr><tr><td>pile</td><td></td><td></td></tr></tbody></table><h3 id="list-2-3"><a href="#list-2-3" class="headerlink" title="list 2"></a>list 2</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> total = ; <br></code></pre></td></tr></table></figure><h2 id="2024-11-29"><a href="#2024-11-29" class="headerlink" title="2024-11-29"></a>2024-11-29</h2><h3 id="list-1-4"><a href="#list-1-4" class="headerlink" title="list 1"></a>list 1</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>rare</td><td>rear</td><td>adolescent</td></tr><tr><td>assign</td><td>float</td><td>furthermore</td></tr><tr><td>illustrate</td><td>occupy</td><td>perspective</td></tr><tr><td>register</td><td>relieve</td><td>robust</td></tr><tr><td>ecosystem</td><td>responsible</td><td>fatal</td></tr><tr><td>reproduce</td><td>decrease</td><td>propose</td></tr><tr><td>ultimate</td><td>adjust</td><td>incorporate</td></tr><tr><td>version</td><td>ingredient</td><td>recall</td></tr><tr><td>artificial</td><td>arise</td><td>complain</td></tr><tr><td>differ</td><td>dramatic</td><td>intelligence</td></tr><tr><td>mininum</td><td>obvious</td><td>prosperity</td></tr><tr><td>abstract</td><td>accuse</td><td>intelligent</td></tr><tr><td>tenant</td><td>display</td><td>refrain</td></tr><tr><td>bet</td><td>stable</td><td>underestimate</td></tr><tr><td>compel</td><td>facilitate</td><td>leap</td></tr><tr><td>update</td><td>participate</td><td>resolve</td></tr></tbody></table><h3 id="list-2-4"><a href="#list-2-4" class="headerlink" title="list 2"></a>list 2</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="2024-12-4"><a href="#2024-12-4" class="headerlink" title="2024-12-4"></a>2024-12-4</h2><h3 id="list-1-5"><a href="#list-1-5" class="headerlink" title="list 1"></a>list 1</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>embark</td><td>accomodate</td><td>acquisition</td></tr><tr><td>arrange</td><td>award</td><td>contend</td></tr><tr><td>compromise</td><td>confirm</td><td>consultant</td></tr><tr><td>contract</td><td>controversy</td><td>criminal</td></tr><tr><td>curb</td><td>deny</td><td>enterprise</td></tr><tr><td>equip</td><td>essence</td><td>illegal</td></tr><tr><td>imperative</td><td>inquiry</td><td>insurance</td></tr><tr><td>integrate</td><td>literacy</td><td>odd</td></tr><tr><td>protest</td><td>renew</td><td>resort</td></tr><tr><td>segregation</td><td>semester</td><td>shortage</td></tr><tr><td>specialize</td><td>stem</td><td>submit</td></tr><tr><td>withdraw</td><td>calculate</td><td>consult</td></tr><tr><td>deadly</td><td>decorate</td><td>devote</td></tr><tr><td>dynamic</td><td>export</td><td>extent</td></tr><tr><td>grant</td><td>impose</td><td>justify</td></tr><tr><td>mortgage</td><td>odds</td><td>penalty</td></tr><tr><td>prejudice</td><td>profile</td><td>proportion</td></tr><tr><td>scare</td><td>skeptical</td><td>spark</td></tr><tr><td>symptom</td><td>steady</td><td>stake</td></tr><tr><td>emergency</td><td>concentrate</td><td>confront</td></tr><tr><td>derive</td><td>distribute</td><td>endure</td></tr><tr><td>entail</td><td>evaluate</td><td>impress</td></tr><tr><td>integral</td><td>intense</td><td>isolate</td></tr><tr><td>neglect</td><td>migrate</td><td>portray</td></tr><tr><td>prompt</td><td>trace</td><td>vision</td></tr><tr><td>complicate</td><td>distract</td><td>sensitive</td></tr></tbody></table><h3 id="list-2-5"><a href="#list-2-5" class="headerlink" title="list 2"></a>list 2</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>rationality</td><td>discourse</td><td>gradual</td></tr><tr><td>exposition</td><td>assertion</td><td>confine</td></tr><tr><td>overturn</td><td>reduce</td><td>sensationalism</td></tr><tr><td>commerce</td><td>proposition</td><td>commercial</td></tr><tr><td>derive</td><td>grip</td><td>colonize</td></tr><tr><td>instant</td><td>approval</td><td>constantly</td></tr><tr><td>unconsciously</td><td>curiosty</td><td>reason</td></tr><tr><td>supremacy</td><td>conducive</td><td>entitlement</td></tr><tr><td>dysfunction</td><td>legitimately</td><td>generous</td></tr><tr><td>irrespective</td><td>discrepancy</td><td>privilege</td></tr><tr><td>inflate</td><td>slack off</td><td>overindulge</td></tr><tr><td>thereby</td><td>spolit</td><td>nonetheless</td></tr><tr><td>virtue</td><td>heighten</td><td>respondent</td></tr><tr><td>alleviate</td><td>indulge</td><td>accountable</td></tr><tr><td>genuinely</td><td>deviate</td><td>confront</td></tr><tr><td>disincline</td><td>tactfully</td><td>somewhat</td></tr><tr><td>distorte</td><td>criterion</td><td></td></tr></tbody></table><h2 id="2024-12-10"><a href="#2024-12-10" class="headerlink" title="2024-12-10"></a>2024-12-10</h2><h3 id="list-2-6"><a href="#list-2-6" class="headerlink" title="list 2"></a>list 2</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>obsess</td><td>obsessive</td><td>obsession</td></tr><tr><td>onsessively</td><td>grant</td><td>assualt</td></tr><tr><td>self-esteem</td><td>mental</td><td>possess</td></tr><tr><td>possession</td><td>outright</td><td>breach</td></tr><tr><td>infringe</td><td>surveillance</td><td>inherent</td></tr><tr><td>relentness</td><td>squeeze</td><td>exhaust</td></tr><tr><td>badge</td><td>intrusive</td><td>exponent</td></tr><tr><td>harassment</td><td>implant</td><td>orinented</td></tr><tr><td>substantial</td><td>slack</td><td>revolt</td></tr><tr><td>liberty</td><td>empower</td><td>intrusion</td></tr><tr><td>counterproductive</td><td>deem</td><td></td></tr></tbody></table><h2 id="2024-12-11"><a href="#2024-12-11" class="headerlink" title="2024-12-11"></a>2024-12-11</h2><h3 id="list-1-6"><a href="#list-1-6" class="headerlink" title="list 1"></a>list 1</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>visible</td><td>visibility</td><td>invisible</td></tr><tr><td>revise</td><td>supervise</td><td>supervisor</td></tr><tr><td>vision</td><td>visionary</td><td>envisage</td></tr><tr><td>visualize</td><td>expectancy</td><td>expectation</td></tr><tr><td>unexpected</td><td>inspect</td><td>perspective</td></tr><tr><td>prospect</td><td>prospective</td><td>spectacle</td></tr><tr><td>spectacular</td><td>spectator</td><td>suspect</td></tr><tr><td>speculate</td><td>speculation</td><td>speculative</td></tr><tr><td>suspicion</td><td>suspicious</td><td>despise</td></tr><tr><td>foresight</td><td>insight</td><td>oversee</td></tr><tr><td>oversignt</td><td>coordinate</td><td>subordinate</td></tr><tr><td>oral</td><td>esteem</td><td>nurture</td></tr><tr><td>nutrition</td><td>nourish</td><td>distinct</td></tr><tr><td>distinctive</td><td>distinguishable</td><td>distinguished</td></tr><tr><td>extinguish</td><td>extinct</td><td>extinction</td></tr><tr><td>instinct</td><td>questionnare</td><td>quest</td></tr><tr><td>acquisition</td><td>inquire</td><td>inquiry</td></tr><tr><td>exquisite</td><td>layer</td><td>layout</td></tr><tr><td>lay-off</td><td>relay</td><td>compile</td></tr><tr><td>edition</td><td>editorial</td><td>justice</td></tr><tr><td>justification</td><td>justify</td><td>protest</td></tr><tr><td>testify</td><td>testimony</td><td>derive</td></tr><tr><td>rival</td><td>rating</td><td>ratio</td></tr><tr><td>ration</td><td>rational</td><td>irrational</td></tr><tr><td>minister</td><td>ministerial</td><td>ministry</td></tr><tr><td>administer</td><td>administration</td><td>administrative</td></tr></tbody></table><h3 id="list-2-7"><a href="#list-2-7" class="headerlink" title="list 2"></a>list 2</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>simultaneously</td><td>permanant</td><td>tempt</td></tr><tr><td>incorporate</td><td>unethical</td><td>unequal</td></tr><tr><td>lawfully</td><td>stain</td><td>reputation</td></tr><tr><td>delicate</td><td>stipulate</td><td>consistent</td></tr><tr><td>tip</td><td>demand</td><td>brand</td></tr><tr><td>intuitive</td><td>bolster</td><td>articulate</td></tr><tr><td>dairy</td><td>discourse</td><td>supposition</td></tr><tr><td>stigma</td><td>tread</td><td>verbal</td></tr><tr><td>broadly</td><td>devastate</td><td>warehouse</td></tr><tr><td>grocery</td><td>lane</td><td>stagger</td></tr><tr><td>trade</td><td>insecurity</td><td>peril</td></tr><tr><td>futile</td><td>inevitable</td><td>detrimental</td></tr><tr><td>sensible</td><td>overstate</td><td>prominent</td></tr><tr><td>upward</td><td>allege</td><td>erroneous</td></tr><tr><td>overview</td><td>dimension</td><td>trait</td></tr><tr><td>demographic</td><td>correlate</td><td>occupation</td></tr><tr><td>regard</td><td>authority</td><td>generalize</td></tr><tr><td>constrain</td><td>dwell</td><td></td></tr></tbody></table><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">total <span class="hljs-punctuation">=</span> <span class="hljs-keyword">Новый</span> <span class="hljs-built_in">Число</span><span class="hljs-punctuation">(</span><span class="hljs-number">78</span> <span class="hljs-punctuation">+</span> <span class="hljs-number">50</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure><h2 id="2024-12-12"><a href="#2024-12-12" class="headerlink" title="2024-12-12"></a>2024-12-12</h2><h3 id="list-2-8"><a href="#list-2-8" class="headerlink" title="list 2"></a>list 2</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>pledge</td><td>surpass</td><td>volume</td></tr><tr><td>affirm</td><td>differentiate</td><td>domian</td></tr><tr><td>formidable</td><td>overstate</td><td>term</td></tr><tr><td>loan</td><td>prevalent</td><td>intermediary</td></tr><tr><td>optimize</td><td>utterly</td><td>sneak</td></tr><tr><td>proficent</td><td>immerse</td><td>immersive</td></tr><tr><td>sprinkle</td><td>systematic</td><td>explicit</td></tr><tr><td>explicitly</td><td>notorious</td><td>legislature</td></tr><tr><td>systhesize</td><td>disprove</td><td>deliberate</td></tr><tr><td>repute</td><td>arbitrarily</td><td>convene</td></tr></tbody></table><h2 id="translate-1"><a href="#translate-1" class="headerlink" title="translate 1"></a>translate 1</h2><h3 id="Original-text"><a href="#Original-text" class="headerlink" title="Original text"></a>Original text</h3><p>中国盛产竹子，是最早开发利用竹资源的国家。竹子在中国分布广泛，品种丰富。竹子实用性强，用于生产和生活的许多方面，如筷子、桌椅的制作和桥梁、房屋的建造。中国人爱竹，自古以来就有无数文人以竹为主题，创作了绚丽多彩的文学和绘画作品。竹子主干(stem)笔直，象征正直的品格。竹子具有强大的生命力和适应能力，无论环境多么恶劣，都能够顽强生存，因而寓意坚韧不拔的精神。几千年来，竹子一直被视为中华民族品格的象征。</p><h3 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h3><p><strong>中国盛产竹子，是最早开发利用竹资源的国家。</strong><br><strong>China boasts abundant bamboo production, and stands as the earliest country to develop and utilize bamboo resources.</strong><br>词语：boast, abundant, utilize.<br>短语：stand as</p><p><strong>竹子在中国分布广泛，品种丰富。</strong><br><strong>Bamboo is widely distributed in China, and rich in variety.</strong><br>词语：widely, distributed, variety.<br>短语：rich in variety</p><p><strong>竹子实用性强，用于生产和生活的许多方面，如筷子、桌椅的制作和桥梁、房屋的建造。</strong><br><strong>Known for its high practicality, it is used in many aspects of production and daliy life, such as the making of chopsticks, tables and chairs, as well as the construction of bridges and houses.</strong><br>词语：practicality, chopstic.<br>短语：known for, high practicality, daliy life, such as … as well as</p><p><strong>中国人爱竹，自古以来就有无数文人以竹为主题，创作了绚丽多彩的文学和绘画作品。</strong><br><strong>Chinese people’s love for bamboo has been enduring, and since ancient times, countless literati have created colorful literacy and artistic works with bamboo as the theme.</strong><br>词语：endure, countless, literatus, literati, literacy, artistic.<br>短语：since the ancient times, artistic work, as the theme</p><p><strong>竹子主干(stem)笔直，象征正直的品格。</strong><br><strong>Bamboo, known for its straight stem, symbolizes integrity.</strong><br>词语：symbolize, integrity.</p><p><strong>竹子具有强大的生命力和适应能力，无论环境多么恶劣，都能够顽强生存，因而寓意坚韧不拔的精神。</strong><br><strong>Its powerful vitality and adaptability allow it to thrive in any adverse conditions, thereby signifying unyeilding perseverance.</strong><br>词语：powerful, vitality, adaptability, thrive, adverse, thereby, signify, unyield, perseverance.<br>短语：thrive in, adverse condition</p><p><strong>几千年来，竹子一直被视为中华民族品格的象征。</strong><br><strong>For thousands of years, bamboo has been regarded as a symbol of the character of the Chinese nation.</strong><br>词语：character, nation.<br>短语：regard as, Chinese nation</p><h2 id="translate-2"><a href="#translate-2" class="headerlink" title="translate 2"></a>translate 2</h2><h3 id="Original-text-1"><a href="#Original-text-1" class="headerlink" title="Original text"></a>Original text</h3><p>中国的传统婚礼习俗历史悠久，从周朝开始就逐渐形成了一套完整的婚礼仪式，有些一直沿用至今。如今的中式婚礼习俗已有很大变化，但婚礼庆典仍然十分隆重。婚礼场地经过精心装饰，以象征喜庆（jubilance）的红色为主色调，摆放着许多祝愿新人幸福的物件。在婚礼上，新人要拜天地（bow to Heaven and Earth）、拜父母和相互对拜，然后设宴招待宾客，并向宾客敬酒致谢。今天，许多年轻人依然钟情于传统的中式婚礼，体验独特而美好的中国式浪漫。</p><h3 id="Translation-1"><a href="#Translation-1" class="headerlink" title="Translation"></a>Translation</h3><p><strong>中国的传统婚礼习俗历史悠久，从周朝开始就逐渐形成了一套完整的婚礼仪式，有些一直沿用至今。</strong><br>*<em>The traditional Chinese wedding customs, which gradually formed a complete set of ceremonyies</em></p><p><span class="fuck">不学了，傻逼英语</span></p><p>听力扣了 5 分，阅读扣了 6 分，嘻嘻</p>]]></content>
    
    
    
    <tags>
      
      <tag>Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>miniob 初赛参赛总结</title>
    <link href="/2024/11/11/miniob/"/>
    <url>/2024/11/11/miniob/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>参加这个比赛其实主要目的是赚钱（感谢周师姐的校友基金，最后含泪收下 7000￥ ），所以以下很多内容可能并不专业。</p><p>最终的结果是全国第 40 名，进决赛一共有 50 个队伍，不过由于加权压力（目前估计加权相较于大二上要掉 6 分左右），决赛不一定会付出太多心血去打了。</p><p>感谢我的队友 Sazikk 和我一起熬夜肝代码，并且忍耐我的屎山代码长达 21 天之久。由于屎山太多了，所以出现屎的部分会标注。</p><blockquote><p>Sazikk 个人博客：<a href="https://sazikk.github.io/">https://sazikk.github.io</a>  目前已有数十万的观看量（狗头<br>我们的项目：<a href="https://github.com/SaZiKK/miniob-2024">https://github.com/SaZiKK/miniob-2024</a><br>806 官方链接：<a href="https://ustb-806.github.io/blogs/2024/11/oceanbase/">https://ustb-806.github.io/blogs/2024/11/oceanbase/</a></p></blockquote><h2 id="个人心得"><a href="#个人心得" class="headerlink" title="个人心得"></a>个人心得</h2><p>参加这个比赛需要什么能力：</p><ol><li>较强的 C++ 开发能力</li><li>一定的 SQL 语言理解能力</li><li>对 miniob 内核有较好的理解</li></ol><h2 id="miniob-框架解析"><a href="#miniob-框架解析" class="headerlink" title="miniob 框架解析"></a>miniob 框架解析</h2><h2 id="我负责的题目"><a href="#我负责的题目" class="headerlink" title="我负责的题目"></a>我负责的题目</h2><h3 id="drop-table"><a href="#drop-table" class="headerlink" title="drop table"></a>drop table</h3><p><img src="/img/drop_table.png"></p><p>题目要求删除某个表格，一个表格的信息包括三种：数据信息 + 索引信息 + 表格元数据</p><ol><li>数据信息：真实存放到表格当中的数据</li><li>索引信息：一个索引对应一棵 B+ 树</li><li>表格元数据：各种表格的描述信息</li></ol><p>drop table 不需要算子，需要执行器</p><h4 id="前端-lex-yacc-完善"><a href="#前端-lex-yacc-完善" class="headerlink" title="前端 lex yacc 完善"></a>前端 lex yacc 完善</h4><p>lex 加入关键字 DROP</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">DROP                                    <span class="hljs-title">RETURN_TOKEN</span><span class="hljs-params">(DROP)</span></span>;<br></code></pre></td></tr></table></figure><p>yacc 加入语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">drop_table_stmt:<br>    DROP TABLE ID &#123;<br>      $$ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ParsedSqlNode</span>(SCF_DROP_TABLE);<br>      $$-&gt;drop_table.relation_name = $<span class="hljs-number">3</span>;<br>      <span class="hljs-built_in">free</span>($<span class="hljs-number">3</span>);<br>    &#125;;<br></code></pre></td></tr></table></figure><h4 id="STMT-设计"><a href="#STMT-设计" class="headerlink" title="STMT 设计"></a>STMT 设计</h4><p>删除表格只需要表格的表名，当然正常来说在 STMT 级就应该通过表格名称获取到实际的 Table 了，但是当时写的时候放到了 Db 的删除表格函数中。</p><h4 id="EXECUTE-设计"><a href="#EXECUTE-设计" class="headerlink" title="EXECUTE 设计"></a>EXECUTE 设计</h4><p>在执行器中通过调用 db 的删除表格函数或者 table 的自毁函数。表格的自毁函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">RC <span class="hljs-title">Table::drop</span><span class="hljs-params">()</span> </span>&#123;<br><br>  <span class="hljs-comment">// 删除数据文件 data_file</span><br>  string data_file = <span class="hljs-built_in">table_data_file</span>(base_dir_.<span class="hljs-built_in">c_str</span>(), table_meta_.<span class="hljs-built_in">name</span>());<br>  <span class="hljs-built_in">unlink</span>(data_file.<span class="hljs-built_in">c_str</span>());<br><br>  <span class="hljs-comment">// 删除索引文件 index_file</span><br>  <span class="hljs-type">int</span> indexNum = table_meta_.<span class="hljs-built_in">index_num</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; indexNum; i++) &#123;<br>    <span class="hljs-keyword">auto</span> *index_meta = table_meta_.<span class="hljs-built_in">index</span>(i);<br>    string index_file = <span class="hljs-built_in">table_index_file</span>(base_dir_.<span class="hljs-built_in">c_str</span>(), table_meta_.<span class="hljs-built_in">name</span>(), index_meta-&gt;<span class="hljs-built_in">name</span>());<br>    <span class="hljs-built_in">unlink</span>(index_file.<span class="hljs-built_in">c_str</span>());<br>  &#125;<br><br>  <span class="hljs-comment">// 删除元文件 meta_file</span><br>  string meta_file = <span class="hljs-built_in">table_meta_file</span>(base_dir_.<span class="hljs-built_in">c_str</span>(), table_meta_.<span class="hljs-built_in">name</span>());<br>  <span class="hljs-built_in">unlink</span>(meta_file.<span class="hljs-built_in">c_str</span>());<br><br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p><img src="/img/update.png"></p><p>虽然题目只要求单字段的更新，但是由于后面很快就要扩充，所以下面直接放完整版。</p><p>需要注意的有两点，如何将 在某些字段修改为某值 推得 在内存某些位置修改二进制数据；以及对于多个字段的更新，必须同时成功或失败，也即先判断后修改（或回滚），不仅有单个字段间的回滚，还有单个元组间的回滚。</p><p>update 语句不需要执行器，需要算子</p><h4 id="前端-lex-yacc-完善-1"><a href="#前端-lex-yacc-完善-1" class="headerlink" title="前端 lex yacc 完善"></a>前端 lex yacc 完善</h4><p>lex 加入关键字 UPDATE</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">UPDATE                                  <span class="hljs-title">RETURN_TOKEN</span><span class="hljs-params">(UPDATE)</span></span>;<br></code></pre></td></tr></table></figure><p>yacc 加入语句<br>其中 update_target 为一个字段的更新，update_target_list 为若干字段的更新，where 为谓词表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++">update_stmt:      <span class="hljs-comment">/*  update 语句的语法解析树*/</span><br>    UPDATE ID SET update_target update_target_list where <br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ParsedSqlNode</span>(SCF_UPDATE);<br>      $$-&gt;update.relation_name = $<span class="hljs-number">2</span>;<br><br>      <span class="hljs-keyword">if</span> ($<span class="hljs-number">6</span> != <span class="hljs-literal">nullptr</span>) &#123;<br>        $$-&gt;update.conditions.<span class="hljs-built_in">swap</span>(*$<span class="hljs-number">6</span>);<br>        <span class="hljs-keyword">delete</span> $<span class="hljs-number">6</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span>($<span class="hljs-number">5</span> != <span class="hljs-literal">nullptr</span>)<br>        $$-&gt;update.update_targets.<span class="hljs-built_in">swap</span>(*$<span class="hljs-number">5</span>);<br>      $$-&gt;update.update_targets.<span class="hljs-built_in">emplace_back</span>(*$<span class="hljs-number">4</span>);<br>      std::<span class="hljs-built_in">reverse</span>($$-&gt;update.update_targets.<span class="hljs-built_in">begin</span>(), $$-&gt;update.update_targets.<span class="hljs-built_in">end</span>());<br>    &#125;<br>    ;<br></code></pre></td></tr></table></figure><p>对于 ParseSqlNode，新增 update 语句对应的 node。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UpdateSqlNode</span> &#123;<br>  std::string relation_name;                <span class="hljs-comment">// 更新表格名称</span><br>  std::vector&lt;UpdateTarget&gt; update_targets; <span class="hljs-comment">// 更新字段集合</span><br>  std::vector&lt;ConditionSqlNode&gt; conditions; <span class="hljs-comment">// 谓词条件</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UpdateTarget</span> &#123;<br>  <span class="hljs-type">bool</span> is_value;                            <span class="hljs-comment">// 是否为简单值，本题视作 true</span><br>  Value value;                              <span class="hljs-comment">// 更新的值</span><br>  std::string attribute_name;               <span class="hljs-comment">// 更新的属性名</span><br>  SubSelectSqlNode *sub_select;             <span class="hljs-comment">// 子查询，后面习题涉及</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="STMT-设计-1"><a href="#STMT-设计-1" class="headerlink" title="STMT 设计"></a>STMT 设计</h4><p>update 语句对应的 STMT 中包含：所有修改域信息(FieldMeta)，目标表格，筛选对应的 STMT(FilterStmt)，以及处理好的 UpdateTarget 数组。</p><p>第一步，拿到表格</p><p>第二步，通过所有修改域的名称，拿到全部修改域，注意顺序是不重要的，因为它们都是同时成功或同时失败的。</p><p>第三步，如果有子查询需要将子查询转化为一个 Value，后面对应的题再解释。</p><h4 id="逻辑算子和物理算子设计"><a href="#逻辑算子和物理算子设计" class="headerlink" title="逻辑算子和物理算子设计"></a>逻辑算子和物理算子设计</h4><p>逻辑算子中需要包含表格以及一个数组，数组表示需要更新的域和值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">Table *table_ = <span class="hljs-literal">nullptr</span>;<br>std::vector&lt;std::pair&lt;Value, FieldMeta&gt;&gt; update_map_;<br></code></pre></td></tr></table></figure><p>物理算子直接继承逻辑算子中的表格和&lt;域, 值&gt;数组，除此之外还需要包含一个 Record 数组，因为我们要处理单个元组的回滚。在存在 unique index 的情境下，一条 update 语句可能对多个元组进行修改，<br>如果修改时发现某一条元组的修改是非法的，则之前所有的修改都要撤回。此处存放修改前的 Record 数组方便回滚。而对于单个字段的回滚，我们采取先判断合法再修改的策略，也即只有全部字段的修改都是有效的<br>才会开始实际的修改。</p><p>例如： </p><table><thead><tr><th>id</th><th>num</th><th>col</th></tr></thead><tbody><tr><td>id1</td><td>num1</td><td>col1</td></tr><tr><td>id2</td><td>num2</td><td>col2</td></tr><tr><td>id3</td><td>num3</td><td>col3</td></tr></tbody></table><p>update 语句需要修改第一个元组和第三个元组的 id, col 字段。</p><p>元组级别的回滚：更新第一个元组没问题，但是更新第三个元组是非法的。</p><p>字段级别的回滚：更新某个元组时，更新 id 域没问题，但是更新 col 域是非法的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">Table *table_ = <span class="hljs-literal">nullptr</span>;<br>Trx *trx_ = <span class="hljs-literal">nullptr</span>;<br>std::vector&lt;std::pair&lt;Value, FieldMeta&gt;&gt; update_map_;<br>std::vector&lt;Record&gt; records_;<br></code></pre></td></tr></table></figure><p>物理算子 open 函数设计：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// main_tuple 涉及到复杂子查询</span><br><span class="hljs-function">RC <span class="hljs-title">UpdatePhysicalOperator::open</span><span class="hljs-params">(Trx *trx, <span class="hljs-type">const</span> Tuple *main_tuple)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (children_.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-keyword">return</span> RC::SUCCESS;<br>  &#125;<br><br>  std::unique_ptr&lt;PhysicalOperator&gt; &amp;child = children_[<span class="hljs-number">0</span>];<br><br>  <span class="hljs-comment">// 调用子算子的 open 函数</span><br>  RC rc = child-&gt;<span class="hljs-built_in">open</span>(trx, main_tuple);<br>  <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to open child operator: %s&quot;</span>, <span class="hljs-built_in">strrc</span>(rc));<br>    <span class="hljs-keyword">return</span> rc;<br>  &#125;<br><br>  trx_ = trx;<br><br>  <span class="hljs-comment">// 收集全部元组</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">OB_SUCC</span>(rc = child-&gt;<span class="hljs-built_in">next</span>(main_tuple))) &#123;<br>    Tuple *tuple = child-&gt;<span class="hljs-built_in">current_tuple</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == tuple) &#123;<br>      <span class="hljs-keyword">return</span> rc;<br>    &#125;<br><br>    RowTuple *row_tuple = <span class="hljs-built_in">static_cast</span>&lt;RowTuple *&gt;(tuple);<br>    Record &amp;record = row_tuple-&gt;<span class="hljs-built_in">record</span>();<br>    records_.<span class="hljs-built_in">emplace_back</span>(std::<span class="hljs-built_in">move</span>(record));<br>  &#125;<br><br>  child-&gt;<span class="hljs-built_in">close</span>();<br><br>  <span class="hljs-keyword">if</span> (records_.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;no records to update&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 将这些元组数据拷贝到一个新数组中，用于回滚</span><br>  std::vector&lt;<span class="hljs-type">char</span> *&gt; backup_datas;<br>  <span class="hljs-keyword">for</span> (Record &amp;record : records_) &#123;<br>    Record backup_record;<br>    <span class="hljs-type">char</span> *old_data = record.<span class="hljs-built_in">data</span>();<br>    <span class="hljs-type">char</span> *backup_data = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(record.<span class="hljs-built_in">len</span>());<br>    <span class="hljs-built_in">memcpy</span>(backup_data, old_data, record.<span class="hljs-built_in">len</span>());<br><br>    backup_datas.<span class="hljs-built_in">push_back</span>(backup_data);<br>  &#125;<br><br>  <span class="hljs-type">size_t</span> update_num = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 先收集记录再更新</span><br>  <span class="hljs-keyword">for</span> (Record &amp;record : records_) &#123;<br>    rc = trx_-&gt;<span class="hljs-built_in">update_records</span>(table_, record, update_map_);<br>    ++update_num;<br>    <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) &#123;<br>      <span class="hljs-comment">// 如果更新失败，需要回滚，重新将修改过的元组复原</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">int</span>)update_num; ++i) &#123;<br>        <span class="hljs-type">char</span> *backup_data = backup_datas[i];<br>        Record &amp;record = records_[i];<br><br>        record.<span class="hljs-built_in">set_data</span>(backup_data);<br>        table_-&gt;<span class="hljs-built_in">record_handler</span>()-&gt;<span class="hljs-built_in">update_record</span>(&amp;record);<br>      &#125;<br>      <span class="hljs-keyword">return</span> rc;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>update 算子一般没有上层算子，所以不需要 next 函数，open 函数中调用了子算子的 close 函数，所以也不需要 close 函数。但理论上子算子的 close 函数放到 update 算子的 close 函数中会更好。<br>不过 delete 算子中也是这么写的，所以此处不修改了。</p><h3 id="expression"><a href="#expression" class="headerlink" title="expression"></a>expression</h3><p><img src="/img/expression.png"></p><h4 id="将万物都改成-expression-的过程"><a href="#将万物都改成-expression-的过程" class="headerlink" title="将万物都改成 expression 的过程"></a>将万物都改成 expression 的过程</h4><p>1.将谓词语句的 value&#x2F;field op value&#x2F;field 结构改成 expression op expression<br>2.初始的 FilterObj 中的 expression 只能是 value&#x2F;field，扩展使得 expression 可以是任何类型</p><p>之前提到过，在 select 语句中，会将查询的表达式进行绑定，例如将 UnboundField 绑定为 Field。在 Filter 部分，如果想要支持任何类型的 expression，也需要绑定的环节。miniob 初始的框架只包含了对 UnboundField 的绑定，<br>也即只完成了通过名字寻找特定域的功能。</p><p>理论上，应该模仿 select 语句的绑定，使用 ExpressionBinder 类来完成绑定的行为，但当时写的过于潦草，采用了纯粹的 switch 来完成。例如在下面的代码中完成了对表达式 expr 的绑定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// use_flag 是弃用的(时间关系未删除)，alias_map 为别名部分，table_map 为复杂子查询中的传递情况</span><br><span class="hljs-comment">// expr 是需要绑定的表达式，也是一条谓词语句的一端</span><br><span class="hljs-function">RC <span class="hljs-title">FilterStmt::bind_filter_expr</span><span class="hljs-params">(Db *db, Table *default_table, std::unordered_map&lt;std::string, Table *&gt; *tables, unique_ptr&lt;Expression&gt; &amp;expr,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-type">bool</span> &amp;use_flag, std::unordered_map&lt;string, string&gt; alias_map, std::unordered_map&lt;string, Table *&gt; table_map)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (expr == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br><br>  <span class="hljs-comment">// TODO 直接使用 expression_binder 中的函数进行</span><br><br>  <span class="hljs-comment">// 根据表达式的不同类型需要进行不同的操作</span><br>  <span class="hljs-keyword">switch</span> (expr-&gt;<span class="hljs-built_in">type</span>()) &#123;<br>    <span class="hljs-keyword">case</span> ExprType::VALUE: &#123;<br>      Value value;<br>      RC rc = expr-&gt;<span class="hljs-built_in">try_get_value</span>(value);<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>      <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">attr_type</span>() == AttrType::DATE &amp;&amp; !DateType::<span class="hljs-built_in">check_date</span>(&amp;value)) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ExprType::VALUELIST: &#123;<br>      std::vector&lt;Value&gt; value_list;<br>      RC rc = expr-&gt;<span class="hljs-built_in">get_value_list</span>(value_list);<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : value_list)<br>        <span class="hljs-keyword">if</span> (it.<span class="hljs-built_in">attr_type</span>() == AttrType::DATE &amp;&amp; !DateType::<span class="hljs-built_in">check_date</span>(&amp;it)) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ExprType::SUBQUERY: &#123;<br>      <span class="hljs-keyword">return</span> RC::SUCCESS;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ExprType::UNBOUND_FIELD: &#123;<br>      Table *table = <span class="hljs-literal">nullptr</span>;<br>      <span class="hljs-type">const</span> FieldMeta *field = <span class="hljs-literal">nullptr</span>;<br>      RC rc = <span class="hljs-built_in">get_table_and_field</span>(db, default_table, tables, expr.<span class="hljs-built_in">get</span>(), table, field, use_flag, alias_map, table_map);<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>      expr = std::<span class="hljs-built_in">make_unique</span>&lt;FieldExpr&gt;(table, field);<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ExprType::ARITHMETIC: &#123;<br>      RC rc = RC::SUCCESS;<br>      ArithmeticExpr *arith_expr = <span class="hljs-built_in">static_cast</span>&lt;ArithmeticExpr *&gt;(expr.<span class="hljs-built_in">get</span>());<br>      <span class="hljs-keyword">if</span> (arith_expr-&gt;<span class="hljs-built_in">left</span>() != <span class="hljs-literal">nullptr</span>) &#123;<br>        rc = <span class="hljs-built_in">bind_filter_expr</span>(db, default_table, tables, arith_expr-&gt;<span class="hljs-built_in">left</span>(), use_flag, alias_map, table_map);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>      <span class="hljs-keyword">if</span> (arith_expr-&gt;<span class="hljs-built_in">right</span>() != <span class="hljs-literal">nullptr</span>) &#123;<br>        rc = <span class="hljs-built_in">bind_filter_expr</span>(db, default_table, tables, arith_expr-&gt;<span class="hljs-built_in">right</span>(), use_flag, alias_map, table_map);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ExprType::VECFUNC: &#123;<br>      RC rc = RC::SUCCESS;<br>      VecFuncExpr *vec_func_expr = <span class="hljs-built_in">static_cast</span>&lt;VecFuncExpr *&gt;(expr.<span class="hljs-built_in">get</span>());<br>      <span class="hljs-keyword">if</span> (vec_func_expr-&gt;<span class="hljs-built_in">child_left</span>() != <span class="hljs-literal">nullptr</span>) &#123;<br>        rc = <span class="hljs-built_in">bind_filter_expr</span>(db, default_table, tables, vec_func_expr-&gt;<span class="hljs-built_in">child_left</span>(), use_flag, alias_map, table_map);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>      <span class="hljs-keyword">if</span> (vec_func_expr-&gt;<span class="hljs-built_in">child_right</span>() != <span class="hljs-literal">nullptr</span>) &#123;<br>        rc = <span class="hljs-built_in">bind_filter_expr</span>(db, default_table, tables, vec_func_expr-&gt;<span class="hljs-built_in">child_right</span>(), use_flag, alias_map, table_map);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ExprType::UNBOUND_AGGREGATION: &#123;<br>      RC rc = RC::SUCCESS;<br>      <span class="hljs-keyword">auto</span> unbound_aggregate_expr = <span class="hljs-built_in">static_cast</span>&lt;UnboundAggregateExpr *&gt;(expr.<span class="hljs-built_in">get</span>());<br>      string name = unbound_aggregate_expr-&gt;<span class="hljs-built_in">name</span>();<br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *aggregate_name = unbound_aggregate_expr-&gt;<span class="hljs-built_in">aggregate_name</span>();<br><br>      AggregateExpr::Type aggregate_type;<br>      rc = AggregateExpr::<span class="hljs-built_in">type_from_string</span>(aggregate_name, aggregate_type);<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br><br>      unique_ptr&lt;Expression&gt; &amp;child_expr = unbound_aggregate_expr-&gt;<span class="hljs-built_in">child</span>();<br><br>      <span class="hljs-keyword">if</span> (child_expr == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br><br>      <span class="hljs-keyword">if</span> (child_expr-&gt;<span class="hljs-built_in">type</span>() == ExprType::STAR &amp;&amp; aggregate_type == AggregateExpr::Type::COUNT) &#123;<br>        ValueExpr *value_expr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ValueExpr</span>(<span class="hljs-built_in">Value</span>(<span class="hljs-number">1</span>));<br>        child_expr.<span class="hljs-built_in">reset</span>(value_expr);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        rc = <span class="hljs-built_in">bind_filter_expr</span>(db, default_table, tables, child_expr, use_flag, alias_map, table_map);<br>        <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>      &#125;<br><br>      <span class="hljs-comment">// TODO 校验聚合表达式</span><br>      expr = <span class="hljs-built_in">make_unique</span>&lt;AggregateExpr&gt;(aggregate_type, std::<span class="hljs-built_in">move</span>(child_expr));<br>      expr-&gt;<span class="hljs-built_in">set_name</span>(name);<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，FilterObj 也需要改成 expression，而不是之前的 field&#x2F;value 模式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FilterObj</span> &#123;<br>  std::unique_ptr&lt;Expression&gt; expr;<br>  <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(FilterObj &amp;obj) &#123; <span class="hljs-keyword">this</span>-&gt;expr = std::<span class="hljs-built_in">move</span>(obj.expr); &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(std::unique_ptr&lt;Expression&gt; expr)</span> </span>&#123; <span class="hljs-keyword">this</span>-&gt;expr = std::<span class="hljs-built_in">move</span>(expr); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 yacc 中，也需要进行修改，condition 部分需要改成左右都为 expression。其中虽然我们将子查询也设计成了表达式，但是在解析的时候，子查询并不算为 expression，否则会出现冲突。<br>所以此处我们先通过 sub_select_stmt 来识别，在后面将其转化为 expression，从而和其他 expression 一起处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C++">expression comp_op<br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> ConditionSqlNode;<br>      $$-&gt;left_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;right_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;comp = $<span class="hljs-number">2</span>;<br>      $$-&gt;left_expression = $<span class="hljs-number">1</span>;<br>      $$-&gt;right_expression = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ValueExpr</span>(<span class="hljs-built_in">Value</span>(<span class="hljs-number">114514</span>));<br>    &#125;<br>    | expression comp_op sub_select_stmt<br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> ConditionSqlNode;<br>      $$-&gt;left_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;right_is_sub_query = <span class="hljs-literal">true</span>;<br>      $$-&gt;comp = $<span class="hljs-number">2</span>;<br>      $$-&gt;left_expression = $<span class="hljs-number">1</span>;<br>      $$-&gt;right_sub_query = $<span class="hljs-number">3</span>;<br>      $$-&gt;right_expression = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    | sub_select_stmt comp_op sub_select_stmt<br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> ConditionSqlNode;<br>      $$-&gt;left_is_sub_query = <span class="hljs-literal">true</span>;<br>      $$-&gt;right_is_sub_query = <span class="hljs-literal">true</span>;<br>      $$-&gt;comp = $<span class="hljs-number">2</span>;<br>      $$-&gt;left_sub_query = $<span class="hljs-number">1</span>;<br>      $$-&gt;left_expression = <span class="hljs-literal">nullptr</span>;<br>      $$-&gt;right_sub_query = $<span class="hljs-number">3</span>;<br>      $$-&gt;right_expression = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    | sub_select_stmt comp_op expression<br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> ConditionSqlNode;<br>      $$-&gt;left_is_sub_query = <span class="hljs-literal">true</span>;<br>      $$-&gt;right_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;comp = $<span class="hljs-number">2</span>;<br>      $$-&gt;left_sub_query = $<span class="hljs-number">1</span>;<br>      $$-&gt;left_expression = <span class="hljs-literal">nullptr</span>;<br>      $$-&gt;right_expression = $<span class="hljs-number">3</span>;<br>    &#125;<br>    | expression comp_op expression<br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> ConditionSqlNode;<br>      $$-&gt;left_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;right_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;comp = $<span class="hljs-number">2</span>;<br>      $$-&gt;left_expression = $<span class="hljs-number">1</span>;<br>      $$-&gt;right_expression = $<span class="hljs-number">3</span>;<br>    &#125;<br>    | comp_op sub_select_stmt<br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> ConditionSqlNode;<br>      $$-&gt;left_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;right_is_sub_query = <span class="hljs-literal">true</span>;<br>      $$-&gt;right_sub_query = $<span class="hljs-number">2</span>;<br>      $$-&gt;comp = $<span class="hljs-number">1</span>;<br>      $$-&gt;left_expression = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ValueExpr</span>(<span class="hljs-built_in">Value</span>(<span class="hljs-number">114514</span>));<br>    &#125;<br>    | expression comp_op LBRACE value value_list RBRACE %prec HIGHER_THAN_EXPRESSION<br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> ConditionSqlNode;<br>      $$-&gt;left_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;right_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;comp = $<span class="hljs-number">2</span>;<br>      $$-&gt;left_expression = $<span class="hljs-number">1</span>;<br>      $<span class="hljs-number">5</span>-&gt;<span class="hljs-built_in">push_back</span>(*$<span class="hljs-number">4</span>);<br>      $$-&gt;right_expression = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ValueListExpr</span>(*$<span class="hljs-number">5</span>);<br>    &#125;<br>    ;<br></code></pre></td></tr></table></figure><p>在后面的日子中，我们将能改的都改成了 expression，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 表达式类型</span><br><span class="hljs-comment"> * @ingroup Expression</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">ExprType</span> &#123;<br>  NONE,<br>  STAR,                 <span class="hljs-comment">///&lt; 星号，表示所有字段</span><br>  UNBOUND_FIELD,        <span class="hljs-comment">///&lt; 未绑定的字段，需要在resolver阶段解析为FieldExpr</span><br>  UNBOUND_TABLE,        <span class="hljs-comment">///&lt; 未绑定的表明，需要在resolver阶段提取别名和原名</span><br>  UNBOUND_AGGREGATION,  <span class="hljs-comment">///&lt; 未绑定的聚合函数，需要在resolver阶段解析为AggregateExpr</span><br><br>  ALIAS,        <span class="hljs-comment">///&lt; 别名</span><br>  FIELD,        <span class="hljs-comment">///&lt; 字段。在实际执行时，根据行数据内容提取对应字段的值</span><br>  JOINTABLE,    <span class="hljs-comment">///&lt; join 字段</span><br>  ORDERBY,      <span class="hljs-comment">///&lt; order 字段</span><br>  VALUE,        <span class="hljs-comment">///&lt; 常量值</span><br>  VALUELIST,    <span class="hljs-comment">///&lt; 常量值列表</span><br>  CAST,         <span class="hljs-comment">///&lt; 需要做类型转换的表达式</span><br>  COMPARISON,   <span class="hljs-comment">///&lt; 需要做比较的表达式</span><br>  CONJUNCTION,  <span class="hljs-comment">///&lt; 多个表达式使用同一种关系(AND或OR)来联结</span><br>  ARITHMETIC,   <span class="hljs-comment">///&lt; 算术运算</span><br>  AGGREGATION,  <span class="hljs-comment">///&lt; 聚合运算</span><br>  SUBQUERY,     <span class="hljs-comment">///&lt; 子查询</span><br>  FUNC,         <span class="hljs-comment">///&lt; 函数运算</span><br>  VECFUNC,      <span class="hljs-comment">///&lt; 向量函数运算</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="修改逻辑算子生成器"><a href="#修改逻辑算子生成器" class="headerlink" title="修改逻辑算子生成器"></a>修改逻辑算子生成器</h4><p>在逻辑算子的生成过程中，原始的 miniob 会将 Filter 中的 field&#x2F;value 变成表达式，很明显现在这是多此一举，对此进行修改。</p><p>需要注意的是，当一个 STMT 创建算子之后，原来的全部 unique_ptr 都会被移动走，在子查询里，应该还会看到这句话。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">RC <span class="hljs-title">LogicalPlanGenerator::create_plan</span><span class="hljs-params">(FilterStmt *filter_stmt, unique_ptr&lt;LogicalOperator&gt; &amp;logical_operator)</span> </span>&#123;<br>  RC rc = RC::SUCCESS;<br>  std::vector&lt;unique_ptr&lt;Expression&gt;&gt; cmp_exprs;<br>  ConjunctionExpr::Type conjunction_types = ConjunctionExpr::Type::AND;<br>  <span class="hljs-type">const</span> std::vector&lt;FilterUnit *&gt; &amp;filter_units = filter_stmt-&gt;<span class="hljs-built_in">filter_units</span>();<br>  <span class="hljs-keyword">for</span> (FilterUnit *filter_unit : filter_units) &#123;<br>    FilterObj &amp;filter_obj_left = filter_unit-&gt;<span class="hljs-built_in">left</span>();<br>    FilterObj &amp;filter_obj_right = filter_unit-&gt;<span class="hljs-built_in">right</span>();<br><br>    unique_ptr&lt;Expression&gt; left = std::<span class="hljs-built_in">move</span>(filter_obj_left.expr);<br>    unique_ptr&lt;Expression&gt; right = std::<span class="hljs-built_in">move</span>(filter_obj_right.expr);<br><br>    <span class="hljs-keyword">if</span> (filter_unit-&gt;<span class="hljs-built_in">conjunction_type</span>() == <span class="hljs-number">1</span>)<br>      conjunction_types = ConjunctionExpr::Type::AND;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (filter_unit-&gt;<span class="hljs-built_in">conjunction_type</span>() == <span class="hljs-number">2</span>)<br>      conjunction_types = ConjunctionExpr::Type::OR;<br><br>    <span class="hljs-type">bool</span> need_value_cast = left-&gt;<span class="hljs-built_in">value_type</span>() != AttrType::TUPLES &amp;&amp; right-&gt;<span class="hljs-built_in">value_type</span>() != AttrType::TUPLES &amp;&amp; left-&gt;<span class="hljs-built_in">type</span>() != ExprType::VALUELIST &amp;&amp;<br>                           right-&gt;<span class="hljs-built_in">type</span>() != ExprType::VALUELIST &amp;&amp; filter_unit-&gt;<span class="hljs-built_in">comp</span>() != CompOp::XXX_IS_NULL &amp;&amp;<br>                           filter_unit-&gt;<span class="hljs-built_in">comp</span>() != CompOp::XXX_IS_NOT_NULL;<br><br>    <span class="hljs-comment">// 如果左右两边的类型不一致，需要先计算转换开销，再进行隐式类型转换，同时要排除有子查询的情况</span><br>    <span class="hljs-keyword">if</span> (need_value_cast) &#123;<br>      Value left_value, right_value;<br>      left-&gt;<span class="hljs-built_in">try_get_value</span>(left_value);<br>      right-&gt;<span class="hljs-built_in">try_get_value</span>(right_value);<br>      <span class="hljs-keyword">if</span> (!left_value.<span class="hljs-built_in">get_null</span>() &amp;&amp; !right_value.<span class="hljs-built_in">get_null</span>() &amp;&amp; left-&gt;<span class="hljs-built_in">value_type</span>() != right-&gt;<span class="hljs-built_in">value_type</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> left_to_right_cost = <span class="hljs-built_in">implicit_cast_cost</span>(left-&gt;<span class="hljs-built_in">value_type</span>(), right-&gt;<span class="hljs-built_in">value_type</span>());<br>        <span class="hljs-keyword">auto</span> right_to_left_cost = <span class="hljs-built_in">implicit_cast_cost</span>(right-&gt;<span class="hljs-built_in">value_type</span>(), left-&gt;<span class="hljs-built_in">value_type</span>());<br>        <span class="hljs-keyword">if</span> (left_to_right_cost &lt;= right_to_left_cost &amp;&amp; left_to_right_cost != INT32_MAX) &#123;<br>          ExprType left_type = left-&gt;<span class="hljs-built_in">type</span>();<br><br>          <span class="hljs-comment">// 特殊判断，如果为 INTS 和 CHARS 比较大小，均转换成 FLOATS 类型</span><br>          unique_ptr&lt;CastExpr&gt; cast_expr;<br>          <span class="hljs-keyword">if</span> (left-&gt;<span class="hljs-built_in">value_type</span>() == AttrType::CHARS &amp;&amp; right-&gt;<span class="hljs-built_in">value_type</span>() == AttrType::INTS)<br>            cast_expr = <span class="hljs-built_in">make_unique</span>&lt;CastExpr&gt;(std::<span class="hljs-built_in">move</span>(left), AttrType::FLOATS);<br>          <span class="hljs-keyword">else</span><br>            cast_expr = <span class="hljs-built_in">make_unique</span>&lt;CastExpr&gt;(std::<span class="hljs-built_in">move</span>(left), right-&gt;<span class="hljs-built_in">value_type</span>());<br>          <span class="hljs-keyword">if</span> (left_type == ExprType::VALUE) &#123;<br>            Value left_val;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">OB_FAIL</span>(rc = cast_expr-&gt;<span class="hljs-built_in">try_get_value</span>(left_val))) &#123;<br>              <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to get value from left child&quot;</span>, <span class="hljs-built_in">strrc</span>(rc));<br>              <span class="hljs-keyword">return</span> rc;<br>            &#125;<br>            left = <span class="hljs-built_in">make_unique</span>&lt;ValueExpr&gt;(left_val);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = std::<span class="hljs-built_in">move</span>(cast_expr);<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right_to_left_cost &lt; left_to_right_cost &amp;&amp; right_to_left_cost != INT32_MAX) &#123;<br>          ExprType right_type = right-&gt;<span class="hljs-built_in">type</span>();<br><br>          <span class="hljs-comment">// 特殊判断，如果为 INTS 和 CHARS 比较大小，均转换成 FLOATS 类型</span><br>          unique_ptr&lt;CastExpr&gt; cast_expr;<br>          <span class="hljs-keyword">if</span> (left-&gt;<span class="hljs-built_in">value_type</span>() == AttrType::INTS &amp;&amp; right-&gt;<span class="hljs-built_in">value_type</span>() == AttrType::CHARS)<br>            cast_expr = <span class="hljs-built_in">make_unique</span>&lt;CastExpr&gt;(std::<span class="hljs-built_in">move</span>(right), AttrType::FLOATS);<br>          <span class="hljs-keyword">else</span><br>            cast_expr = <span class="hljs-built_in">make_unique</span>&lt;CastExpr&gt;(std::<span class="hljs-built_in">move</span>(right), left-&gt;<span class="hljs-built_in">value_type</span>());<br><br>          <span class="hljs-keyword">if</span> (right_type == ExprType::VALUE) &#123;<br>            Value right_val;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">OB_FAIL</span>(rc = cast_expr-&gt;<span class="hljs-built_in">try_get_value</span>(right_val))) &#123;<br>              <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to get value from right child&quot;</span>, <span class="hljs-built_in">strrc</span>(rc));<br>              <span class="hljs-keyword">return</span> rc;<br>            &#125;<br>            right = <span class="hljs-built_in">make_unique</span>&lt;ValueExpr&gt;(right_val);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = std::<span class="hljs-built_in">move</span>(cast_expr);<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (filter_unit-&gt;<span class="hljs-built_in">comp</span>() == CompOp::LIKE_XXX || filter_unit-&gt;<span class="hljs-built_in">comp</span>() == CompOp::NOT_LIKE_XXX) &#123;<br>          ExprType right_type = right-&gt;<span class="hljs-built_in">type</span>();<br><br>          <span class="hljs-comment">// 如果执行LIKE运算符，把右边转化成CHARS类型</span><br>          unique_ptr&lt;CastExpr&gt; cast_expr;<br>          cast_expr = <span class="hljs-built_in">make_unique</span>&lt;CastExpr&gt;(std::<span class="hljs-built_in">move</span>(right), AttrType::CHARS);<br><br>          <span class="hljs-keyword">if</span> (right_type == ExprType::VALUE) &#123;<br>            Value right_val;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">OB_FAIL</span>(rc = cast_expr-&gt;<span class="hljs-built_in">try_get_value</span>(right_val))) &#123;<br>              <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to get value from right child&quot;</span>, <span class="hljs-built_in">strrc</span>(rc));<br>              <span class="hljs-keyword">return</span> rc;<br>            &#125;<br>            right = <span class="hljs-built_in">make_unique</span>&lt;ValueExpr&gt;(right_val);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = std::<span class="hljs-built_in">move</span>(cast_expr);<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          rc = RC::UNSUPPORTED;<br>          <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;unsupported cast from %s to %s&quot;</span>, <span class="hljs-built_in">attr_type_to_string</span>(left-&gt;<span class="hljs-built_in">value_type</span>()), <span class="hljs-built_in">attr_type_to_string</span>(right-&gt;<span class="hljs-built_in">value_type</span>()));<br>          <span class="hljs-keyword">return</span> rc;<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    ComparisonExpr *cmp_expr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ComparisonExpr</span>(filter_unit-&gt;<span class="hljs-built_in">comp</span>(), std::<span class="hljs-built_in">move</span>(left), std::<span class="hljs-built_in">move</span>(right));<br><br>    cmp_exprs.<span class="hljs-built_in">emplace_back</span>(cmp_expr);<br>  &#125;<br><br>  unique_ptr&lt;PredicateLogicalOperator&gt; predicate_oper;<br>  <span class="hljs-keyword">if</span> (!cmp_exprs.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-function">unique_ptr&lt;ConjunctionExpr&gt; <span class="hljs-title">conjunction_expr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> ConjunctionExpr(conjunction_types, cmp_exprs))</span></span>;<br>    predicate_oper = <span class="hljs-built_in">unique_ptr</span>&lt;PredicateLogicalOperator&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">PredicateLogicalOperator</span>(std::<span class="hljs-built_in">move</span>(conjunction_expr)));<br>  &#125;<br><br>  logical_operator = std::<span class="hljs-built_in">move</span>(predicate_oper);<br>  <span class="hljs-keyword">return</span> rc;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LogicalPlanGenerator::implicit_cast_cost</span><span class="hljs-params">(AttrType from, AttrType to)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (from == to) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> DataType::<span class="hljs-built_in">type_instance</span>(from)-&gt;<span class="hljs-built_in">cast_cost</span>(to);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="vector-basic"><a href="#vector-basic" class="headerlink" title="vector_basic"></a>vector_basic</h3><p><img src="/img/vector_basic.png"></p><p>相对简单的一道题目，需要添加一种数据类型：VECTOR</p><p>我们采取的方式为，对于 ‘[1, 2, 3, 4]’ 这样的向量，先以字符串的形式输入进来，在 Value 的构造函数中进行格式检验，如果符合向量的格式，那么将其转化为向量存储，否则以字符串的方式存储。</p><p>有些边角的东西没有体现在下面的描述中，包括：插入向量时的长度不匹配问题 + 创建表格时的 VECTOR 长度检验等</p><h4 id="Value-类的完善"><a href="#Value-类的完善" class="headerlink" title="Value 类的完善"></a>Value 类的完善</h4><p>首先，由于向量一定是 float 类型，所以实际的存储形式为 vector<float>。Value 中有个字段 len，表示 Value 的长度，注意这个长度是占用空间的长度，对于 vector 来说，这个长度是 vector.size() * 4。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// vector part</span><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// 判断一个字符串是否为向量形式</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">isValidFormat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *input)</span></span>;<br>  <span class="hljs-comment">// 判断一个字符串是否为数字，避免 [1, a, 2] 这样的例子</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">isValidNumber</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;s)</span></span>;<br>  <span class="hljs-comment">// 将字符串转化为 vector，如果字符串不合法，返回 FAILURE</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> RC <span class="hljs-title">string_to_vector</span><span class="hljs-params">(string str, vector&lt;<span class="hljs-type">float</span>&gt; &amp;result)</span></span>;<br><br>  <span class="hljs-comment">// set and get</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_vector</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">float</span>&gt; value_vector)</span></span>;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">get_vector</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">get_vector_item</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_vector_size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  std::vector&lt;<span class="hljs-type">float</span>&gt; value_vector_;<br></code></pre></td></tr></table></figure><p>isValidFormat, isValidNumber, string_to_vector 的设计如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// vector part</span><br><br><span class="hljs-comment">// 用于检查输入字符串是否符合 vector 的格式</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Value::isValidFormat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *input)</span> </span>&#123;<br>  <span class="hljs-comment">// 检查是否为空或长度小于2（必须至少包含 &quot;[]&quot;)</span><br>  <span class="hljs-keyword">if</span> (input == <span class="hljs-literal">nullptr</span> || <span class="hljs-built_in">strlen</span>(input) &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 检查首尾是否分别为 &#x27;[&#x27; 和 &#x27;]&#x27;</span><br>  <span class="hljs-keyword">if</span> (input[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;[&#x27;</span> || input[<span class="hljs-built_in">strlen</span>(input) - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 剔除 &#x27;[&#x27; 和 &#x27;]&#x27;，从第二个字符开始检查</span><br>  <span class="hljs-function">std::string <span class="hljs-title">content</span><span class="hljs-params">(input + <span class="hljs-number">1</span>, strlen(input) - <span class="hljs-number">2</span>)</span></span>;<br><br>  <span class="hljs-comment">// 删除多余的空格</span><br>  content.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">remove</span>(content.<span class="hljs-built_in">begin</span>(), content.<span class="hljs-built_in">end</span>(), <span class="hljs-string">&#x27; &#x27;</span>), content.<span class="hljs-built_in">end</span>());<br><br>  <span class="hljs-comment">// 使用逗号分割内容</span><br>  <span class="hljs-function">std::istringstream <span class="hljs-title">ss</span><span class="hljs-params">(content)</span></span>;<br>  std::string token;<br>  std::vector&lt;std::string&gt; tokens;<br><br>  <span class="hljs-comment">// 分割内容并检查每个部分</span><br>  <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(ss, token, <span class="hljs-string">&#x27;,&#x27;</span>)) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isValidNumber</span>(token)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 如果某个部分不是有效的数字，返回 false</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 所有部分都是有效的数字</span><br>&#125;<br><br><span class="hljs-comment">// 用于检查一个字符串是否是整数或浮点数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Value::isValidNumber</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;s)</span> </span>&#123;<br>  <span class="hljs-function">std::istringstream <span class="hljs-title">stream</span><span class="hljs-params">(s)</span></span>;<br>  <span class="hljs-type">float</span> number;<br>  stream &gt;&gt; number;<br>  <span class="hljs-comment">// 检查是否成功解析为数字，并且没有多余字符</span><br>  <span class="hljs-keyword">return</span> stream.<span class="hljs-built_in">eof</span>() &amp;&amp; !stream.<span class="hljs-built_in">fail</span>();<br>&#125;<br><br><span class="hljs-function">RC <span class="hljs-title">Value::string_to_vector</span><span class="hljs-params">(string str, vector&lt;<span class="hljs-type">float</span>&gt; &amp;result)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!Value::<span class="hljs-built_in">isValidFormat</span>(str.<span class="hljs-built_in">c_str</span>())) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br><br>  <span class="hljs-comment">// 剔除 &#x27;[&#x27; 和 &#x27;]&#x27;，从第二个字符开始检查</span><br>  str = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, (<span class="hljs-type">int</span>)str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>);<br><br>  <span class="hljs-comment">// 去除多余空格</span><br>  str.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">remove</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>(), <span class="hljs-string">&#x27; &#x27;</span>), str.<span class="hljs-built_in">end</span>());<br><br>  <span class="hljs-comment">// 使用逗号分割内容</span><br>  <span class="hljs-function">std::istringstream <span class="hljs-title">ss</span><span class="hljs-params">(str)</span></span>;<br>  std::string token;<br>  std::vector&lt;std::string&gt; tokens;<br><br>  <span class="hljs-comment">// 分割内容并检查每个部分</span><br>  <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(ss, token, <span class="hljs-string">&#x27;,&#x27;</span>)) &#123;<br>    result.<span class="hljs-built_in">push_back</span>(FloatType::formatFloat(std::<span class="hljs-built_in">stof</span>(token), <span class="hljs-number">2</span>));<br>  &#125;<br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来是 Value 输入为字符串的构造函数，如果发现字符串的格式为数组形式，那么转化为 VECTOR。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">Value::<span class="hljs-built_in">Value</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> len <span class="hljs-comment">/*= 0*/</span>) &#123;<br>  vector&lt;<span class="hljs-type">float</span>&gt; value_vector;<br>  RC rc = Value::<span class="hljs-built_in">string_to_vector</span>(s, value_vector);<br>  <span class="hljs-keyword">if</span> (rc == RC::SUCCESS)<br>    <span class="hljs-built_in">set_vector</span>(value_vector);<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">set_string</span>(s, len);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来是 Value 和 data 的转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Value::set_data</span><span class="hljs-params">(<span class="hljs-type">char</span> *data, <span class="hljs-type">int</span> length)</span> </span>&#123;<br>  <span class="hljs-keyword">switch</span> (attr_type_) &#123;<br>    <span class="hljs-keyword">case</span> AttrType::CHARS: &#123;<br>      <span class="hljs-built_in">set_string</span>(data, length);<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::INTS: &#123;<br>      value_.int_value_ = *(<span class="hljs-type">int</span> *)data;<br>      length_ = length;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::FLOATS: &#123;<br>      value_.float_value_ = *(<span class="hljs-type">float</span> *)data;<br>      length_ = length;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::BOOLEANS: &#123;<br>      value_.bool_value_ = *(<span class="hljs-type">int</span> *)data != <span class="hljs-number">0</span>;<br>      length_ = length;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::DATE: &#123;<br>      value_.int_value_ = *(<span class="hljs-type">int</span> *)data;<br>      length_ = length;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::VECTORS: &#123;<br>      <span class="hljs-type">size_t</span> element_size = <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br>      <span class="hljs-type">size_t</span> num_elements = length / element_size;<br><br>      <span class="hljs-comment">// 使用 memcpy 将数据复制回 vector</span><br>      value_vector_.<span class="hljs-built_in">resize</span>(num_elements);<br>      <span class="hljs-built_in">memcpy</span>(value_vector_.<span class="hljs-built_in">data</span>(), data, length);<br>      length_ = length;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::TEXT: &#123;<br>      <span class="hljs-built_in">set_text</span>(data);<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>: &#123;<br>      <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;unknown data type: %d&quot;</span>, attr_type_);<br>    &#125; <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">Value::data</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">switch</span> (attr_type_) &#123;<br>    <span class="hljs-keyword">case</span> AttrType::TEXT: &#123;<br>      <span class="hljs-keyword">return</span> value_.pointer_value_;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::CHARS: &#123;<br>      <span class="hljs-keyword">return</span> value_.pointer_value_;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::VECTORS: &#123;<br>      <span class="hljs-keyword">return</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)(value_vector_.<span class="hljs-built_in">data</span>());<br>    &#125;<br>    <span class="hljs-keyword">default</span>: &#123;<br>      <span class="hljs-keyword">return</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)&amp;value_;<br>    &#125; <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="VECTOR-的各种运算"><a href="#VECTOR-的各种运算" class="headerlink" title="VECTOR 的各种运算"></a>VECTOR 的各种运算</h4><p>在 common&#x2F;type 中，还需要完成有关 VECTOR 的各种计算、比较等。由于比较简单这里直接放上来了，不过需要注意的是，比赛要求向量的乘法是逐位相乘，也即两个向量的乘积仍为向量：[1, 2, 3] * [4, 5, 6] &#x3D; [4, 10, 18]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">VectorType::compare</span><span class="hljs-params">(<span class="hljs-type">const</span> Value &amp;left, <span class="hljs-type">const</span> Value &amp;right)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (left.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || right.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || left.<span class="hljs-built_in">get_vector_size</span>() != right.<span class="hljs-built_in">get_vector_size</span>())<br>    <span class="hljs-keyword">return</span> INT32_MAX;<br>  <span class="hljs-type">int</span> size = (<span class="hljs-type">int</span>)left.<span class="hljs-built_in">get_vector_size</span>();<br>  <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>    <span class="hljs-keyword">if</span> (left.<span class="hljs-built_in">get_vector</span>()[i] &gt; right.<span class="hljs-built_in">get_vector</span>()[i]) &#123;<br>      result = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left.<span class="hljs-built_in">get_vector</span>()[i] &lt; right.<span class="hljs-built_in">get_vector</span>()[i]) &#123;<br>      result = <span class="hljs-number">-1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function">RC <span class="hljs-title">VectorType::add</span><span class="hljs-params">(<span class="hljs-type">const</span> Value &amp;left, <span class="hljs-type">const</span> Value &amp;right, Value &amp;result)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (left.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || right.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || left.<span class="hljs-built_in">get_vector_size</span>() != right.<span class="hljs-built_in">get_vector_size</span>())<br>    <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>  <span class="hljs-type">int</span> size = (<span class="hljs-type">int</span>)left.<span class="hljs-built_in">get_vector_size</span>();<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">answer</span><span class="hljs-params">(size, <span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) answer[i] = left.<span class="hljs-built_in">get_vector</span>()[i] + right.<span class="hljs-built_in">get_vector</span>()[i];<br>  result.<span class="hljs-built_in">set_vector</span>(answer);<br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br><span class="hljs-function">RC <span class="hljs-title">VectorType::subtract</span><span class="hljs-params">(<span class="hljs-type">const</span> Value &amp;left, <span class="hljs-type">const</span> Value &amp;right, Value &amp;result)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (left.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || right.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || left.<span class="hljs-built_in">get_vector_size</span>() != right.<span class="hljs-built_in">get_vector_size</span>())<br>    <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>  <span class="hljs-type">int</span> size = (<span class="hljs-type">int</span>)left.<span class="hljs-built_in">get_vector_size</span>();<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">answer</span><span class="hljs-params">(size, <span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) answer[i] = left.<span class="hljs-built_in">get_vector</span>()[i] - right.<span class="hljs-built_in">get_vector</span>()[i];<br>  result.<span class="hljs-built_in">set_vector</span>(answer);<br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br><span class="hljs-function">RC <span class="hljs-title">VectorType::multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Value &amp;left, <span class="hljs-type">const</span> Value &amp;right, Value &amp;result)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (left.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || right.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || left.<span class="hljs-built_in">get_vector_size</span>() != right.<span class="hljs-built_in">get_vector_size</span>())<br>    <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>  <span class="hljs-type">int</span> size = (<span class="hljs-type">int</span>)left.<span class="hljs-built_in">get_vector_size</span>();<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">answer</span><span class="hljs-params">(size, <span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) answer[i] = left.<span class="hljs-built_in">get_vector</span>()[i] * right.<span class="hljs-built_in">get_vector</span>()[i];<br>  result.<span class="hljs-built_in">set_vector</span>(answer);<br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br><br><span class="hljs-function">RC <span class="hljs-title">VectorType::to_string</span><span class="hljs-params">(<span class="hljs-type">const</span> Value &amp;val, string &amp;result)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (val.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br><br>  result = <span class="hljs-string">&quot;[&quot;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : val.<span class="hljs-built_in">get_vector</span>()) &#123;<br>    it = FloatType::formatFloat(it, <span class="hljs-number">2</span>);<br>    string str = std::<span class="hljs-built_in">to_string</span>(it);<br>    str = FloatType::formatFloat_s(it, <span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// 去除后导零</span><br>    str.<span class="hljs-built_in">erase</span>(str.<span class="hljs-built_in">find_last_not_of</span>(<span class="hljs-string">&#x27;0&#x27;</span>) + <span class="hljs-number">1</span>, std::string::npos);<br>    <span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">back</span>() == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>      str.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    result += str;<br>    result += <span class="hljs-string">&#x27;,&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">int</span>)result.<span class="hljs-built_in">length</span>() &gt; <span class="hljs-number">1</span>) result.<span class="hljs-built_in">pop_back</span>();<br>  result += <span class="hljs-string">&quot;]&quot;</span>;<br><br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="vector-format"><a href="#vector-format" class="headerlink" title="vector_format"></a>vector_format</h3><p><img src="/img/vector_format.png"></p><p>题目要求不仅要识别字符串类型的向量数据，还需要识别不带引号的向量数据。我在写的时候偷懒了，直接采取 [ + value + value_list + ]，所以只需要在 yacc 中添加这一条规则即可。</p><h4 id="lex-和-yacc-完善"><a href="#lex-和-yacc-完善" class="headerlink" title="lex 和 yacc 完善"></a>lex 和 yacc 完善</h4><p>lex 需要添加左右中括号的词语：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-string">&quot;[&quot;</span>                                     <span class="hljs-built_in">RETURN_TOKEN</span>(LBRACKET);<br><span class="hljs-string">&quot;]&quot;</span>                                     <span class="hljs-built_in">RETURN_TOKEN</span>(RBRACKET);<br></code></pre></td></tr></table></figure><p>yacc 需要添加对向量变量的识别：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">value:<br>    LBRACKET value value_list RBRACKET &#123;<br>      std::vector&lt;<span class="hljs-type">float</span>&gt; nums;<br>      nums.<span class="hljs-built_in">emplace_back</span>($<span class="hljs-number">2</span>-&gt;<span class="hljs-built_in">get_float</span>());<br>      <span class="hljs-keyword">if</span>($<span class="hljs-number">3</span> != <span class="hljs-literal">nullptr</span>) &#123;<br>        std::<span class="hljs-built_in">reverse</span>($<span class="hljs-number">3</span>-&gt;<span class="hljs-built_in">begin</span>(), $<span class="hljs-number">3</span>-&gt;<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (Value value : *$<span class="hljs-number">3</span>) &#123;<br>          nums.<span class="hljs-built_in">emplace_back</span>(value.<span class="hljs-built_in">get_float</span>());<br>        &#125;<br>      &#125;<br>      $$ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Value</span>(nums);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="join-tables"><a href="#join-tables" class="headerlink" title="join-tables"></a>join-tables</h3><p><img src="/img/join_tables.png"></p><p>join-tables 所涉及的算子在初始工程已经很完善了。简单来说，对于一条 select 语句可能有多个目标表格，其中第一个目标表格为主表格，后面的表格会跟主表格一并做笛卡尔积。创建算子的时候，第一个表格会创建 TableGet 相关算子，后面的表格会创建 JoinTable 相关算子。</p><p>对于 INNERJOIN，ON 中定义的谓词逻辑和 WHERE 中定义的谓词逻辑是完全平等的，所以，对于 ON 中的全部谓词逻辑，我们只需要将其视作 WHERE 中通过 AND 连结词连在一起的即可。</p><p>对于 join 部分，将其视作一个表达式，原因见 expression。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// *********************************************************</span><br><span class="hljs-comment">// * 表格连接表达式</span><br><span class="hljs-comment">// *</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JoinTableExpr</span> : <span class="hljs-keyword">public</span> Expression &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">JoinTableExpr</span>(std::vector&lt;ConditionSqlNode&gt; conditions, unique_ptr&lt;Expression&gt; child) : <span class="hljs-built_in">conditions_</span>(conditions), <span class="hljs-built_in">child_</span>(std::<span class="hljs-built_in">move</span>(child)) &#123;&#125;<br>  <span class="hljs-built_in">JoinTableExpr</span>(std::vector&lt;ConditionSqlNode&gt; conditions, Expression *child) : <span class="hljs-built_in">conditions_</span>(conditions), <span class="hljs-built_in">child_</span>(child) &#123;&#125;<br><br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">JoinTableExpr</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-function">ExprType <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> ExprType::JOINTABLE; &#125;<br>  <span class="hljs-function">AttrType <span class="hljs-title">value_type</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> AttrType::UNDEFINED; &#125;<br><br>  <span class="hljs-function">RC <span class="hljs-title">get_value</span><span class="hljs-params">(<span class="hljs-type">const</span> Tuple &amp;tuple, Value &amp;value)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> RC::INTERNAL; &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">const</span> std::vector&lt;ConditionSqlNode&gt; <span class="hljs-title">conditions</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> conditions_; &#125;<br>  <span class="hljs-function"><span class="hljs-type">const</span> std::unique_ptr&lt;Expression&gt; &amp;<span class="hljs-title">child</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> child_; &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  std::vector&lt;ConditionSqlNode&gt; conditions_;<br>  std::unique_ptr&lt;Expression&gt; child_;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="lex-和-yacc-的完善"><a href="#lex-和-yacc-的完善" class="headerlink" title="lex 和 yacc 的完善"></a>lex 和 yacc 的完善</h4><p>lex 需要完善对 JOIN&#x2F;INNER JOIN&#x2F;ON 的识别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">JOIN|INNER[ \t]+<span class="hljs-function">JOIN                    <span class="hljs-title">RETURN_TOKEN</span><span class="hljs-params">(INNER_JOIN)</span></span>;<br><span class="hljs-function">ON                                      <span class="hljs-title">RETURN_TOKEN</span><span class="hljs-params">(ON)</span></span>;<br></code></pre></td></tr></table></figure><p>对于 join 子句的部分，创建一个 expression 数组，数组的 expression 类型为 JoinTableExpr，每一个 JoinTableExpr 包含 join 的表格以及谓词逻辑语句。</p><p>select_stmt 也需要加入 join_list 部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++">join_list:<br>    <span class="hljs-comment">/* empty */</span><br>    &#123;<br>      $$ = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    | INNER_JOIN relation ON condition_list join_list &#123;<br>      <span class="hljs-keyword">if</span> ($<span class="hljs-number">5</span> != <span class="hljs-literal">nullptr</span>) &#123;<br>        $$ = $<span class="hljs-number">5</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        $$ = <span class="hljs-keyword">new</span> std::vector&lt;std::unique_ptr&lt;Expression&gt;&gt;;<br>      &#125;<br>      $$-&gt;<span class="hljs-built_in">emplace_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">JoinTableExpr</span>(*$<span class="hljs-number">4</span>, $<span class="hljs-number">2</span>));<br>    &#125;<br>    ;<br></code></pre></td></tr></table></figure><h4 id="select-stmt-的完善"><a href="#select-stmt-的完善" class="headerlink" title="select_stmt 的完善"></a>select_stmt 的完善</h4><p>在创建 SelectStmt 时，需要将 join 的表格和谓词语句添加到 select 语句中的表格列表和谓词语句列表中。谓词语句顺序无所谓，但是表格的顺序会影响输出表头的顺序，所以需要严格按照 JOIN 出现的顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// *****************************************************************************</span><br>  <span class="hljs-comment">// * 将节点中的 join 添加到 conditions 以及 relations 当中</span><br>  <span class="hljs-comment">// *    在之后的处理中，如果查询的表格有多个，就会计算全部表格的笛卡尔积</span><br>  <span class="hljs-comment">// *    join 等价于先求笛卡尔积，然后进行选择运算</span><br>  <span class="hljs-comment">// *    所以需要将选择条件也加进 conditions 中(目前全是 AND 运算，所以可以这么处理)</span><br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; select_sql.join.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    JoinTableExpr *join_table_expr = <span class="hljs-built_in">static_cast</span>&lt;JoinTableExpr *&gt;(select_sql.join[i].<span class="hljs-built_in">get</span>());<br>    UnboundTableExpr *table_expr = <span class="hljs-built_in">static_cast</span>&lt;UnboundTableExpr *&gt;(join_table_expr-&gt;<span class="hljs-built_in">child</span>().<span class="hljs-built_in">get</span>());<br>    unique_ptr&lt;Expression&gt; temp = <span class="hljs-built_in">make_unique</span>&lt;UnboundTableExpr&gt;(table_expr-&gt;<span class="hljs-built_in">table_name</span>(), table_expr-&gt;<span class="hljs-built_in">table_alias</span>());<br>    select_sql.relations.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">move</span>(temp));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> condition : join_table_expr-&gt;<span class="hljs-built_in">conditions</span>()) select_sql.conditions.<span class="hljs-built_in">emplace_back</span>(condition);<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p><img src="/img/null.png"></p><p>题目要求支持一种特殊的数据类型：null，它不属于任何普通类型，却又能匹配任何普通类型。</p><p>整体来说，需要完成以下内容：</p><ol><li>支持识别关键字 NULL IS NOT 等</li><li>支持创建表格时对特定域声明 NULL or NOT NULL &#x3D; default</li><li>Value 类中添加对 NULL 的管理</li><li>支持插入数据时插入 NULL，并判断合法性</li><li>支持更新数据时更新 NULL，并判断合法性</li><li>支持谓词逻辑普通运算符对 NULL 计算，以及谓词逻辑新增运算 IS NULL and IS NOT NULL</li></ol><p>额外需要考虑的一点为，Value 会被转换成 Record 写入内存，也即实际写入内存的是 01 串，而通过 01 串并不能知道这是什么类型。假设某个域类型为 INT，它可以通过表头信息知道：从该列拿出来的数据一定是 INT 类型，所以可以将 01 串按照 INT 的存储规则还原，但是对于 NULL 类型，由于其可以匹配任意类型，所以并不能通过某处记录的信息来得知拿出来的数据为 NULL 类型。</p><p>我们的处理是 bitmap 或者 写入特殊字符，使用 bitmap 会导致后面的并发 update 报错，至比赛结束仍不知道原因。不过 bitmap 无疑是最优美的解决方案。</p><blockquote><p>—- WARING  下文有狗屎 —-</p></blockquote><p>所以我们的处理方法是，对于一个 x 字节的数据，如果它的类型为 NULL，则向内存写入数据时，写入 x 字节的 ÿ，就是如此抽象。拿出数据时，首先检验 01 串是否为 x 字节的 ÿ 的 ASCII 码，<br>如果是则还原成 NULL，不是则根据表头信息等还原。</p><h4 id="支持识别关键字-NULL-IS-NOT-等"><a href="#支持识别关键字-NULL-IS-NOT-等" class="headerlink" title="支持识别关键字 NULL IS NOT 等"></a>支持识别关键字 NULL IS NOT 等</h4><p>lex 中需要添加新的词语解析</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">NULL                                    <span class="hljs-built_in">RETURN_TOKEN</span>(NULLABLE);<br>NOT<span class="hljs-selector-attr">[ \t]</span>+NULL                           <span class="hljs-built_in">RETURN_TOKEN</span>(UNNULLABLE);<br>IS<span class="hljs-selector-attr">[ \t]</span>+NULL                            <span class="hljs-built_in">RETURN_TOKEN</span>(IS_NULL);<br>IS<span class="hljs-selector-attr">[ \t]</span>+NOT+<span class="hljs-selector-attr">[ \t]</span>+NULL                  <span class="hljs-built_in">RETURN_TOKEN</span>(IS_NOT_NULL);<br></code></pre></td></tr></table></figure><h4 id="支持创建表格时对特定域声明-NULL-or-NOT-NULL-default"><a href="#支持创建表格时对特定域声明-NULL-or-NOT-NULL-default" class="headerlink" title="支持创建表格时对特定域声明 NULL or NOT NULL &#x3D; default"></a>支持创建表格时对特定域声明 NULL or NOT NULL &#x3D; default</h4><p>yacc 中需要添加新的语法解析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 运算符</span><br>comp_op:<br>    ...<br>    | IS_NULL &#123; $$ = XXX_IS_NULL; &#125;<br>    | IS_NOT_NULL &#123; $$ = XXX_IS_NOT_NULL; &#125;<br>    | NOT_LIKE &#123; $$ = NOT_LIKE_XXX; &#125;<br>    ...<br>    ;<br><span class="hljs-comment">// 创建表格时的声明</span><br>attr_def:<br>    ID type LBRACE number RBRACE null_def <br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> AttrInfoSqlNode;<br>      $$-&gt;type = (AttrType)$<span class="hljs-number">2</span>;<br>      $$-&gt;name = $<span class="hljs-number">1</span>;<br>      $$-&gt;length = $<span class="hljs-number">4</span>;<br>      $$-&gt;can_be_null = $<span class="hljs-number">6</span>;<br><br>      ...<br><br>      <span class="hljs-built_in">free</span>($<span class="hljs-number">1</span>);<br>    &#125;<br><span class="hljs-comment">// null</span><br>null_def:<br>    &#123;<br>      $$ = <span class="hljs-literal">false</span>;<br>    &#125;<br>    | NULLABLE &#123;<br>      $$ = <span class="hljs-literal">true</span>;<br>    &#125;<br>    | UNNULLABLE &#123;<br>      $$ = <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="Value-类中添加对-NULL-的管理"><a href="#Value-类中添加对-NULL-的管理" class="headerlink" title="Value 类中添加对 NULL 的管理"></a>Value 类中添加对 NULL 的管理</h4><p>Value 中添加标志位 is_null_，用于判断 Value 是否为 NULL。同时还需要维护各种构造函数，拷贝函数，运算符重载有关 NULL 的问题。同时 NULL 数据转化为 char * 写入内存的<br>时候要转换成若干个 ÿ。</p><h4 id="支持插入数据时插入-NULL，并判断合法性"><a href="#支持插入数据时插入-NULL，并判断合法性" class="headerlink" title="支持插入数据时插入 NULL，并判断合法性"></a>支持插入数据时插入 NULL，并判断合法性</h4><p>在将 Value 转化为 Record 时，需要额外做一步判断。如果插入的数据为 NULL 且该域不允许为 NULL，返回 FAILURE。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">RC <span class="hljs-title">Table::make_record</span><span class="hljs-params">(<span class="hljs-type">int</span> value_num, <span class="hljs-type">const</span> Value *values, Record &amp;record)</span> </span>&#123;<br>  RC rc = RC::SUCCESS;<br>  <span class="hljs-comment">// 检查属性数量是否一致</span><br>  <span class="hljs-keyword">if</span> (value_num + table_meta_.<span class="hljs-built_in">sys_field_num</span>() != table_meta_.<span class="hljs-built_in">field_num</span>()) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;Input values don&#x27;t match the table&#x27;s schema, table name:%s&quot;</span>, table_meta_.<span class="hljs-built_in">name</span>());<br>    <span class="hljs-keyword">return</span> RC::SCHEMA_FIELD_MISSING;<br>  &#125;<br><br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> normal_field_start_index = table_meta_.<span class="hljs-built_in">sys_field_num</span>();<br>  <span class="hljs-comment">// 复制所有字段的值</span><br>  <span class="hljs-type">int</span> record_size = table_meta_.<span class="hljs-built_in">record_size</span>();<br>  <span class="hljs-type">char</span> *record_data = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(record_size);<br>  <span class="hljs-built_in">memset</span>(record_data, <span class="hljs-number">0</span>, record_size);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; value_num &amp;&amp; <span class="hljs-built_in">OB_SUCC</span>(rc); i++) &#123;<br>    <span class="hljs-type">const</span> FieldMeta *field = table_meta_.<span class="hljs-built_in">field</span>(i + normal_field_start_index);<br>    Value value = values[i];<br><br>    <span class="hljs-comment">// 当插入数据 NULL 时，做一次检验</span><br>    <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">get_null</span>()) &#123;<br>      <span class="hljs-keyword">if</span> (field-&gt;<span class="hljs-built_in">can_be_null</span>() == <span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to insert NULL to NOT_NULL field&quot;</span>);<br>        <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>      &#125;<br>      rc = <span class="hljs-built_in">set_value_to_record</span>(record_data, value, field, i);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (field-&gt;<span class="hljs-built_in">type</span>() != value.<span class="hljs-built_in">attr_type</span>()) &#123;<br>      Value real_value;<br>      rc = Value::<span class="hljs-built_in">cast_to</span>(value, field-&gt;<span class="hljs-built_in">type</span>(), real_value);<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">OB_FAIL</span>(rc)) &#123;<br>        <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to cast value. table name:%s,field name:%s,value:%s &quot;</span>, table_meta_.<span class="hljs-built_in">name</span>(), field-&gt;<span class="hljs-built_in">name</span>(), value.<span class="hljs-built_in">to_string</span>().<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      rc = <span class="hljs-built_in">set_value_to_record</span>(record_data, real_value, field, i);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      rc = <span class="hljs-built_in">set_value_to_record</span>(record_data, value, field, i);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">OB_FAIL</span>(rc)) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to make record. table name:%s&quot;</span>, table_meta_.<span class="hljs-built_in">name</span>());<br>    <span class="hljs-built_in">free</span>(record_data);<br>    <span class="hljs-keyword">return</span> rc;<br>  &#125;<br><br>  record.<span class="hljs-built_in">set_data_owner</span>(record_data, record_size);<br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时转换为 Record 时，也需要考虑 NULL 的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">get_null</span>()) &#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *flag = <span class="hljs-string">&quot;ÿÿÿÿ&quot;</span>;<br>  <span class="hljs-built_in">memcpy</span>(record_data + field-&gt;<span class="hljs-built_in">offset</span>(), flag, std::<span class="hljs-built_in">min</span>(field-&gt;<span class="hljs-built_in">len</span>(), <span class="hljs-number">4</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="支持更新数据时更新-NULL，并判断合法性"><a href="#支持更新数据时更新-NULL，并判断合法性" class="headerlink" title="支持更新数据时更新 NULL，并判断合法性"></a>支持更新数据时更新 NULL，并判断合法性</h4><p>和插入数据区别不大，也是需要额外添加一层判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 检查所有更新字段是否全部有效</span><br><span class="hljs-function">RC <span class="hljs-title">Table::update_records</span><span class="hljs-params">(Record &amp;record, std::vector&lt;std::pair&lt;Value, FieldMeta&gt;&gt; update_map_)</span> </span>&#123;<br>  <span class="hljs-comment">// 遍历表格的全部域，找到目标域</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> sys_field_num = table_meta_.<span class="hljs-built_in">sys_field_num</span>();<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> user_field_num = table_meta_.<span class="hljs-built_in">field_num</span>() - sys_field_num;<br>  FieldMeta *targetFiled = <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : update_map_) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; user_field_num; i++) &#123;<br>      <span class="hljs-type">const</span> FieldMeta *field_meta = table_meta_.<span class="hljs-built_in">field</span>(sys_field_num + i);<br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *field_name = field_meta-&gt;<span class="hljs-built_in">name</span>();<br><br>      <span class="hljs-comment">// 找到目标域</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(field_name, it.second.<span class="hljs-built_in">name</span>()) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 判断 NULL 值</span><br>        <span class="hljs-keyword">if</span> (it.first.<span class="hljs-built_in">get_null</span>()) &#123;<br>          <span class="hljs-keyword">if</span> (field_meta-&gt;<span class="hljs-built_in">can_be_null</span>() == <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>        &#125;<br>        <span class="hljs-comment">// 类型匹配检查</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (field_meta-&gt;<span class="hljs-built_in">type</span>() != it.first.<span class="hljs-built_in">attr_type</span>()) &#123;<br>          Value real_value;<br>          RC rc = Value::<span class="hljs-built_in">cast_to</span>(it.first, field_meta-&gt;<span class="hljs-built_in">type</span>(), real_value);<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">OB_FAIL</span>(rc)) <span class="hljs-keyword">return</span> rc;<br>        &#125;<br><br>        <span class="hljs-comment">// 拿到目标域</span><br>        targetFiled = (FieldMeta *)field_meta;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 域存在检查</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == targetFiled) &#123;<br>      <span class="hljs-keyword">return</span> RC::SCHEMA_FIELD_NOT_EXIST;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 暂时备份旧数据</span><br>  <span class="hljs-type">char</span> *old_data = record.<span class="hljs-built_in">data</span>();<br>  <span class="hljs-type">char</span> *backup_data = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(record.<span class="hljs-built_in">len</span>());<br>  <span class="hljs-built_in">memcpy</span>(backup_data, old_data, record.<span class="hljs-built_in">len</span>());<br><br>  <span class="hljs-comment">// 所有字段均可更新，开始更新</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : update_map_) &#123;<br>    RC rc = <span class="hljs-built_in">update_record</span>(record, it.second.<span class="hljs-built_in">name</span>(), &amp;it.first);<br>    <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>  &#125;<br><br>  <span class="hljs-comment">// 如果有索引，更新索引，顺便检查如果是唯一索引，那么是否有重复</span><br>  std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span> *&gt; update_fields;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : update_map_) &#123;<br>    update_fields.<span class="hljs-built_in">push_back</span>(it.second.<span class="hljs-built_in">name</span>());<br>  &#125;<br>  Index *index = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">find_index_by_fields</span>(update_fields);<br>  <span class="hljs-comment">// 只检查多索引，单列索引交给 update_record 处理</span><br>  <span class="hljs-keyword">if</span> (index != <span class="hljs-literal">nullptr</span> &amp;&amp; update_fields.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>    RC rc = index-&gt;<span class="hljs-built_in">insert_entry</span>(record.<span class="hljs-built_in">data</span>(), &amp;record.<span class="hljs-built_in">rid</span>());<br>    <span class="hljs-keyword">if</span> (rc != RC::SUCCESS &amp;&amp; <span class="hljs-built_in">strcmp</span>(old_data, backup_data) != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;Failed to update data, recovering. table=%s, rc=%d:%s&quot;</span>, <span class="hljs-built_in">name</span>(), rc, <span class="hljs-built_in">strrc</span>(rc));<br>      <span class="hljs-keyword">return</span> rc;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br><br><span class="hljs-comment">// 更新一个字段</span><br><span class="hljs-function">RC <span class="hljs-title">Table::update_record</span><span class="hljs-params">(Record &amp;record, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *attr_name, Value *value)</span> </span>&#123;<br>  <span class="hljs-comment">// 遍历表格的全部域，找到目标域</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> sys_field_num = table_meta_.<span class="hljs-built_in">sys_field_num</span>();<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> user_field_num = table_meta_.<span class="hljs-built_in">field_num</span>() - sys_field_num;<br>  FieldMeta *targetFiled = <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (; i &lt; user_field_num; i++) &#123;<br>    <span class="hljs-type">const</span> FieldMeta *field_meta = table_meta_.<span class="hljs-built_in">field</span>(sys_field_num + i);<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *field_name = field_meta-&gt;<span class="hljs-built_in">name</span>();<br><br>    <span class="hljs-comment">// 找到目标域</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(field_name, attr_name) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 判断 NULL 值</span><br>      <span class="hljs-keyword">if</span> (value-&gt;<span class="hljs-built_in">get_null</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (field_meta-&gt;<span class="hljs-built_in">can_be_null</span>() == <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>      &#125;<br>      <span class="hljs-comment">// 类型匹配检查</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (field_meta-&gt;<span class="hljs-built_in">type</span>() != value-&gt;<span class="hljs-built_in">attr_type</span>()) &#123;<br>        Value real_value;<br>        RC rc = Value::<span class="hljs-built_in">cast_to</span>(*value, field_meta-&gt;<span class="hljs-built_in">type</span>(), real_value);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">OB_FAIL</span>(rc)) <span class="hljs-keyword">return</span> rc;<br>        *value = std::<span class="hljs-built_in">move</span>(real_value);<br>      &#125;<br><br>      <span class="hljs-comment">// 拿到目标域</span><br>      targetFiled = (FieldMeta *)field_meta;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 域存在检查</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == targetFiled) &#123;<br>    <span class="hljs-keyword">return</span> RC::SCHEMA_FIELD_NOT_EXIST;<br>  &#125;<br><br>  <span class="hljs-type">int</span> field_offset = targetFiled-&gt;<span class="hljs-built_in">offset</span>();<br>  <span class="hljs-type">int</span> field_length = targetFiled-&gt;<span class="hljs-built_in">len</span>();<br><br>  <span class="hljs-comment">// 修改旧数据</span><br>  <span class="hljs-type">char</span> *old_data = record.<span class="hljs-built_in">data</span>();<br><br>  <span class="hljs-comment">// 暂时备份旧数据</span><br>  <span class="hljs-type">char</span> *backup_data = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(record.<span class="hljs-built_in">len</span>());<br>  <span class="hljs-built_in">memcpy</span>(backup_data, old_data, record.<span class="hljs-built_in">len</span>());<br><br>  <span class="hljs-keyword">if</span> (value-&gt;<span class="hljs-built_in">length</span>() &gt; field_length &amp;&amp; targetFiled-&gt;<span class="hljs-built_in">type</span>() != AttrType::VECTORS) &#123;<br>    <span class="hljs-built_in">memcpy</span>(old_data + field_offset, value-&gt;<span class="hljs-built_in">data</span>(), field_length);<br>  &#125;<br>  ...<br>  <span class="hljs-comment">// 对于 CHARS</span><br>  <span class="hljs-comment">// 这种不定长的记录，如果更新的元素小于原来的长度，需要额外抹去原有元素</span><br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">memcpy</span>(old_data + field_offset, value-&gt;<span class="hljs-built_in">data</span>(), value-&gt;<span class="hljs-built_in">length</span>());<br>    <span class="hljs-built_in">memset</span>(old_data + field_offset + value-&gt;<span class="hljs-built_in">length</span>(), <span class="hljs-number">0</span>, field_length - value-&gt;<span class="hljs-built_in">length</span>());<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (value-&gt;<span class="hljs-built_in">get_null</span>()) &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *flag = <span class="hljs-string">&quot;ÿÿÿÿ&quot;</span>;<br>    <span class="hljs-built_in">memcpy</span>(old_data + field_offset, flag, std::<span class="hljs-built_in">min</span>(<span class="hljs-number">4</span>, field_length));<br>  &#125;<br><br>  record.<span class="hljs-built_in">set_data</span>(old_data);<br><br>  Index *index = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">find_index_by_field</span>(targetFiled-&gt;<span class="hljs-built_in">name</span>());<br><br>  <span class="hljs-comment">// 单字段索引更新和检查</span><br>  <span class="hljs-keyword">if</span> (index != <span class="hljs-literal">nullptr</span>) &#123;<br>    RC rc = index-&gt;<span class="hljs-built_in">insert_entry</span>(record.<span class="hljs-built_in">data</span>(), &amp;record.<span class="hljs-built_in">rid</span>());<br>    <span class="hljs-keyword">if</span> (rc != RC::SUCCESS &amp;&amp; <span class="hljs-built_in">strcmp</span>(old_data, backup_data) != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;Failed to update data, recovering. table=%s, rc=%d:%s&quot;</span>, <span class="hljs-built_in">name</span>(), rc, <span class="hljs-built_in">strrc</span>(rc));<br>      <span class="hljs-keyword">return</span> rc;<br>    &#125;<br>  &#125;<br><br>  record_handler_-&gt;<span class="hljs-built_in">update_record</span>(&amp;record);<br>  <span class="hljs-comment">// delete old_data;</span><br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="支持谓词逻辑普通运算符对-NULL-计算，以及谓词逻辑新增运算-IS-NULL-and-IS-NOT-NULL"><a href="#支持谓词逻辑普通运算符对-NULL-计算，以及谓词逻辑新增运算-IS-NULL-and-IS-NOT-NULL" class="headerlink" title="支持谓词逻辑普通运算符对 NULL 计算，以及谓词逻辑新增运算 IS NULL and IS NOT NULL"></a>支持谓词逻辑普通运算符对 NULL 计算，以及谓词逻辑新增运算 IS NULL and IS NOT NULL</h4><p>由于 Compare 部分我们写的比较复杂，这边只展示有关 IS NULL and IS NOT NULL 的函数，对于普通运算符，只需要在最上方判断：如果为 NULL，直接返回 false。不过需要注意，后面涉及到排序题目的时候，不能无脑返回 false，需要特殊考虑 NULL 和 NULL 的比较。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IS_NULL_Compare</span><span class="hljs-params">(CompType type_, <span class="hljs-type">const</span> Value &amp;left, <span class="hljs-type">const</span> Value &amp;right, <span class="hljs-type">const</span> std::vector&lt;Value&gt; left_list, <span class="hljs-type">const</span> std::vector&lt;Value&gt; right_list,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> std::vector&lt;std::vector&lt;Value&gt;&gt; left_tuple_list, <span class="hljs-type">const</span> std::vector&lt;std::vector&lt;Value&gt;&gt; right_tuple_list)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (type_ == CompType::VAL_LIST || type_ == CompType::VAL_VAL || type_ == CompType::VAL_TUPLES) &#123;<br>    <span class="hljs-keyword">return</span> left.<span class="hljs-built_in">get_null</span>();<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!left_list.<span class="hljs-built_in">empty</span>() &amp;&amp; type_ == CompType::LIST_VAL) &#123;<br>    <span class="hljs-keyword">return</span> left_list[<span class="hljs-number">0</span>].<span class="hljs-built_in">get_null</span>();<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!left_tuple_list.<span class="hljs-built_in">empty</span>() &amp;&amp; type_ == CompType::TUPLES_VAL) &#123;<br>    <span class="hljs-keyword">return</span> left_tuple_list[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].<span class="hljs-built_in">get_null</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="update-select"><a href="#update-select" class="headerlink" title="update-select"></a>update-select</h3><p><img src="/img/update_select.png"></p><p>本题要求 update 的更新目标值可以通过子查询得出，子查询第一版本是我的队友完成的，但是在写复杂子查询的时候将整个框架重构了一下。因为在看代码框架的时候发现，用于生成算子的部分是完全独立的，所以完全可以将生成算子的部分改成静态的，从而可以 : “随时随地，STNT -&gt; 算子 -&gt; 结果”。这样设计完之后，想要获取子查询的结果只需要一个 STMT，极大的简化了代码，甚至 update-select 并没有新增什么内容，只是在收集更新的 Value 时，多增一步，如果 Value 是子查询需要转化一下。</p><p>需要注意的是，准确说当时因为这个 debug 了好久，where 子句筛选出来的元组集合为空集时，即便子查询搜出来的结果不合法，也算 SUCCESS。<br>对于子查询，能当作 update 的 Value 的充分必要条件是搜出来的元组数组，或者二维数组，只能是一个元素。如果搜出来是空集，等同于插入 NULL。</p><h4 id="STMT-vector-vector-Value"><a href="#STMT-vector-vector-Value" class="headerlink" title="STMT -&gt; vector&lt; vector&lt; Value&gt;&gt;"></a>STMT -&gt; vector&lt; vector&lt; Value&gt;&gt;</h4><p>更近一步，设计一个函数，输入 STMT，输出为二维 Value 数组，省去中间的部分。函数设计如下：输入 STMT，输出 数据 + 表头信息。其中 main_tuple 为复杂子查询的内容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">RC <span class="hljs-title">OptimizeStage::handle_sub_stmt</span><span class="hljs-params">(Stmt *stmt, std::vector&lt;std::vector&lt;Value&gt;&gt; &amp;tuple_list, TupleSchema &amp;tuple_schema, <span class="hljs-type">const</span> Tuple *main_tuple)</span> </span>&#123;<br>  SelectStmt *select_stmt = <span class="hljs-built_in">static_cast</span>&lt;SelectStmt *&gt;(stmt);<br>  vector&lt;Table *&gt; tables = select_stmt-&gt;<span class="hljs-built_in">tables</span>();<br>  string table_names;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : tables) table_names += it-&gt;<span class="hljs-built_in">name</span>();<br><br>  RC rc = RC::SUCCESS;<br><br>  <span class="hljs-comment">// ? 不存在创建好的逻辑算子</span><br>  <span class="hljs-keyword">if</span> (!sub_expr_and_logical_oper.<span class="hljs-built_in">contains</span>(table_names)) &#123;<br>    unique_ptr&lt;LogicalOperator&gt; logical_oper;<br>    rc = <span class="hljs-built_in">create_logical_plan</span>(stmt, logical_oper);<br><br>    <span class="hljs-keyword">if</span> (rc != RC::SUCCESS &amp;&amp; rc != RC::UNIMPLEMENTED) <span class="hljs-keyword">return</span> rc;<br>    <span class="hljs-built_in">ASSERT</span>(logical_oper, <span class="hljs-string">&quot;logical operator is null&quot;</span>);<br><br>    sub_expr_and_logical_oper.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(table_names, std::<span class="hljs-built_in">move</span>(logical_oper)));<br>  &#125;<br><br>  <span class="hljs-comment">// ? 不存在创建好的物理算子</span><br>  <span class="hljs-keyword">if</span> (!sub_expr_and_physical_oper.<span class="hljs-built_in">contains</span>(table_names)) &#123;<br>    unique_ptr&lt;PhysicalOperator&gt; physical_oper;<br>    rc = <span class="hljs-built_in">generate_physical_plan</span>(sub_expr_and_logical_oper[table_names], physical_oper);<br><br>    <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br><br>    sub_expr_and_physical_oper.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(table_names, std::<span class="hljs-built_in">move</span>(physical_oper)));<br>  &#125;<br><br>  PhysicalOperator *physical_oper = sub_expr_and_physical_oper[table_names].<span class="hljs-built_in">get</span>();<br>  rc = <span class="hljs-built_in">get_tuple_schema</span>(physical_oper, tuple_schema);<br>  <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br><br>  rc = <span class="hljs-built_in">get_tuple_list</span>(physical_oper, tuple_list, main_tuple);<br>  <span class="hljs-keyword">return</span> rc;<br>&#125;<br><br><span class="hljs-function">RC <span class="hljs-title">OptimizeStage::create_logical_plan</span><span class="hljs-params">(Stmt *stmt, unique_ptr&lt;LogicalOperator&gt; &amp;logical_operator)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == stmt) &#123;<br>    <span class="hljs-keyword">return</span> RC::UNIMPLEMENTED;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> LogicalPlanGenerator::<span class="hljs-built_in">create</span>(stmt, logical_operator);<br>&#125;<br><br><span class="hljs-function">RC <span class="hljs-title">OptimizeStage::generate_physical_plan</span><span class="hljs-params">(unique_ptr&lt;LogicalOperator&gt; &amp;logical_operator, unique_ptr&lt;PhysicalOperator&gt; &amp;physical_operator)</span> </span>&#123;<br>  RC rc = PhysicalPlanGenerator::<span class="hljs-built_in">create</span>(*logical_operator, physical_operator);<br><br>  <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to create physical operator. rc=%s&quot;</span>, <span class="hljs-built_in">strrc</span>(rc));<br>  &#125;<br>  <span class="hljs-keyword">return</span> rc;<br>&#125;<br><br><span class="hljs-function">RC <span class="hljs-title">OptimizeStage::get_tuple_schema</span><span class="hljs-params">(PhysicalOperator *physical_operator, TupleSchema &amp;tuple_schema)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> physical_operator-&gt;<span class="hljs-built_in">tuple_schema</span>(tuple_schema);<br>&#125;<br><br><span class="hljs-function">RC <span class="hljs-title">OptimizeStage::get_tuple_list</span><span class="hljs-params">(PhysicalOperator *physical_operator, std::vector&lt;std::vector&lt;Value&gt;&gt; &amp;tuple_list, <span class="hljs-type">const</span> Tuple *main_tuple)</span> </span>&#123;<br>  RC rc = physical_operator-&gt;<span class="hljs-built_in">open</span>(<span class="hljs-literal">nullptr</span>, main_tuple);<br>  <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to open sub physical operator. rc=%s&quot;</span>, <span class="hljs-built_in">strrc</span>(rc));<br>    <span class="hljs-keyword">return</span> rc;<br>  &#125;<br><br>  <span class="hljs-comment">// 将查表结果放入value_list</span><br>  <span class="hljs-keyword">while</span> (RC::SUCCESS == (rc = physical_operator-&gt;<span class="hljs-built_in">next</span>(main_tuple))) &#123;<br>    Tuple *tuple = physical_operator-&gt;<span class="hljs-built_in">current_tuple</span>();<br>    std::vector&lt;Value&gt; single_tuple;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tuple-&gt;<span class="hljs-built_in">cell_num</span>(); i++) &#123;<br>      Value value;<br>      tuple-&gt;<span class="hljs-built_in">cell_at</span>(i, value);<br>      single_tuple.<span class="hljs-built_in">push_back</span>(value);<br>    &#125;<br>    tuple_list.<span class="hljs-built_in">push_back</span>(single_tuple);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (rc != RC::RECORD_EOF) <span class="hljs-keyword">return</span> rc;<br><br>  rc = physical_operator-&gt;<span class="hljs-built_in">close</span>();<br>  <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br><br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="update-中添加有关子查询的部分"><a href="#update-中添加有关子查询的部分" class="headerlink" title="update 中添加有关子查询的部分"></a>update 中添加有关子查询的部分</h4><p>如果发现有子查询，通过函数将其转化为二维 Value 数组，如果数组只有一个元素则合法，拿出来；如果数组为空，则等同于 NULL；如果数组不为空，等同一个非法的 Value，注意这里并没有直接返回 FAILURE，因为如果 where 子句筛选集为空集，即便子查询有误也返回 SUCCESS，所以这里通过特意构造非法 Value，如果 where 子句筛选集不为空集，则会识别非法 Value 并返回 FAILURE；如果 where 子句筛选集为空集，则不会有识别环节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">RC <span class="hljs-title">UpdateStmt::create</span><span class="hljs-params">(Db *db, UpdateSqlNode &amp;update, Stmt *&amp;stmt)</span> </span>&#123;<br>  <span class="hljs-comment">// 拿到目标表格以及名称以及修改域</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *table_name = update.relation_name.<span class="hljs-built_in">c_str</span>();<br>  Table *table = db-&gt;<span class="hljs-built_in">find_table</span>(table_name);<br><br>  <span class="hljs-comment">// 目标表格不存在检查</span><br>  <span class="hljs-keyword">if</span> (table == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;no such table. db=%s, table_name=%s&quot;</span>, db-&gt;<span class="hljs-built_in">name</span>(), table_name);<br>    <span class="hljs-keyword">return</span> RC::SCHEMA_TABLE_NOT_EXIST;<br>  &#125;<br>  <span class="hljs-comment">// 参数非法检查</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == db || <span class="hljs-literal">nullptr</span> == table_name) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;invalid argument. db=%p, table_name=%p&quot;</span>, db, table_name);<br>    <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>  &#125;<br><br>  <span class="hljs-comment">// 拿到全部修改域</span><br>  std::vector&lt;FieldMeta&gt; field_metas;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : update.update_targets) &#123;<br>    FieldMeta *field_meta = (FieldMeta *)table-&gt;<span class="hljs-built_in">table_meta</span>().<span class="hljs-built_in">field</span>(it.attribute_name.<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-comment">// 修改域检查</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == field_meta) &#123;<br>      <span class="hljs-keyword">return</span> RC::SCHEMA_FIELD_NOT_EXIST;<br>    &#125;<br>    field_metas.<span class="hljs-built_in">push_back</span>(*field_meta);<br>  &#125;<br><br>  <span class="hljs-comment">// 创建筛选 STMT 对象</span><br>  std::unordered_map&lt;std::string, Table *&gt; table_map;<br>  table_map.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">pair</span>&lt;std::string, Table *&gt;(std::<span class="hljs-built_in">string</span>(table_name), table));<br>  FilterStmt *filter_stmt = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-type">bool</span> flag;<br>  RC rc = FilterStmt::<span class="hljs-built_in">create</span>(db, table, &amp;table_map, update.conditions.<span class="hljs-built_in">data</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(update.conditions.<span class="hljs-built_in">size</span>()), filter_stmt, flag);<br><br>  <span class="hljs-comment">// 谓词语句合法检查</span><br>  <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to create filter statement. rc=%d:%s&quot;</span>, rc, <span class="hljs-built_in">strrc</span>(rc));<br>    <span class="hljs-keyword">return</span> rc;<br>  &#125;<br><br>  <span class="hljs-comment">// 创建子查询的 STMT 对象</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">int</span>)update.update_targets.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (update.update_targets[i].is_value == <span class="hljs-literal">false</span>) &#123;<br>      Stmt *temp;<br>      rc = SelectStmt::<span class="hljs-built_in">create</span>(db, update.update_targets[i].sub_select-&gt;selection, temp, flag);<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>      vector&lt;vector&lt;Value&gt;&gt; tuple_list;<br>      TupleSchema tuple_schema;<br>      OptimizeStage::<span class="hljs-built_in">reset</span>();<br>      RC rc = OptimizeStage::<span class="hljs-built_in">handle_sub_stmt</span>(temp, tuple_list, tuple_schema);<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>      <span class="hljs-comment">// 子查询为空值，等同于插入 NULL</span><br>      <span class="hljs-keyword">if</span> (tuple_list.<span class="hljs-built_in">empty</span>()) &#123;<br>        update.update_targets[i].value.<span class="hljs-built_in">set_null</span>(<span class="hljs-literal">true</span>);<br>      &#125;<br>      <span class="hljs-comment">// 子查询非法，等同于插入非法 Value，如果筛选出来没有更新目标，则无视，否则报错</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tuple_list.<span class="hljs-built_in">size</span>() != <span class="hljs-number">1</span> || tuple_list[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() != <span class="hljs-number">1</span>) &#123;<br>        update.update_targets[i].value.<span class="hljs-built_in">set_type</span>(AttrType::UNDEFINED);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        update.update_targets[i].value = tuple_list[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>      &#125;<br>      update.update_targets[i].is_value = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// check date validity</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : update.update_targets) &#123;<br>    Value value = it.value;<br>    <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">attr_type</span>() == AttrType::DATE) &#123;<br>      <span class="hljs-keyword">if</span> (!DateType::<span class="hljs-built_in">check_date</span>(value.<span class="hljs-built_in">get_date</span>())) &#123;<br>        <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">attr_type</span>() == AttrType::CHARS) &#123;<br>      <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">get_string</span>().<span class="hljs-built_in">size</span>() &gt; BP_MAX_TEXT_SIZE) &#123;<br>        <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">attr_type</span>() == AttrType::VECTORS) &#123;<br>      <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">get_vector_size</span>() &gt; BP_MAX_VECTOR_SIZE) &#123;<br>        <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 创建 update 的 STMT 对象</span><br>  stmt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">UpdateStmt</span>(table, filter_stmt, field_metas, update.update_targets);<br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p><img src="/img/alias.png"></p><h3 id="order-by"><a href="#order-by" class="headerlink" title="order-by"></a>order-by</h3><p><img src="/img/order_by.png"></p><h3 id="aggregation-and-groupby"><a href="#aggregation-and-groupby" class="headerlink" title="aggregation_and_groupby"></a>aggregation_and_groupby</h3><p><img src="/img/aggregation_and_groupby.png"></p><h3 id="create-table-select"><a href="#create-table-select" class="headerlink" title="create-table-select"></a>create-table-select</h3><p><img src="/img/create_table_select.png"></p><h3 id="vector-rewrite"><a href="#vector-rewrite" class="headerlink" title="vector_rewrite"></a>vector_rewrite</h3><p><img src="/img/vector_rewrite.png"></p><h3 id="vector-search"><a href="#vector-search" class="headerlink" title="vector_search"></a>vector_search</h3><p><img src="/img/vector_search.png"></p><h3 id="complex-sub-query"><a href="#complex-sub-query" class="headerlink" title="complex-sub-query"></a>complex-sub-query</h3><p><img src="/img/complex_sub_query.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Competition</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>funny</title>
    <link href="/2000/01/01/funny/"/>
    <url>/2000/01/01/funny/</url>
    
    <content type="html"><![CDATA[<blockquote><p>网络冲浪时发现的一些有趣的东西</p></blockquote><p>C++ 中的单例模式<br>关键词：单例模式、饿汉模式、懒汉模式<br>语法的缘故实现起来比 C# 复杂<br><a href="https://www.bilibili.com/video/BV12QATewEww/">https://www.bilibili.com/video/BV12QATewEww/</a></p><p>C++ 中的头文件重复引用问题<br>关键词：#ifndef #pragma once<br>数据库比赛时遇到的最恶心的问题<br><a href="https://www.bilibili.com/video/BV12Kr5Y8E7c/">https://www.bilibili.com/video/BV12Kr5Y8E7c/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
