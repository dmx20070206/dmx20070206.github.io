<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ENGLISH</title>
    <link href="/2024/11/21/ENGLISH/"/>
    <url>/2024/11/21/ENGLISH/</url>
    
    <content type="html"><![CDATA[<h2 id="2024-11-22"><a href="#2024-11-22" class="headerlink" title="2024-11-22"></a>2024-11-22</h2><h3 id="list-1"><a href="#list-1" class="headerlink" title="list 1"></a>list 1</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>account</td><td>benefit</td><td>challenge</td></tr><tr><td>impact</td><td>apply</td><td>focus</td></tr><tr><td>involve</td><td>potential</td><td>promote</td></tr><tr><td>shift</td><td>tend</td><td>access</td></tr><tr><td>resource</td><td>launch</td><td>current</td></tr><tr><td>opportunity</td><td>reflect</td><td>debate</td></tr><tr><td>conduct</td><td>despite</td><td>determine</td></tr><tr><td>purchase</td><td>specific</td><td>senior</td></tr><tr><td>unique</td><td>amount</td><td>agency</td></tr><tr><td>expand</td><td>attitude</td><td>financial</td></tr><tr><td>release</td><td>declare</td><td>institution</td></tr><tr><td>estimate</td><td>pose</td><td>significant</td></tr><tr><td>associate</td><td>assume</td><td>eventually</td></tr><tr><td>replace</td><td>series</td><td>fund</td></tr><tr><td>rank</td><td>respond</td><td>advocate</td></tr><tr><td>boost</td><td>throughout</td><td>define</td></tr><tr><td>establish</td><td>predict</td><td>attach</td></tr><tr><td>campaign</td><td>track</td><td>exchange</td></tr><tr><td>numerous</td><td>expose</td><td>overall</td></tr><tr><td>vehicle</td><td>outcome</td><td>intend</td></tr><tr><td>reveal</td><td>positive</td><td>critical</td></tr><tr><td>survey</td><td>capacity</td><td>enhance</td></tr></tbody></table><h3 id="list-2"><a href="#list-2" class="headerlink" title="list 2"></a>list 2</h3><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>vocal</td><td>officials</td><td>overestimate</td></tr><tr><td>hesitant</td><td>terminate</td><td>invest</td></tr><tr><td>bleak</td><td>inclusiveness</td><td>frontline</td></tr><tr><td>genre</td><td>regulation</td><td>overnight</td></tr><tr><td>distinguish</td><td>money-making</td><td>monolingual</td></tr><tr><td>bilingual</td><td>multilingual</td><td>leather</td></tr><tr><td>substitute</td><td>fierce</td><td>particularly</td></tr><tr><td>obsessed</td><td>cognitive</td><td>elite</td></tr><tr><td>vast</td><td>bulk</td><td>aggressive</td></tr><tr><td>inflation</td><td>cross-country</td><td>church</td></tr><tr><td>dictate</td><td>infant</td><td>struggle</td></tr><tr><td>category</td><td>measure</td><td>interpret</td></tr><tr><td>exotic</td><td>acclaim</td><td>infrastructure</td></tr></tbody></table><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">wire</span> total = <span class="hljs-number">66</span> + <span class="hljs-number">39</span>; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>miniob 初赛参赛总结</title>
    <link href="/2024/11/11/miniob/"/>
    <url>/2024/11/11/miniob/</url>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>参加这个比赛其实主要目的是赚钱（感谢周师姐的校友基金，最后含泪收下 7000￥ ），所以以下很多内容可能并不专业。</p><p>最终的结果是全国第 40 名，进决赛一共有 50 个队伍，不过由于加权压力（目前估计加权相较于大二上要掉 6 分左右），决赛不一定会付出太多心血去打了。</p><p>感谢我的队友 Sazikk 和我一起熬夜肝代码，并且忍耐我的屎山代码长达 21 天之久。由于屎山太多了，所以出现屎的部分会标注。</p><blockquote><p>Sazikk 个人博客：<a href="https://sazikk.github.io/">https://sazikk.github.io</a>  目前已有数十万的观看量（狗头<br>我们的项目：<a href="https://github.com/SaZiKK/miniob-2024">https://github.com/SaZiKK/miniob-2024</a><br>806 官方链接：<a href="https://ustb-806.github.io/blogs/2024/11/oceanbase/">https://ustb-806.github.io/blogs/2024/11/oceanbase/</a></p></blockquote><h2 id="个人心得"><a href="#个人心得" class="headerlink" title="个人心得"></a>个人心得</h2><p>参加这个比赛需要什么能力：</p><ol><li>较强的 C++ 开发能力</li><li>一定的 SQL 语言理解能力</li><li>对 miniob 内核有较好的理解</li></ol><h2 id="miniob-框架解析"><a href="#miniob-框架解析" class="headerlink" title="miniob 框架解析"></a>miniob 框架解析</h2><h2 id="我负责的题目"><a href="#我负责的题目" class="headerlink" title="我负责的题目"></a>我负责的题目</h2><h3 id="drop-table"><a href="#drop-table" class="headerlink" title="drop table"></a>drop table</h3><p><img src="/img/drop_table.png"></p><p>题目要求删除某个表格，一个表格的信息包括三种：数据信息 + 索引信息 + 表格元数据</p><ol><li>数据信息：真实存放到表格当中的数据</li><li>索引信息：一个索引对应一棵 B+ 树</li><li>表格元数据：各种表格的描述信息</li></ol><p>drop table 不需要算子，需要执行器</p><h4 id="前端-lex-yacc-完善"><a href="#前端-lex-yacc-完善" class="headerlink" title="前端 lex yacc 完善"></a>前端 lex yacc 完善</h4><p>lex 加入关键字 DROP</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">DROP                                    <span class="hljs-title">RETURN_TOKEN</span><span class="hljs-params">(DROP)</span></span>;<br></code></pre></td></tr></table></figure><p>yacc 加入语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">drop_table_stmt:<br>    DROP TABLE ID &#123;<br>      $$ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ParsedSqlNode</span>(SCF_DROP_TABLE);<br>      $$-&gt;drop_table.relation_name = $<span class="hljs-number">3</span>;<br>      <span class="hljs-built_in">free</span>($<span class="hljs-number">3</span>);<br>    &#125;;<br></code></pre></td></tr></table></figure><h4 id="STMT-设计"><a href="#STMT-设计" class="headerlink" title="STMT 设计"></a>STMT 设计</h4><p>删除表格只需要表格的表名，当然正常来说在 STMT 级就应该通过表格名称获取到实际的 Table 了，但是当时写的时候放到了 Db 的删除表格函数中。</p><h4 id="EXECUTE-设计"><a href="#EXECUTE-设计" class="headerlink" title="EXECUTE 设计"></a>EXECUTE 设计</h4><p>在执行器中通过调用 db 的删除表格函数或者 table 的自毁函数。表格的自毁函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">RC <span class="hljs-title">Table::drop</span><span class="hljs-params">()</span> </span>&#123;<br><br>  <span class="hljs-comment">// 删除数据文件 data_file</span><br>  string data_file = <span class="hljs-built_in">table_data_file</span>(base_dir_.<span class="hljs-built_in">c_str</span>(), table_meta_.<span class="hljs-built_in">name</span>());<br>  <span class="hljs-built_in">unlink</span>(data_file.<span class="hljs-built_in">c_str</span>());<br><br>  <span class="hljs-comment">// 删除索引文件 index_file</span><br>  <span class="hljs-type">int</span> indexNum = table_meta_.<span class="hljs-built_in">index_num</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; indexNum; i++) &#123;<br>    <span class="hljs-keyword">auto</span> *index_meta = table_meta_.<span class="hljs-built_in">index</span>(i);<br>    string index_file = <span class="hljs-built_in">table_index_file</span>(base_dir_.<span class="hljs-built_in">c_str</span>(), table_meta_.<span class="hljs-built_in">name</span>(), index_meta-&gt;<span class="hljs-built_in">name</span>());<br>    <span class="hljs-built_in">unlink</span>(index_file.<span class="hljs-built_in">c_str</span>());<br>  &#125;<br><br>  <span class="hljs-comment">// 删除元文件 meta_file</span><br>  string meta_file = <span class="hljs-built_in">table_meta_file</span>(base_dir_.<span class="hljs-built_in">c_str</span>(), table_meta_.<span class="hljs-built_in">name</span>());<br>  <span class="hljs-built_in">unlink</span>(meta_file.<span class="hljs-built_in">c_str</span>());<br><br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p><img src="/img/update.png"></p><p>虽然题目只要求单字段的更新，但是由于后面很快就要扩充，所以下面直接放完整版。</p><p>需要注意的有两点，如何将 在某些字段修改为某值 推得 在内存某些位置修改二进制数据；以及对于多个字段的更新，必须同时成功或失败，也即先判断后修改（或回滚），不仅有单个字段间的回滚，还有单个元组间的回滚。</p><p>update 语句不需要执行器，需要算子</p><h4 id="前端-lex-yacc-完善-1"><a href="#前端-lex-yacc-完善-1" class="headerlink" title="前端 lex yacc 完善"></a>前端 lex yacc 完善</h4><p>lex 加入关键字 UPDATE</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">UPDATE                                  <span class="hljs-title">RETURN_TOKEN</span><span class="hljs-params">(UPDATE)</span></span>;<br></code></pre></td></tr></table></figure><p>yacc 加入语句<br>其中 update_target 为一个字段的更新，update_target_list 为若干字段的更新，where 为谓词表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++">update_stmt:      <span class="hljs-comment">/*  update 语句的语法解析树*/</span><br>    UPDATE ID SET update_target update_target_list where <br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ParsedSqlNode</span>(SCF_UPDATE);<br>      $$-&gt;update.relation_name = $<span class="hljs-number">2</span>;<br><br>      <span class="hljs-keyword">if</span> ($<span class="hljs-number">6</span> != <span class="hljs-literal">nullptr</span>) &#123;<br>        $$-&gt;update.conditions.<span class="hljs-built_in">swap</span>(*$<span class="hljs-number">6</span>);<br>        <span class="hljs-keyword">delete</span> $<span class="hljs-number">6</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span>($<span class="hljs-number">5</span> != <span class="hljs-literal">nullptr</span>)<br>        $$-&gt;update.update_targets.<span class="hljs-built_in">swap</span>(*$<span class="hljs-number">5</span>);<br>      $$-&gt;update.update_targets.<span class="hljs-built_in">emplace_back</span>(*$<span class="hljs-number">4</span>);<br>      std::<span class="hljs-built_in">reverse</span>($$-&gt;update.update_targets.<span class="hljs-built_in">begin</span>(), $$-&gt;update.update_targets.<span class="hljs-built_in">end</span>());<br>    &#125;<br>    ;<br></code></pre></td></tr></table></figure><p>对于 ParseSqlNode，新增 update 语句对应的 node。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UpdateSqlNode</span> &#123;<br>  std::string relation_name;                <span class="hljs-comment">// 更新表格名称</span><br>  std::vector&lt;UpdateTarget&gt; update_targets; <span class="hljs-comment">// 更新字段集合</span><br>  std::vector&lt;ConditionSqlNode&gt; conditions; <span class="hljs-comment">// 谓词条件</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UpdateTarget</span> &#123;<br>  <span class="hljs-type">bool</span> is_value;                            <span class="hljs-comment">// 是否为简单值，本题视作 true</span><br>  Value value;                              <span class="hljs-comment">// 更新的值</span><br>  std::string attribute_name;               <span class="hljs-comment">// 更新的属性名</span><br>  SubSelectSqlNode *sub_select;             <span class="hljs-comment">// 子查询，后面习题涉及</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="STMT-设计-1"><a href="#STMT-设计-1" class="headerlink" title="STMT 设计"></a>STMT 设计</h4><p>update 语句对应的 STMT 中包含：所有修改域信息(FieldMeta)，目标表格，筛选对应的 STMT(FilterStmt)，以及处理好的 UpdateTarget 数组。</p><p>第一步，拿到表格</p><p>第二步，通过所有修改域的名称，拿到全部修改域，注意顺序是不重要的，因为它们都是同时成功或同时失败的。</p><p>第三步，如果有子查询需要将子查询转化为一个 Value，后面对应的题再解释。</p><h4 id="逻辑算子和物理算子设计"><a href="#逻辑算子和物理算子设计" class="headerlink" title="逻辑算子和物理算子设计"></a>逻辑算子和物理算子设计</h4><p>逻辑算子中需要包含表格以及一个数组，数组表示需要更新的域和值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">Table *table_ = <span class="hljs-literal">nullptr</span>;<br>std::vector&lt;std::pair&lt;Value, FieldMeta&gt;&gt; update_map_;<br></code></pre></td></tr></table></figure><p>物理算子直接继承逻辑算子中的表格和&lt;域, 值&gt;数组，除此之外还需要包含一个 Record 数组，因为我们要处理单个元组的回滚。在存在 unique index 的情境下，一条 update 语句可能对多个元组进行修改，<br>如果修改时发现某一条元组的修改是非法的，则之前所有的修改都要撤回。此处存放修改前的 Record 数组方便回滚。而对于单个字段的回滚，我们采取先判断合法再修改的策略，也即只有全部字段的修改都是有效的<br>才会开始实际的修改。</p><p>例如： </p><table><thead><tr><th>id</th><th>num</th><th>col</th></tr></thead><tbody><tr><td>id1</td><td>num1</td><td>col1</td></tr><tr><td>id2</td><td>num2</td><td>col2</td></tr><tr><td>id3</td><td>num3</td><td>col3</td></tr></tbody></table><p>update 语句需要修改第一个元组和第三个元组的 id, col 字段。</p><p>元组级别的回滚：更新第一个元组没问题，但是更新第三个元组是非法的。</p><p>字段级别的回滚：更新某个元组时，更新 id 域没问题，但是更新 col 域是非法的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">Table *table_ = <span class="hljs-literal">nullptr</span>;<br>Trx *trx_ = <span class="hljs-literal">nullptr</span>;<br>std::vector&lt;std::pair&lt;Value, FieldMeta&gt;&gt; update_map_;<br>std::vector&lt;Record&gt; records_;<br></code></pre></td></tr></table></figure><p>物理算子 open 函数设计：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// main_tuple 涉及到复杂子查询</span><br><span class="hljs-function">RC <span class="hljs-title">UpdatePhysicalOperator::open</span><span class="hljs-params">(Trx *trx, <span class="hljs-type">const</span> Tuple *main_tuple)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (children_.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-keyword">return</span> RC::SUCCESS;<br>  &#125;<br><br>  std::unique_ptr&lt;PhysicalOperator&gt; &amp;child = children_[<span class="hljs-number">0</span>];<br><br>  <span class="hljs-comment">// 调用子算子的 open 函数</span><br>  RC rc = child-&gt;<span class="hljs-built_in">open</span>(trx, main_tuple);<br>  <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to open child operator: %s&quot;</span>, <span class="hljs-built_in">strrc</span>(rc));<br>    <span class="hljs-keyword">return</span> rc;<br>  &#125;<br><br>  trx_ = trx;<br><br>  <span class="hljs-comment">// 收集全部元组</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">OB_SUCC</span>(rc = child-&gt;<span class="hljs-built_in">next</span>(main_tuple))) &#123;<br>    Tuple *tuple = child-&gt;<span class="hljs-built_in">current_tuple</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == tuple) &#123;<br>      <span class="hljs-keyword">return</span> rc;<br>    &#125;<br><br>    RowTuple *row_tuple = <span class="hljs-built_in">static_cast</span>&lt;RowTuple *&gt;(tuple);<br>    Record &amp;record = row_tuple-&gt;<span class="hljs-built_in">record</span>();<br>    records_.<span class="hljs-built_in">emplace_back</span>(std::<span class="hljs-built_in">move</span>(record));<br>  &#125;<br><br>  child-&gt;<span class="hljs-built_in">close</span>();<br><br>  <span class="hljs-keyword">if</span> (records_.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;no records to update&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 将这些元组数据拷贝到一个新数组中，用于回滚</span><br>  std::vector&lt;<span class="hljs-type">char</span> *&gt; backup_datas;<br>  <span class="hljs-keyword">for</span> (Record &amp;record : records_) &#123;<br>    Record backup_record;<br>    <span class="hljs-type">char</span> *old_data = record.<span class="hljs-built_in">data</span>();<br>    <span class="hljs-type">char</span> *backup_data = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(record.<span class="hljs-built_in">len</span>());<br>    <span class="hljs-built_in">memcpy</span>(backup_data, old_data, record.<span class="hljs-built_in">len</span>());<br><br>    backup_datas.<span class="hljs-built_in">push_back</span>(backup_data);<br>  &#125;<br><br>  <span class="hljs-type">size_t</span> update_num = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 先收集记录再更新</span><br>  <span class="hljs-keyword">for</span> (Record &amp;record : records_) &#123;<br>    rc = trx_-&gt;<span class="hljs-built_in">update_records</span>(table_, record, update_map_);<br>    ++update_num;<br>    <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) &#123;<br>      <span class="hljs-comment">// 如果更新失败，需要回滚，重新将修改过的元组复原</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">int</span>)update_num; ++i) &#123;<br>        <span class="hljs-type">char</span> *backup_data = backup_datas[i];<br>        Record &amp;record = records_[i];<br><br>        record.<span class="hljs-built_in">set_data</span>(backup_data);<br>        table_-&gt;<span class="hljs-built_in">record_handler</span>()-&gt;<span class="hljs-built_in">update_record</span>(&amp;record);<br>      &#125;<br>      <span class="hljs-keyword">return</span> rc;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>update 算子一般没有上层算子，所以不需要 next 函数，open 函数中调用了子算子的 close 函数，所以也不需要 close 函数。但理论上子算子的 close 函数放到 update 算子的 close 函数中会更好。<br>不过 delete 算子中也是这么写的，所以此处不修改了。</p><h3 id="expression"><a href="#expression" class="headerlink" title="expression"></a>expression</h3><p><img src="/img/expression.png"></p><h4 id="将万物都改成-expression-的过程"><a href="#将万物都改成-expression-的过程" class="headerlink" title="将万物都改成 expression 的过程"></a>将万物都改成 expression 的过程</h4><p>1.将谓词语句的 value&#x2F;field op value&#x2F;field 结构改成 expression op expression<br>2.初始的 FilterObj 中的 expression 只能是 value&#x2F;field，扩展使得 expression 可以是任何类型</p><p>之前提到过，在 select 语句中，会将查询的表达式进行绑定，例如将 UnboundField 绑定为 Field。在 Filter 部分，如果想要支持任何类型的 expression，也需要绑定的环节。miniob 初始的框架只包含了对 UnboundField 的绑定，<br>也即只完成了通过名字寻找特定域的功能。</p><p>理论上，应该模仿 select 语句的绑定，使用 ExpressionBinder 类来完成绑定的行为，但当时写的过于潦草，采用了纯粹的 switch 来完成。例如在下面的代码中完成了对表达式 expr 的绑定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// use_flag 是弃用的(时间关系未删除)，alias_map 为别名部分，table_map 为复杂子查询中的传递情况</span><br><span class="hljs-comment">// expr 是需要绑定的表达式，也是一条谓词语句的一端</span><br><span class="hljs-function">RC <span class="hljs-title">FilterStmt::bind_filter_expr</span><span class="hljs-params">(Db *db, Table *default_table, std::unordered_map&lt;std::string, Table *&gt; *tables, unique_ptr&lt;Expression&gt; &amp;expr,</span></span><br><span class="hljs-params"><span class="hljs-function">                                <span class="hljs-type">bool</span> &amp;use_flag, std::unordered_map&lt;string, string&gt; alias_map, std::unordered_map&lt;string, Table *&gt; table_map)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (expr == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br><br>  <span class="hljs-comment">// TODO 直接使用 expression_binder 中的函数进行</span><br><br>  <span class="hljs-comment">// 根据表达式的不同类型需要进行不同的操作</span><br>  <span class="hljs-keyword">switch</span> (expr-&gt;<span class="hljs-built_in">type</span>()) &#123;<br>    <span class="hljs-keyword">case</span> ExprType::VALUE: &#123;<br>      Value value;<br>      RC rc = expr-&gt;<span class="hljs-built_in">try_get_value</span>(value);<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>      <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">attr_type</span>() == AttrType::DATE &amp;&amp; !DateType::<span class="hljs-built_in">check_date</span>(&amp;value)) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ExprType::VALUELIST: &#123;<br>      std::vector&lt;Value&gt; value_list;<br>      RC rc = expr-&gt;<span class="hljs-built_in">get_value_list</span>(value_list);<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : value_list)<br>        <span class="hljs-keyword">if</span> (it.<span class="hljs-built_in">attr_type</span>() == AttrType::DATE &amp;&amp; !DateType::<span class="hljs-built_in">check_date</span>(&amp;it)) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ExprType::SUBQUERY: &#123;<br>      <span class="hljs-keyword">return</span> RC::SUCCESS;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ExprType::UNBOUND_FIELD: &#123;<br>      Table *table = <span class="hljs-literal">nullptr</span>;<br>      <span class="hljs-type">const</span> FieldMeta *field = <span class="hljs-literal">nullptr</span>;<br>      RC rc = <span class="hljs-built_in">get_table_and_field</span>(db, default_table, tables, expr.<span class="hljs-built_in">get</span>(), table, field, use_flag, alias_map, table_map);<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>      expr = std::<span class="hljs-built_in">make_unique</span>&lt;FieldExpr&gt;(table, field);<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ExprType::ARITHMETIC: &#123;<br>      RC rc = RC::SUCCESS;<br>      ArithmeticExpr *arith_expr = <span class="hljs-built_in">static_cast</span>&lt;ArithmeticExpr *&gt;(expr.<span class="hljs-built_in">get</span>());<br>      <span class="hljs-keyword">if</span> (arith_expr-&gt;<span class="hljs-built_in">left</span>() != <span class="hljs-literal">nullptr</span>) &#123;<br>        rc = <span class="hljs-built_in">bind_filter_expr</span>(db, default_table, tables, arith_expr-&gt;<span class="hljs-built_in">left</span>(), use_flag, alias_map, table_map);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>      <span class="hljs-keyword">if</span> (arith_expr-&gt;<span class="hljs-built_in">right</span>() != <span class="hljs-literal">nullptr</span>) &#123;<br>        rc = <span class="hljs-built_in">bind_filter_expr</span>(db, default_table, tables, arith_expr-&gt;<span class="hljs-built_in">right</span>(), use_flag, alias_map, table_map);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ExprType::VECFUNC: &#123;<br>      RC rc = RC::SUCCESS;<br>      VecFuncExpr *vec_func_expr = <span class="hljs-built_in">static_cast</span>&lt;VecFuncExpr *&gt;(expr.<span class="hljs-built_in">get</span>());<br>      <span class="hljs-keyword">if</span> (vec_func_expr-&gt;<span class="hljs-built_in">child_left</span>() != <span class="hljs-literal">nullptr</span>) &#123;<br>        rc = <span class="hljs-built_in">bind_filter_expr</span>(db, default_table, tables, vec_func_expr-&gt;<span class="hljs-built_in">child_left</span>(), use_flag, alias_map, table_map);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>      <span class="hljs-keyword">if</span> (vec_func_expr-&gt;<span class="hljs-built_in">child_right</span>() != <span class="hljs-literal">nullptr</span>) &#123;<br>        rc = <span class="hljs-built_in">bind_filter_expr</span>(db, default_table, tables, vec_func_expr-&gt;<span class="hljs-built_in">child_right</span>(), use_flag, alias_map, table_map);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> ExprType::UNBOUND_AGGREGATION: &#123;<br>      RC rc = RC::SUCCESS;<br>      <span class="hljs-keyword">auto</span> unbound_aggregate_expr = <span class="hljs-built_in">static_cast</span>&lt;UnboundAggregateExpr *&gt;(expr.<span class="hljs-built_in">get</span>());<br>      string name = unbound_aggregate_expr-&gt;<span class="hljs-built_in">name</span>();<br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *aggregate_name = unbound_aggregate_expr-&gt;<span class="hljs-built_in">aggregate_name</span>();<br><br>      AggregateExpr::Type aggregate_type;<br>      rc = AggregateExpr::<span class="hljs-built_in">type_from_string</span>(aggregate_name, aggregate_type);<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br><br>      unique_ptr&lt;Expression&gt; &amp;child_expr = unbound_aggregate_expr-&gt;<span class="hljs-built_in">child</span>();<br><br>      <span class="hljs-keyword">if</span> (child_expr == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br><br>      <span class="hljs-keyword">if</span> (child_expr-&gt;<span class="hljs-built_in">type</span>() == ExprType::STAR &amp;&amp; aggregate_type == AggregateExpr::Type::COUNT) &#123;<br>        ValueExpr *value_expr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ValueExpr</span>(<span class="hljs-built_in">Value</span>(<span class="hljs-number">1</span>));<br>        child_expr.<span class="hljs-built_in">reset</span>(value_expr);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        rc = <span class="hljs-built_in">bind_filter_expr</span>(db, default_table, tables, child_expr, use_flag, alias_map, table_map);<br>        <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>      &#125;<br><br>      <span class="hljs-comment">// TODO 校验聚合表达式</span><br>      expr = <span class="hljs-built_in">make_unique</span>&lt;AggregateExpr&gt;(aggregate_type, std::<span class="hljs-built_in">move</span>(child_expr));<br>      expr-&gt;<span class="hljs-built_in">set_name</span>(name);<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，FilterObj 也需要改成 expression，而不是之前的 field&#x2F;value 模式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">FilterObj</span> &#123;<br>  std::unique_ptr&lt;Expression&gt; expr;<br>  <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>=(FilterObj &amp;obj) &#123; <span class="hljs-keyword">this</span>-&gt;expr = std::<span class="hljs-built_in">move</span>(obj.expr); &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(std::unique_ptr&lt;Expression&gt; expr)</span> </span>&#123; <span class="hljs-keyword">this</span>-&gt;expr = std::<span class="hljs-built_in">move</span>(expr); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 yacc 中，也需要进行修改，condition 部分需要改成左右都为 expression。其中虽然我们将子查询也设计成了表达式，但是在解析的时候，子查询并不算为 expression，否则会出现冲突。<br>所以此处我们先通过 sub_select_stmt 来识别，在后面将其转化为 expression，从而和其他 expression 一起处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C++">expression comp_op<br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> ConditionSqlNode;<br>      $$-&gt;left_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;right_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;comp = $<span class="hljs-number">2</span>;<br>      $$-&gt;left_expression = $<span class="hljs-number">1</span>;<br>      $$-&gt;right_expression = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ValueExpr</span>(<span class="hljs-built_in">Value</span>(<span class="hljs-number">114514</span>));<br>    &#125;<br>    | expression comp_op sub_select_stmt<br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> ConditionSqlNode;<br>      $$-&gt;left_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;right_is_sub_query = <span class="hljs-literal">true</span>;<br>      $$-&gt;comp = $<span class="hljs-number">2</span>;<br>      $$-&gt;left_expression = $<span class="hljs-number">1</span>;<br>      $$-&gt;right_sub_query = $<span class="hljs-number">3</span>;<br>      $$-&gt;right_expression = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    | sub_select_stmt comp_op sub_select_stmt<br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> ConditionSqlNode;<br>      $$-&gt;left_is_sub_query = <span class="hljs-literal">true</span>;<br>      $$-&gt;right_is_sub_query = <span class="hljs-literal">true</span>;<br>      $$-&gt;comp = $<span class="hljs-number">2</span>;<br>      $$-&gt;left_sub_query = $<span class="hljs-number">1</span>;<br>      $$-&gt;left_expression = <span class="hljs-literal">nullptr</span>;<br>      $$-&gt;right_sub_query = $<span class="hljs-number">3</span>;<br>      $$-&gt;right_expression = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    | sub_select_stmt comp_op expression<br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> ConditionSqlNode;<br>      $$-&gt;left_is_sub_query = <span class="hljs-literal">true</span>;<br>      $$-&gt;right_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;comp = $<span class="hljs-number">2</span>;<br>      $$-&gt;left_sub_query = $<span class="hljs-number">1</span>;<br>      $$-&gt;left_expression = <span class="hljs-literal">nullptr</span>;<br>      $$-&gt;right_expression = $<span class="hljs-number">3</span>;<br>    &#125;<br>    | expression comp_op expression<br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> ConditionSqlNode;<br>      $$-&gt;left_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;right_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;comp = $<span class="hljs-number">2</span>;<br>      $$-&gt;left_expression = $<span class="hljs-number">1</span>;<br>      $$-&gt;right_expression = $<span class="hljs-number">3</span>;<br>    &#125;<br>    | comp_op sub_select_stmt<br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> ConditionSqlNode;<br>      $$-&gt;left_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;right_is_sub_query = <span class="hljs-literal">true</span>;<br>      $$-&gt;right_sub_query = $<span class="hljs-number">2</span>;<br>      $$-&gt;comp = $<span class="hljs-number">1</span>;<br>      $$-&gt;left_expression = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ValueExpr</span>(<span class="hljs-built_in">Value</span>(<span class="hljs-number">114514</span>));<br>    &#125;<br>    | expression comp_op LBRACE value value_list RBRACE %prec HIGHER_THAN_EXPRESSION<br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> ConditionSqlNode;<br>      $$-&gt;left_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;right_is_sub_query = <span class="hljs-literal">false</span>;<br>      $$-&gt;comp = $<span class="hljs-number">2</span>;<br>      $$-&gt;left_expression = $<span class="hljs-number">1</span>;<br>      $<span class="hljs-number">5</span>-&gt;<span class="hljs-built_in">push_back</span>(*$<span class="hljs-number">4</span>);<br>      $$-&gt;right_expression = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ValueListExpr</span>(*$<span class="hljs-number">5</span>);<br>    &#125;<br>    ;<br></code></pre></td></tr></table></figure><p>在后面的日子中，我们将能改的都改成了 expression，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @brief 表达式类型</span><br><span class="hljs-comment"> * @ingroup Expression</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">ExprType</span> &#123;<br>  NONE,<br>  STAR,                 <span class="hljs-comment">///&lt; 星号，表示所有字段</span><br>  UNBOUND_FIELD,        <span class="hljs-comment">///&lt; 未绑定的字段，需要在resolver阶段解析为FieldExpr</span><br>  UNBOUND_TABLE,        <span class="hljs-comment">///&lt; 未绑定的表明，需要在resolver阶段提取别名和原名</span><br>  UNBOUND_AGGREGATION,  <span class="hljs-comment">///&lt; 未绑定的聚合函数，需要在resolver阶段解析为AggregateExpr</span><br><br>  ALIAS,        <span class="hljs-comment">///&lt; 别名</span><br>  FIELD,        <span class="hljs-comment">///&lt; 字段。在实际执行时，根据行数据内容提取对应字段的值</span><br>  JOINTABLE,    <span class="hljs-comment">///&lt; join 字段</span><br>  ORDERBY,      <span class="hljs-comment">///&lt; order 字段</span><br>  VALUE,        <span class="hljs-comment">///&lt; 常量值</span><br>  VALUELIST,    <span class="hljs-comment">///&lt; 常量值列表</span><br>  CAST,         <span class="hljs-comment">///&lt; 需要做类型转换的表达式</span><br>  COMPARISON,   <span class="hljs-comment">///&lt; 需要做比较的表达式</span><br>  CONJUNCTION,  <span class="hljs-comment">///&lt; 多个表达式使用同一种关系(AND或OR)来联结</span><br>  ARITHMETIC,   <span class="hljs-comment">///&lt; 算术运算</span><br>  AGGREGATION,  <span class="hljs-comment">///&lt; 聚合运算</span><br>  SUBQUERY,     <span class="hljs-comment">///&lt; 子查询</span><br>  FUNC,         <span class="hljs-comment">///&lt; 函数运算</span><br>  VECFUNC,      <span class="hljs-comment">///&lt; 向量函数运算</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="修改逻辑算子生成器"><a href="#修改逻辑算子生成器" class="headerlink" title="修改逻辑算子生成器"></a>修改逻辑算子生成器</h4><p>在逻辑算子的生成过程中，原始的 miniob 会将 Filter 中的 field&#x2F;value 变成表达式，很明显现在这是多此一举，对此进行修改。</p><p>需要注意的是，当一个 STMT 创建算子之后，原来的全部 unique_ptr 都会被移动走，在子查询里，应该还会看到这句话。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">RC <span class="hljs-title">LogicalPlanGenerator::create_plan</span><span class="hljs-params">(FilterStmt *filter_stmt, unique_ptr&lt;LogicalOperator&gt; &amp;logical_operator)</span> </span>&#123;<br>  RC rc = RC::SUCCESS;<br>  std::vector&lt;unique_ptr&lt;Expression&gt;&gt; cmp_exprs;<br>  ConjunctionExpr::Type conjunction_types = ConjunctionExpr::Type::AND;<br>  <span class="hljs-type">const</span> std::vector&lt;FilterUnit *&gt; &amp;filter_units = filter_stmt-&gt;<span class="hljs-built_in">filter_units</span>();<br>  <span class="hljs-keyword">for</span> (FilterUnit *filter_unit : filter_units) &#123;<br>    FilterObj &amp;filter_obj_left = filter_unit-&gt;<span class="hljs-built_in">left</span>();<br>    FilterObj &amp;filter_obj_right = filter_unit-&gt;<span class="hljs-built_in">right</span>();<br><br>    unique_ptr&lt;Expression&gt; left = std::<span class="hljs-built_in">move</span>(filter_obj_left.expr);<br>    unique_ptr&lt;Expression&gt; right = std::<span class="hljs-built_in">move</span>(filter_obj_right.expr);<br><br>    <span class="hljs-keyword">if</span> (filter_unit-&gt;<span class="hljs-built_in">conjunction_type</span>() == <span class="hljs-number">1</span>)<br>      conjunction_types = ConjunctionExpr::Type::AND;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (filter_unit-&gt;<span class="hljs-built_in">conjunction_type</span>() == <span class="hljs-number">2</span>)<br>      conjunction_types = ConjunctionExpr::Type::OR;<br><br>    <span class="hljs-type">bool</span> need_value_cast = left-&gt;<span class="hljs-built_in">value_type</span>() != AttrType::TUPLES &amp;&amp; right-&gt;<span class="hljs-built_in">value_type</span>() != AttrType::TUPLES &amp;&amp; left-&gt;<span class="hljs-built_in">type</span>() != ExprType::VALUELIST &amp;&amp;<br>                           right-&gt;<span class="hljs-built_in">type</span>() != ExprType::VALUELIST &amp;&amp; filter_unit-&gt;<span class="hljs-built_in">comp</span>() != CompOp::XXX_IS_NULL &amp;&amp;<br>                           filter_unit-&gt;<span class="hljs-built_in">comp</span>() != CompOp::XXX_IS_NOT_NULL;<br><br>    <span class="hljs-comment">// 如果左右两边的类型不一致，需要先计算转换开销，再进行隐式类型转换，同时要排除有子查询的情况</span><br>    <span class="hljs-keyword">if</span> (need_value_cast) &#123;<br>      Value left_value, right_value;<br>      left-&gt;<span class="hljs-built_in">try_get_value</span>(left_value);<br>      right-&gt;<span class="hljs-built_in">try_get_value</span>(right_value);<br>      <span class="hljs-keyword">if</span> (!left_value.<span class="hljs-built_in">get_null</span>() &amp;&amp; !right_value.<span class="hljs-built_in">get_null</span>() &amp;&amp; left-&gt;<span class="hljs-built_in">value_type</span>() != right-&gt;<span class="hljs-built_in">value_type</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> left_to_right_cost = <span class="hljs-built_in">implicit_cast_cost</span>(left-&gt;<span class="hljs-built_in">value_type</span>(), right-&gt;<span class="hljs-built_in">value_type</span>());<br>        <span class="hljs-keyword">auto</span> right_to_left_cost = <span class="hljs-built_in">implicit_cast_cost</span>(right-&gt;<span class="hljs-built_in">value_type</span>(), left-&gt;<span class="hljs-built_in">value_type</span>());<br>        <span class="hljs-keyword">if</span> (left_to_right_cost &lt;= right_to_left_cost &amp;&amp; left_to_right_cost != INT32_MAX) &#123;<br>          ExprType left_type = left-&gt;<span class="hljs-built_in">type</span>();<br><br>          <span class="hljs-comment">// 特殊判断，如果为 INTS 和 CHARS 比较大小，均转换成 FLOATS 类型</span><br>          unique_ptr&lt;CastExpr&gt; cast_expr;<br>          <span class="hljs-keyword">if</span> (left-&gt;<span class="hljs-built_in">value_type</span>() == AttrType::CHARS &amp;&amp; right-&gt;<span class="hljs-built_in">value_type</span>() == AttrType::INTS)<br>            cast_expr = <span class="hljs-built_in">make_unique</span>&lt;CastExpr&gt;(std::<span class="hljs-built_in">move</span>(left), AttrType::FLOATS);<br>          <span class="hljs-keyword">else</span><br>            cast_expr = <span class="hljs-built_in">make_unique</span>&lt;CastExpr&gt;(std::<span class="hljs-built_in">move</span>(left), right-&gt;<span class="hljs-built_in">value_type</span>());<br>          <span class="hljs-keyword">if</span> (left_type == ExprType::VALUE) &#123;<br>            Value left_val;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">OB_FAIL</span>(rc = cast_expr-&gt;<span class="hljs-built_in">try_get_value</span>(left_val))) &#123;<br>              <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to get value from left child&quot;</span>, <span class="hljs-built_in">strrc</span>(rc));<br>              <span class="hljs-keyword">return</span> rc;<br>            &#125;<br>            left = <span class="hljs-built_in">make_unique</span>&lt;ValueExpr&gt;(left_val);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            left = std::<span class="hljs-built_in">move</span>(cast_expr);<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right_to_left_cost &lt; left_to_right_cost &amp;&amp; right_to_left_cost != INT32_MAX) &#123;<br>          ExprType right_type = right-&gt;<span class="hljs-built_in">type</span>();<br><br>          <span class="hljs-comment">// 特殊判断，如果为 INTS 和 CHARS 比较大小，均转换成 FLOATS 类型</span><br>          unique_ptr&lt;CastExpr&gt; cast_expr;<br>          <span class="hljs-keyword">if</span> (left-&gt;<span class="hljs-built_in">value_type</span>() == AttrType::INTS &amp;&amp; right-&gt;<span class="hljs-built_in">value_type</span>() == AttrType::CHARS)<br>            cast_expr = <span class="hljs-built_in">make_unique</span>&lt;CastExpr&gt;(std::<span class="hljs-built_in">move</span>(right), AttrType::FLOATS);<br>          <span class="hljs-keyword">else</span><br>            cast_expr = <span class="hljs-built_in">make_unique</span>&lt;CastExpr&gt;(std::<span class="hljs-built_in">move</span>(right), left-&gt;<span class="hljs-built_in">value_type</span>());<br><br>          <span class="hljs-keyword">if</span> (right_type == ExprType::VALUE) &#123;<br>            Value right_val;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">OB_FAIL</span>(rc = cast_expr-&gt;<span class="hljs-built_in">try_get_value</span>(right_val))) &#123;<br>              <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to get value from right child&quot;</span>, <span class="hljs-built_in">strrc</span>(rc));<br>              <span class="hljs-keyword">return</span> rc;<br>            &#125;<br>            right = <span class="hljs-built_in">make_unique</span>&lt;ValueExpr&gt;(right_val);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = std::<span class="hljs-built_in">move</span>(cast_expr);<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (filter_unit-&gt;<span class="hljs-built_in">comp</span>() == CompOp::LIKE_XXX || filter_unit-&gt;<span class="hljs-built_in">comp</span>() == CompOp::NOT_LIKE_XXX) &#123;<br>          ExprType right_type = right-&gt;<span class="hljs-built_in">type</span>();<br><br>          <span class="hljs-comment">// 如果执行LIKE运算符，把右边转化成CHARS类型</span><br>          unique_ptr&lt;CastExpr&gt; cast_expr;<br>          cast_expr = <span class="hljs-built_in">make_unique</span>&lt;CastExpr&gt;(std::<span class="hljs-built_in">move</span>(right), AttrType::CHARS);<br><br>          <span class="hljs-keyword">if</span> (right_type == ExprType::VALUE) &#123;<br>            Value right_val;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">OB_FAIL</span>(rc = cast_expr-&gt;<span class="hljs-built_in">try_get_value</span>(right_val))) &#123;<br>              <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to get value from right child&quot;</span>, <span class="hljs-built_in">strrc</span>(rc));<br>              <span class="hljs-keyword">return</span> rc;<br>            &#125;<br>            right = <span class="hljs-built_in">make_unique</span>&lt;ValueExpr&gt;(right_val);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = std::<span class="hljs-built_in">move</span>(cast_expr);<br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          rc = RC::UNSUPPORTED;<br>          <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;unsupported cast from %s to %s&quot;</span>, <span class="hljs-built_in">attr_type_to_string</span>(left-&gt;<span class="hljs-built_in">value_type</span>()), <span class="hljs-built_in">attr_type_to_string</span>(right-&gt;<span class="hljs-built_in">value_type</span>()));<br>          <span class="hljs-keyword">return</span> rc;<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    ComparisonExpr *cmp_expr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ComparisonExpr</span>(filter_unit-&gt;<span class="hljs-built_in">comp</span>(), std::<span class="hljs-built_in">move</span>(left), std::<span class="hljs-built_in">move</span>(right));<br><br>    cmp_exprs.<span class="hljs-built_in">emplace_back</span>(cmp_expr);<br>  &#125;<br><br>  unique_ptr&lt;PredicateLogicalOperator&gt; predicate_oper;<br>  <span class="hljs-keyword">if</span> (!cmp_exprs.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-function">unique_ptr&lt;ConjunctionExpr&gt; <span class="hljs-title">conjunction_expr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> ConjunctionExpr(conjunction_types, cmp_exprs))</span></span>;<br>    predicate_oper = <span class="hljs-built_in">unique_ptr</span>&lt;PredicateLogicalOperator&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">PredicateLogicalOperator</span>(std::<span class="hljs-built_in">move</span>(conjunction_expr)));<br>  &#125;<br><br>  logical_operator = std::<span class="hljs-built_in">move</span>(predicate_oper);<br>  <span class="hljs-keyword">return</span> rc;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LogicalPlanGenerator::implicit_cast_cost</span><span class="hljs-params">(AttrType from, AttrType to)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (from == to) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> DataType::<span class="hljs-built_in">type_instance</span>(from)-&gt;<span class="hljs-built_in">cast_cost</span>(to);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="vector-basic"><a href="#vector-basic" class="headerlink" title="vector_basic"></a>vector_basic</h3><p><img src="/img/vector_basic.png"></p><p>相对简单的一道题目，需要添加一种数据类型：VECTOR</p><p>我们采取的方式为，对于 ‘[1, 2, 3, 4]’ 这样的向量，先以字符串的形式输入进来，在 Value 的构造函数中进行格式检验，如果符合向量的格式，那么将其转化为向量存储，否则以字符串的方式存储。</p><p>有些边角的东西没有体现在下面的描述中，包括：插入向量时的长度不匹配问题 + 创建表格时的 VECTOR 长度检验等</p><h4 id="Value-类的完善"><a href="#Value-类的完善" class="headerlink" title="Value 类的完善"></a>Value 类的完善</h4><p>首先，由于向量一定是 float 类型，所以实际的存储形式为 vector<float>。Value 中有个字段 len，表示 Value 的长度，注意这个长度是占用空间的长度，对于 vector 来说，这个长度是 vector.size() * 4。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// vector part</span><br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// 判断一个字符串是否为向量形式</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">isValidFormat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *input)</span></span>;<br>  <span class="hljs-comment">// 判断一个字符串是否为数字，避免 [1, a, 2] 这样的例子</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">isValidNumber</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;s)</span></span>;<br>  <span class="hljs-comment">// 将字符串转化为 vector，如果字符串不合法，返回 FAILURE</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> RC <span class="hljs-title">string_to_vector</span><span class="hljs-params">(string str, vector&lt;<span class="hljs-type">float</span>&gt; &amp;result)</span></span>;<br><br>  <span class="hljs-comment">// set and get</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_vector</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">float</span>&gt; value_vector)</span></span>;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">get_vector</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">get_vector_item</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_vector_size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>  std::vector&lt;<span class="hljs-type">float</span>&gt; value_vector_;<br></code></pre></td></tr></table></figure><p>isValidFormat, isValidNumber, string_to_vector 的设计如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// vector part</span><br><br><span class="hljs-comment">// 用于检查输入字符串是否符合 vector 的格式</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Value::isValidFormat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *input)</span> </span>&#123;<br>  <span class="hljs-comment">// 检查是否为空或长度小于2（必须至少包含 &quot;[]&quot;)</span><br>  <span class="hljs-keyword">if</span> (input == <span class="hljs-literal">nullptr</span> || <span class="hljs-built_in">strlen</span>(input) &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 检查首尾是否分别为 &#x27;[&#x27; 和 &#x27;]&#x27;</span><br>  <span class="hljs-keyword">if</span> (input[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;[&#x27;</span> || input[<span class="hljs-built_in">strlen</span>(input) - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 剔除 &#x27;[&#x27; 和 &#x27;]&#x27;，从第二个字符开始检查</span><br>  <span class="hljs-function">std::string <span class="hljs-title">content</span><span class="hljs-params">(input + <span class="hljs-number">1</span>, strlen(input) - <span class="hljs-number">2</span>)</span></span>;<br><br>  <span class="hljs-comment">// 删除多余的空格</span><br>  content.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">remove</span>(content.<span class="hljs-built_in">begin</span>(), content.<span class="hljs-built_in">end</span>(), <span class="hljs-string">&#x27; &#x27;</span>), content.<span class="hljs-built_in">end</span>());<br><br>  <span class="hljs-comment">// 使用逗号分割内容</span><br>  <span class="hljs-function">std::istringstream <span class="hljs-title">ss</span><span class="hljs-params">(content)</span></span>;<br>  std::string token;<br>  std::vector&lt;std::string&gt; tokens;<br><br>  <span class="hljs-comment">// 分割内容并检查每个部分</span><br>  <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(ss, token, <span class="hljs-string">&#x27;,&#x27;</span>)) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isValidNumber</span>(token)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 如果某个部分不是有效的数字，返回 false</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 所有部分都是有效的数字</span><br>&#125;<br><br><span class="hljs-comment">// 用于检查一个字符串是否是整数或浮点数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Value::isValidNumber</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;s)</span> </span>&#123;<br>  <span class="hljs-function">std::istringstream <span class="hljs-title">stream</span><span class="hljs-params">(s)</span></span>;<br>  <span class="hljs-type">float</span> number;<br>  stream &gt;&gt; number;<br>  <span class="hljs-comment">// 检查是否成功解析为数字，并且没有多余字符</span><br>  <span class="hljs-keyword">return</span> stream.<span class="hljs-built_in">eof</span>() &amp;&amp; !stream.<span class="hljs-built_in">fail</span>();<br>&#125;<br><br><span class="hljs-function">RC <span class="hljs-title">Value::string_to_vector</span><span class="hljs-params">(string str, vector&lt;<span class="hljs-type">float</span>&gt; &amp;result)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!Value::<span class="hljs-built_in">isValidFormat</span>(str.<span class="hljs-built_in">c_str</span>())) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br><br>  <span class="hljs-comment">// 剔除 &#x27;[&#x27; 和 &#x27;]&#x27;，从第二个字符开始检查</span><br>  str = str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">1</span>, (<span class="hljs-type">int</span>)str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>);<br><br>  <span class="hljs-comment">// 去除多余空格</span><br>  str.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">remove</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>(), <span class="hljs-string">&#x27; &#x27;</span>), str.<span class="hljs-built_in">end</span>());<br><br>  <span class="hljs-comment">// 使用逗号分割内容</span><br>  <span class="hljs-function">std::istringstream <span class="hljs-title">ss</span><span class="hljs-params">(str)</span></span>;<br>  std::string token;<br>  std::vector&lt;std::string&gt; tokens;<br><br>  <span class="hljs-comment">// 分割内容并检查每个部分</span><br>  <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(ss, token, <span class="hljs-string">&#x27;,&#x27;</span>)) &#123;<br>    result.<span class="hljs-built_in">push_back</span>(FloatType::formatFloat(std::<span class="hljs-built_in">stof</span>(token), <span class="hljs-number">2</span>));<br>  &#125;<br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来是 Value 输入为字符串的构造函数，如果发现字符串的格式为数组形式，那么转化为 VECTOR。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">Value::<span class="hljs-built_in">Value</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> len <span class="hljs-comment">/*= 0*/</span>) &#123;<br>  vector&lt;<span class="hljs-type">float</span>&gt; value_vector;<br>  RC rc = Value::<span class="hljs-built_in">string_to_vector</span>(s, value_vector);<br>  <span class="hljs-keyword">if</span> (rc == RC::SUCCESS)<br>    <span class="hljs-built_in">set_vector</span>(value_vector);<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-built_in">set_string</span>(s, len);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来是 Value 和 data 的转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Value::set_data</span><span class="hljs-params">(<span class="hljs-type">char</span> *data, <span class="hljs-type">int</span> length)</span> </span>&#123;<br>  <span class="hljs-keyword">switch</span> (attr_type_) &#123;<br>    <span class="hljs-keyword">case</span> AttrType::CHARS: &#123;<br>      <span class="hljs-built_in">set_string</span>(data, length);<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::INTS: &#123;<br>      value_.int_value_ = *(<span class="hljs-type">int</span> *)data;<br>      length_ = length;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::FLOATS: &#123;<br>      value_.float_value_ = *(<span class="hljs-type">float</span> *)data;<br>      length_ = length;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::BOOLEANS: &#123;<br>      value_.bool_value_ = *(<span class="hljs-type">int</span> *)data != <span class="hljs-number">0</span>;<br>      length_ = length;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::DATE: &#123;<br>      value_.int_value_ = *(<span class="hljs-type">int</span> *)data;<br>      length_ = length;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::VECTORS: &#123;<br>      <span class="hljs-type">size_t</span> element_size = <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>);<br>      <span class="hljs-type">size_t</span> num_elements = length / element_size;<br><br>      <span class="hljs-comment">// 使用 memcpy 将数据复制回 vector</span><br>      value_vector_.<span class="hljs-built_in">resize</span>(num_elements);<br>      <span class="hljs-built_in">memcpy</span>(value_vector_.<span class="hljs-built_in">data</span>(), data, length);<br>      length_ = length;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::TEXT: &#123;<br>      <span class="hljs-built_in">set_text</span>(data);<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>: &#123;<br>      <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;unknown data type: %d&quot;</span>, attr_type_);<br>    &#125; <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">Value::data</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">switch</span> (attr_type_) &#123;<br>    <span class="hljs-keyword">case</span> AttrType::TEXT: &#123;<br>      <span class="hljs-keyword">return</span> value_.pointer_value_;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::CHARS: &#123;<br>      <span class="hljs-keyword">return</span> value_.pointer_value_;<br>    &#125; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> AttrType::VECTORS: &#123;<br>      <span class="hljs-keyword">return</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)(value_vector_.<span class="hljs-built_in">data</span>());<br>    &#125;<br>    <span class="hljs-keyword">default</span>: &#123;<br>      <span class="hljs-keyword">return</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)&amp;value_;<br>    &#125; <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="VECTOR-的各种运算"><a href="#VECTOR-的各种运算" class="headerlink" title="VECTOR 的各种运算"></a>VECTOR 的各种运算</h4><p>在 common&#x2F;type 中，还需要完成有关 VECTOR 的各种计算、比较等。由于比较简单这里直接放上来了，不过需要注意的是，比赛要求向量的乘法是逐位相乘，也即两个向量的乘积仍为向量：[1, 2, 3] * [4, 5, 6] &#x3D; [4, 10, 18]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">VectorType::compare</span><span class="hljs-params">(<span class="hljs-type">const</span> Value &amp;left, <span class="hljs-type">const</span> Value &amp;right)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (left.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || right.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || left.<span class="hljs-built_in">get_vector_size</span>() != right.<span class="hljs-built_in">get_vector_size</span>())<br>    <span class="hljs-keyword">return</span> INT32_MAX;<br>  <span class="hljs-type">int</span> size = (<span class="hljs-type">int</span>)left.<span class="hljs-built_in">get_vector_size</span>();<br>  <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>    <span class="hljs-keyword">if</span> (left.<span class="hljs-built_in">get_vector</span>()[i] &gt; right.<span class="hljs-built_in">get_vector</span>()[i]) &#123;<br>      result = <span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (left.<span class="hljs-built_in">get_vector</span>()[i] &lt; right.<span class="hljs-built_in">get_vector</span>()[i]) &#123;<br>      result = <span class="hljs-number">-1</span>;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function">RC <span class="hljs-title">VectorType::add</span><span class="hljs-params">(<span class="hljs-type">const</span> Value &amp;left, <span class="hljs-type">const</span> Value &amp;right, Value &amp;result)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (left.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || right.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || left.<span class="hljs-built_in">get_vector_size</span>() != right.<span class="hljs-built_in">get_vector_size</span>())<br>    <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>  <span class="hljs-type">int</span> size = (<span class="hljs-type">int</span>)left.<span class="hljs-built_in">get_vector_size</span>();<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">answer</span><span class="hljs-params">(size, <span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) answer[i] = left.<span class="hljs-built_in">get_vector</span>()[i] + right.<span class="hljs-built_in">get_vector</span>()[i];<br>  result.<span class="hljs-built_in">set_vector</span>(answer);<br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br><span class="hljs-function">RC <span class="hljs-title">VectorType::subtract</span><span class="hljs-params">(<span class="hljs-type">const</span> Value &amp;left, <span class="hljs-type">const</span> Value &amp;right, Value &amp;result)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (left.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || right.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || left.<span class="hljs-built_in">get_vector_size</span>() != right.<span class="hljs-built_in">get_vector_size</span>())<br>    <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>  <span class="hljs-type">int</span> size = (<span class="hljs-type">int</span>)left.<span class="hljs-built_in">get_vector_size</span>();<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">answer</span><span class="hljs-params">(size, <span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) answer[i] = left.<span class="hljs-built_in">get_vector</span>()[i] - right.<span class="hljs-built_in">get_vector</span>()[i];<br>  result.<span class="hljs-built_in">set_vector</span>(answer);<br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br><span class="hljs-function">RC <span class="hljs-title">VectorType::multiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Value &amp;left, <span class="hljs-type">const</span> Value &amp;right, Value &amp;result)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (left.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || right.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS || left.<span class="hljs-built_in">get_vector_size</span>() != right.<span class="hljs-built_in">get_vector_size</span>())<br>    <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>  <span class="hljs-type">int</span> size = (<span class="hljs-type">int</span>)left.<span class="hljs-built_in">get_vector_size</span>();<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">float</span>&gt; <span class="hljs-title">answer</span><span class="hljs-params">(size, <span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) answer[i] = left.<span class="hljs-built_in">get_vector</span>()[i] * right.<span class="hljs-built_in">get_vector</span>()[i];<br>  result.<span class="hljs-built_in">set_vector</span>(answer);<br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br><br><span class="hljs-function">RC <span class="hljs-title">VectorType::to_string</span><span class="hljs-params">(<span class="hljs-type">const</span> Value &amp;val, string &amp;result)</span> <span class="hljs-type">const</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (val.<span class="hljs-built_in">attr_type</span>() != AttrType::VECTORS) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br><br>  result = <span class="hljs-string">&quot;[&quot;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : val.<span class="hljs-built_in">get_vector</span>()) &#123;<br>    it = FloatType::formatFloat(it, <span class="hljs-number">2</span>);<br>    string str = std::<span class="hljs-built_in">to_string</span>(it);<br>    str = FloatType::formatFloat_s(it, <span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// 去除后导零</span><br>    str.<span class="hljs-built_in">erase</span>(str.<span class="hljs-built_in">find_last_not_of</span>(<span class="hljs-string">&#x27;0&#x27;</span>) + <span class="hljs-number">1</span>, std::string::npos);<br>    <span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">back</span>() == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>      str.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    result += str;<br>    result += <span class="hljs-string">&#x27;,&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">int</span>)result.<span class="hljs-built_in">length</span>() &gt; <span class="hljs-number">1</span>) result.<span class="hljs-built_in">pop_back</span>();<br>  result += <span class="hljs-string">&quot;]&quot;</span>;<br><br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="vector-format"><a href="#vector-format" class="headerlink" title="vector_format"></a>vector_format</h3><p><img src="/img/vector_format.png"></p><p>题目要求不仅要识别字符串类型的向量数据，还需要识别不带引号的向量数据。我在写的时候偷懒了，直接采取 [ + value + value_list + ]，所以只需要在 yacc 中添加这一条规则即可。</p><h4 id="lex-和-yacc-完善"><a href="#lex-和-yacc-完善" class="headerlink" title="lex 和 yacc 完善"></a>lex 和 yacc 完善</h4><p>lex 需要添加左右中括号的词语：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-string">&quot;[&quot;</span>                                     <span class="hljs-built_in">RETURN_TOKEN</span>(LBRACKET);<br><span class="hljs-string">&quot;]&quot;</span>                                     <span class="hljs-built_in">RETURN_TOKEN</span>(RBRACKET);<br></code></pre></td></tr></table></figure><p>yacc 需要添加对向量变量的识别：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">value:<br>    LBRACKET value value_list RBRACKET &#123;<br>      std::vector&lt;<span class="hljs-type">float</span>&gt; nums;<br>      nums.<span class="hljs-built_in">emplace_back</span>($<span class="hljs-number">2</span>-&gt;<span class="hljs-built_in">get_float</span>());<br>      <span class="hljs-keyword">if</span>($<span class="hljs-number">3</span> != <span class="hljs-literal">nullptr</span>) &#123;<br>        std::<span class="hljs-built_in">reverse</span>($<span class="hljs-number">3</span>-&gt;<span class="hljs-built_in">begin</span>(), $<span class="hljs-number">3</span>-&gt;<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (Value value : *$<span class="hljs-number">3</span>) &#123;<br>          nums.<span class="hljs-built_in">emplace_back</span>(value.<span class="hljs-built_in">get_float</span>());<br>        &#125;<br>      &#125;<br>      $$ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Value</span>(nums);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="join-tables"><a href="#join-tables" class="headerlink" title="join-tables"></a>join-tables</h3><p><img src="/img/join_tables.png"></p><p>join-tables 所涉及的算子在初始工程已经很完善了。简单来说，对于一条 select 语句可能有多个目标表格，其中第一个目标表格为主表格，后面的表格会跟主表格一并做笛卡尔积。创建算子的时候，第一个表格会创建 TableGet 相关算子，后面的表格会创建 JoinTable 相关算子。</p><p>对于 INNERJOIN，ON 中定义的谓词逻辑和 WHERE 中定义的谓词逻辑是完全平等的，所以，对于 ON 中的全部谓词逻辑，我们只需要将其视作 WHERE 中通过 AND 连结词连在一起的即可。</p><p>对于 join 部分，将其视作一个表达式，原因见 expression。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// *********************************************************</span><br><span class="hljs-comment">// * 表格连接表达式</span><br><span class="hljs-comment">// *</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JoinTableExpr</span> : <span class="hljs-keyword">public</span> Expression &#123;<br> <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">JoinTableExpr</span>(std::vector&lt;ConditionSqlNode&gt; conditions, unique_ptr&lt;Expression&gt; child) : <span class="hljs-built_in">conditions_</span>(conditions), <span class="hljs-built_in">child_</span>(std::<span class="hljs-built_in">move</span>(child)) &#123;&#125;<br>  <span class="hljs-built_in">JoinTableExpr</span>(std::vector&lt;ConditionSqlNode&gt; conditions, Expression *child) : <span class="hljs-built_in">conditions_</span>(conditions), <span class="hljs-built_in">child_</span>(child) &#123;&#125;<br><br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">JoinTableExpr</span>() = <span class="hljs-keyword">default</span>;<br><br>  <span class="hljs-function">ExprType <span class="hljs-title">type</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> ExprType::JOINTABLE; &#125;<br>  <span class="hljs-function">AttrType <span class="hljs-title">value_type</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> AttrType::UNDEFINED; &#125;<br><br>  <span class="hljs-function">RC <span class="hljs-title">get_value</span><span class="hljs-params">(<span class="hljs-type">const</span> Tuple &amp;tuple, Value &amp;value)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> RC::INTERNAL; &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">const</span> std::vector&lt;ConditionSqlNode&gt; <span class="hljs-title">conditions</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> conditions_; &#125;<br>  <span class="hljs-function"><span class="hljs-type">const</span> std::unique_ptr&lt;Expression&gt; &amp;<span class="hljs-title">child</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> child_; &#125;<br><br> <span class="hljs-keyword">private</span>:<br>  std::vector&lt;ConditionSqlNode&gt; conditions_;<br>  std::unique_ptr&lt;Expression&gt; child_;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="lex-和-yacc-的完善"><a href="#lex-和-yacc-的完善" class="headerlink" title="lex 和 yacc 的完善"></a>lex 和 yacc 的完善</h4><p>lex 需要完善对 JOIN&#x2F;INNER JOIN&#x2F;ON 的识别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">JOIN|INNER[ \t]+<span class="hljs-function">JOIN                    <span class="hljs-title">RETURN_TOKEN</span><span class="hljs-params">(INNER_JOIN)</span></span>;<br><span class="hljs-function">ON                                      <span class="hljs-title">RETURN_TOKEN</span><span class="hljs-params">(ON)</span></span>;<br></code></pre></td></tr></table></figure><p>对于 join 子句的部分，创建一个 expression 数组，数组的 expression 类型为 JoinTableExpr，每一个 JoinTableExpr 包含 join 的表格以及谓词逻辑语句。</p><p>select_stmt 也需要加入 join_list 部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++">join_list:<br>    <span class="hljs-comment">/* empty */</span><br>    &#123;<br>      $$ = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    | INNER_JOIN relation ON condition_list join_list &#123;<br>      <span class="hljs-keyword">if</span> ($<span class="hljs-number">5</span> != <span class="hljs-literal">nullptr</span>) &#123;<br>        $$ = $<span class="hljs-number">5</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        $$ = <span class="hljs-keyword">new</span> std::vector&lt;std::unique_ptr&lt;Expression&gt;&gt;;<br>      &#125;<br>      $$-&gt;<span class="hljs-built_in">emplace_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">JoinTableExpr</span>(*$<span class="hljs-number">4</span>, $<span class="hljs-number">2</span>));<br>    &#125;<br>    ;<br></code></pre></td></tr></table></figure><h4 id="select-stmt-的完善"><a href="#select-stmt-的完善" class="headerlink" title="select_stmt 的完善"></a>select_stmt 的完善</h4><p>在创建 SelectStmt 时，需要将 join 的表格和谓词语句添加到 select 语句中的表格列表和谓词语句列表中。谓词语句顺序无所谓，但是表格的顺序会影响输出表头的顺序，所以需要严格按照 JOIN 出现的顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// *****************************************************************************</span><br>  <span class="hljs-comment">// * 将节点中的 join 添加到 conditions 以及 relations 当中</span><br>  <span class="hljs-comment">// *    在之后的处理中，如果查询的表格有多个，就会计算全部表格的笛卡尔积</span><br>  <span class="hljs-comment">// *    join 等价于先求笛卡尔积，然后进行选择运算</span><br>  <span class="hljs-comment">// *    所以需要将选择条件也加进 conditions 中(目前全是 AND 运算，所以可以这么处理)</span><br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; select_sql.join.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    JoinTableExpr *join_table_expr = <span class="hljs-built_in">static_cast</span>&lt;JoinTableExpr *&gt;(select_sql.join[i].<span class="hljs-built_in">get</span>());<br>    UnboundTableExpr *table_expr = <span class="hljs-built_in">static_cast</span>&lt;UnboundTableExpr *&gt;(join_table_expr-&gt;<span class="hljs-built_in">child</span>().<span class="hljs-built_in">get</span>());<br>    unique_ptr&lt;Expression&gt; temp = <span class="hljs-built_in">make_unique</span>&lt;UnboundTableExpr&gt;(table_expr-&gt;<span class="hljs-built_in">table_name</span>(), table_expr-&gt;<span class="hljs-built_in">table_alias</span>());<br>    select_sql.relations.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">move</span>(temp));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> condition : join_table_expr-&gt;<span class="hljs-built_in">conditions</span>()) select_sql.conditions.<span class="hljs-built_in">emplace_back</span>(condition);<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p><img src="/img/null.png"></p><p>题目要求支持一种特殊的数据类型：null，它不属于任何普通类型，却又能匹配任何普通类型。</p><p>整体来说，需要完成以下内容：</p><ol><li>支持识别关键字 NULL IS NOT 等</li><li>支持创建表格时对特定域声明 NULL or NOT NULL &#x3D; default</li><li>Value 类中添加对 NULL 的管理</li><li>支持插入数据时插入 NULL，并判断合法性</li><li>支持更新数据时更新 NULL，并判断合法性</li><li>支持谓词逻辑普通运算符对 NULL 计算，以及谓词逻辑新增运算 IS NULL and IS NOT NULL</li></ol><p>额外需要考虑的一点为，Value 会被转换成 Record 写入内存，也即实际写入内存的是 01 串，而通过 01 串并不能知道这是什么类型。假设某个域类型为 INT，它可以通过表头信息知道：从该列拿出来的数据一定是 INT 类型，所以可以将 01 串按照 INT 的存储规则还原，但是对于 NULL 类型，由于其可以匹配任意类型，所以并不能通过某处记录的信息来得知拿出来的数据为 NULL 类型。</p><p>我们的处理是 bitmap 或者 写入特殊字符，使用 bitmap 会导致后面的并发 update 报错，至比赛结束仍不知道原因。不过 bitmap 无疑是最优美的解决方案。</p><blockquote><p>—- WARING  下文有狗屎 —-</p></blockquote><p>所以我们的处理方法是，对于一个 x 字节的数据，如果它的类型为 NULL，则向内存写入数据时，写入 x 字节的 ÿ，就是如此抽象。拿出数据时，首先检验 01 串是否为 x 字节的 ÿ 的 ASCII 码，<br>如果是则还原成 NULL，不是则根据表头信息等还原。</p><h4 id="支持识别关键字-NULL-IS-NOT-等"><a href="#支持识别关键字-NULL-IS-NOT-等" class="headerlink" title="支持识别关键字 NULL IS NOT 等"></a>支持识别关键字 NULL IS NOT 等</h4><p>lex 中需要添加新的词语解析</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">NULL                                    <span class="hljs-built_in">RETURN_TOKEN</span>(NULLABLE);<br>NOT<span class="hljs-selector-attr">[ \t]</span>+NULL                           <span class="hljs-built_in">RETURN_TOKEN</span>(UNNULLABLE);<br>IS<span class="hljs-selector-attr">[ \t]</span>+NULL                            <span class="hljs-built_in">RETURN_TOKEN</span>(IS_NULL);<br>IS<span class="hljs-selector-attr">[ \t]</span>+NOT+<span class="hljs-selector-attr">[ \t]</span>+NULL                  <span class="hljs-built_in">RETURN_TOKEN</span>(IS_NOT_NULL);<br></code></pre></td></tr></table></figure><h4 id="支持创建表格时对特定域声明-NULL-or-NOT-NULL-default"><a href="#支持创建表格时对特定域声明-NULL-or-NOT-NULL-default" class="headerlink" title="支持创建表格时对特定域声明 NULL or NOT NULL &#x3D; default"></a>支持创建表格时对特定域声明 NULL or NOT NULL &#x3D; default</h4><p>yacc 中需要添加新的语法解析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 运算符</span><br>comp_op:<br>    ...<br>    | IS_NULL &#123; $$ = XXX_IS_NULL; &#125;<br>    | IS_NOT_NULL &#123; $$ = XXX_IS_NOT_NULL; &#125;<br>    | NOT_LIKE &#123; $$ = NOT_LIKE_XXX; &#125;<br>    ...<br>    ;<br><span class="hljs-comment">// 创建表格时的声明</span><br>attr_def:<br>    ID type LBRACE number RBRACE null_def <br>    &#123;<br>      $$ = <span class="hljs-keyword">new</span> AttrInfoSqlNode;<br>      $$-&gt;type = (AttrType)$<span class="hljs-number">2</span>;<br>      $$-&gt;name = $<span class="hljs-number">1</span>;<br>      $$-&gt;length = $<span class="hljs-number">4</span>;<br>      $$-&gt;can_be_null = $<span class="hljs-number">6</span>;<br><br>      ...<br><br>      <span class="hljs-built_in">free</span>($<span class="hljs-number">1</span>);<br>    &#125;<br><span class="hljs-comment">// null</span><br>null_def:<br>    &#123;<br>      $$ = <span class="hljs-literal">false</span>;<br>    &#125;<br>    | NULLABLE &#123;<br>      $$ = <span class="hljs-literal">true</span>;<br>    &#125;<br>    | UNNULLABLE &#123;<br>      $$ = <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="Value-类中添加对-NULL-的管理"><a href="#Value-类中添加对-NULL-的管理" class="headerlink" title="Value 类中添加对 NULL 的管理"></a>Value 类中添加对 NULL 的管理</h4><p>Value 中添加标志位 is_null_，用于判断 Value 是否为 NULL。同时还需要维护各种构造函数，拷贝函数，运算符重载有关 NULL 的问题。同时 NULL 数据转化为 char * 写入内存的<br>时候要转换成若干个 ÿ。</p><h4 id="支持插入数据时插入-NULL，并判断合法性"><a href="#支持插入数据时插入-NULL，并判断合法性" class="headerlink" title="支持插入数据时插入 NULL，并判断合法性"></a>支持插入数据时插入 NULL，并判断合法性</h4><p>在将 Value 转化为 Record 时，需要额外做一步判断。如果插入的数据为 NULL 且该域不允许为 NULL，返回 FAILURE。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">RC <span class="hljs-title">Table::make_record</span><span class="hljs-params">(<span class="hljs-type">int</span> value_num, <span class="hljs-type">const</span> Value *values, Record &amp;record)</span> </span>&#123;<br>  RC rc = RC::SUCCESS;<br>  <span class="hljs-comment">// 检查属性数量是否一致</span><br>  <span class="hljs-keyword">if</span> (value_num + table_meta_.<span class="hljs-built_in">sys_field_num</span>() != table_meta_.<span class="hljs-built_in">field_num</span>()) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;Input values don&#x27;t match the table&#x27;s schema, table name:%s&quot;</span>, table_meta_.<span class="hljs-built_in">name</span>());<br>    <span class="hljs-keyword">return</span> RC::SCHEMA_FIELD_MISSING;<br>  &#125;<br><br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> normal_field_start_index = table_meta_.<span class="hljs-built_in">sys_field_num</span>();<br>  <span class="hljs-comment">// 复制所有字段的值</span><br>  <span class="hljs-type">int</span> record_size = table_meta_.<span class="hljs-built_in">record_size</span>();<br>  <span class="hljs-type">char</span> *record_data = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(record_size);<br>  <span class="hljs-built_in">memset</span>(record_data, <span class="hljs-number">0</span>, record_size);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; value_num &amp;&amp; <span class="hljs-built_in">OB_SUCC</span>(rc); i++) &#123;<br>    <span class="hljs-type">const</span> FieldMeta *field = table_meta_.<span class="hljs-built_in">field</span>(i + normal_field_start_index);<br>    Value value = values[i];<br><br>    <span class="hljs-comment">// 当插入数据 NULL 时，做一次检验</span><br>    <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">get_null</span>()) &#123;<br>      <span class="hljs-keyword">if</span> (field-&gt;<span class="hljs-built_in">can_be_null</span>() == <span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to insert NULL to NOT_NULL field&quot;</span>);<br>        <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>      &#125;<br>      rc = <span class="hljs-built_in">set_value_to_record</span>(record_data, value, field, i);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (field-&gt;<span class="hljs-built_in">type</span>() != value.<span class="hljs-built_in">attr_type</span>()) &#123;<br>      Value real_value;<br>      rc = Value::<span class="hljs-built_in">cast_to</span>(value, field-&gt;<span class="hljs-built_in">type</span>(), real_value);<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">OB_FAIL</span>(rc)) &#123;<br>        <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to cast value. table name:%s,field name:%s,value:%s &quot;</span>, table_meta_.<span class="hljs-built_in">name</span>(), field-&gt;<span class="hljs-built_in">name</span>(), value.<span class="hljs-built_in">to_string</span>().<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>      rc = <span class="hljs-built_in">set_value_to_record</span>(record_data, real_value, field, i);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      rc = <span class="hljs-built_in">set_value_to_record</span>(record_data, value, field, i);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">OB_FAIL</span>(rc)) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to make record. table name:%s&quot;</span>, table_meta_.<span class="hljs-built_in">name</span>());<br>    <span class="hljs-built_in">free</span>(record_data);<br>    <span class="hljs-keyword">return</span> rc;<br>  &#125;<br><br>  record.<span class="hljs-built_in">set_data_owner</span>(record_data, record_size);<br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时转换为 Record 时，也需要考虑 NULL 的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">get_null</span>()) &#123;<br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *flag = <span class="hljs-string">&quot;ÿÿÿÿ&quot;</span>;<br>  <span class="hljs-built_in">memcpy</span>(record_data + field-&gt;<span class="hljs-built_in">offset</span>(), flag, std::<span class="hljs-built_in">min</span>(field-&gt;<span class="hljs-built_in">len</span>(), <span class="hljs-number">4</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="支持更新数据时更新-NULL，并判断合法性"><a href="#支持更新数据时更新-NULL，并判断合法性" class="headerlink" title="支持更新数据时更新 NULL，并判断合法性"></a>支持更新数据时更新 NULL，并判断合法性</h4><p>和插入数据区别不大，也是需要额外添加一层判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 检查所有更新字段是否全部有效</span><br><span class="hljs-function">RC <span class="hljs-title">Table::update_records</span><span class="hljs-params">(Record &amp;record, std::vector&lt;std::pair&lt;Value, FieldMeta&gt;&gt; update_map_)</span> </span>&#123;<br>  <span class="hljs-comment">// 遍历表格的全部域，找到目标域</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> sys_field_num = table_meta_.<span class="hljs-built_in">sys_field_num</span>();<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> user_field_num = table_meta_.<span class="hljs-built_in">field_num</span>() - sys_field_num;<br>  FieldMeta *targetFiled = <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : update_map_) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; user_field_num; i++) &#123;<br>      <span class="hljs-type">const</span> FieldMeta *field_meta = table_meta_.<span class="hljs-built_in">field</span>(sys_field_num + i);<br>      <span class="hljs-type">const</span> <span class="hljs-type">char</span> *field_name = field_meta-&gt;<span class="hljs-built_in">name</span>();<br><br>      <span class="hljs-comment">// 找到目标域</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(field_name, it.second.<span class="hljs-built_in">name</span>()) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 判断 NULL 值</span><br>        <span class="hljs-keyword">if</span> (it.first.<span class="hljs-built_in">get_null</span>()) &#123;<br>          <span class="hljs-keyword">if</span> (field_meta-&gt;<span class="hljs-built_in">can_be_null</span>() == <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>        &#125;<br>        <span class="hljs-comment">// 类型匹配检查</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (field_meta-&gt;<span class="hljs-built_in">type</span>() != it.first.<span class="hljs-built_in">attr_type</span>()) &#123;<br>          Value real_value;<br>          RC rc = Value::<span class="hljs-built_in">cast_to</span>(it.first, field_meta-&gt;<span class="hljs-built_in">type</span>(), real_value);<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">OB_FAIL</span>(rc)) <span class="hljs-keyword">return</span> rc;<br>        &#125;<br><br>        <span class="hljs-comment">// 拿到目标域</span><br>        targetFiled = (FieldMeta *)field_meta;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 域存在检查</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == targetFiled) &#123;<br>      <span class="hljs-keyword">return</span> RC::SCHEMA_FIELD_NOT_EXIST;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 暂时备份旧数据</span><br>  <span class="hljs-type">char</span> *old_data = record.<span class="hljs-built_in">data</span>();<br>  <span class="hljs-type">char</span> *backup_data = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(record.<span class="hljs-built_in">len</span>());<br>  <span class="hljs-built_in">memcpy</span>(backup_data, old_data, record.<span class="hljs-built_in">len</span>());<br><br>  <span class="hljs-comment">// 所有字段均可更新，开始更新</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : update_map_) &#123;<br>    RC rc = <span class="hljs-built_in">update_record</span>(record, it.second.<span class="hljs-built_in">name</span>(), &amp;it.first);<br>    <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>  &#125;<br><br>  <span class="hljs-comment">// 如果有索引，更新索引，顺便检查如果是唯一索引，那么是否有重复</span><br>  std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span> *&gt; update_fields;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : update_map_) &#123;<br>    update_fields.<span class="hljs-built_in">push_back</span>(it.second.<span class="hljs-built_in">name</span>());<br>  &#125;<br>  Index *index = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">find_index_by_fields</span>(update_fields);<br>  <span class="hljs-comment">// 只检查多索引，单列索引交给 update_record 处理</span><br>  <span class="hljs-keyword">if</span> (index != <span class="hljs-literal">nullptr</span> &amp;&amp; update_fields.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>    RC rc = index-&gt;<span class="hljs-built_in">insert_entry</span>(record.<span class="hljs-built_in">data</span>(), &amp;record.<span class="hljs-built_in">rid</span>());<br>    <span class="hljs-keyword">if</span> (rc != RC::SUCCESS &amp;&amp; <span class="hljs-built_in">strcmp</span>(old_data, backup_data) != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;Failed to update data, recovering. table=%s, rc=%d:%s&quot;</span>, <span class="hljs-built_in">name</span>(), rc, <span class="hljs-built_in">strrc</span>(rc));<br>      <span class="hljs-keyword">return</span> rc;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br><br><span class="hljs-comment">// 更新一个字段</span><br><span class="hljs-function">RC <span class="hljs-title">Table::update_record</span><span class="hljs-params">(Record &amp;record, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *attr_name, Value *value)</span> </span>&#123;<br>  <span class="hljs-comment">// 遍历表格的全部域，找到目标域</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> sys_field_num = table_meta_.<span class="hljs-built_in">sys_field_num</span>();<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> user_field_num = table_meta_.<span class="hljs-built_in">field_num</span>() - sys_field_num;<br>  FieldMeta *targetFiled = <span class="hljs-literal">nullptr</span>;<br><br>  <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (; i &lt; user_field_num; i++) &#123;<br>    <span class="hljs-type">const</span> FieldMeta *field_meta = table_meta_.<span class="hljs-built_in">field</span>(sys_field_num + i);<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *field_name = field_meta-&gt;<span class="hljs-built_in">name</span>();<br><br>    <span class="hljs-comment">// 找到目标域</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(field_name, attr_name) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 判断 NULL 值</span><br>      <span class="hljs-keyword">if</span> (value-&gt;<span class="hljs-built_in">get_null</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (field_meta-&gt;<span class="hljs-built_in">can_be_null</span>() == <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>      &#125;<br>      <span class="hljs-comment">// 类型匹配检查</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (field_meta-&gt;<span class="hljs-built_in">type</span>() != value-&gt;<span class="hljs-built_in">attr_type</span>()) &#123;<br>        Value real_value;<br>        RC rc = Value::<span class="hljs-built_in">cast_to</span>(*value, field_meta-&gt;<span class="hljs-built_in">type</span>(), real_value);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">OB_FAIL</span>(rc)) <span class="hljs-keyword">return</span> rc;<br>        *value = std::<span class="hljs-built_in">move</span>(real_value);<br>      &#125;<br><br>      <span class="hljs-comment">// 拿到目标域</span><br>      targetFiled = (FieldMeta *)field_meta;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 域存在检查</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == targetFiled) &#123;<br>    <span class="hljs-keyword">return</span> RC::SCHEMA_FIELD_NOT_EXIST;<br>  &#125;<br><br>  <span class="hljs-type">int</span> field_offset = targetFiled-&gt;<span class="hljs-built_in">offset</span>();<br>  <span class="hljs-type">int</span> field_length = targetFiled-&gt;<span class="hljs-built_in">len</span>();<br><br>  <span class="hljs-comment">// 修改旧数据</span><br>  <span class="hljs-type">char</span> *old_data = record.<span class="hljs-built_in">data</span>();<br><br>  <span class="hljs-comment">// 暂时备份旧数据</span><br>  <span class="hljs-type">char</span> *backup_data = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(record.<span class="hljs-built_in">len</span>());<br>  <span class="hljs-built_in">memcpy</span>(backup_data, old_data, record.<span class="hljs-built_in">len</span>());<br><br>  <span class="hljs-keyword">if</span> (value-&gt;<span class="hljs-built_in">length</span>() &gt; field_length &amp;&amp; targetFiled-&gt;<span class="hljs-built_in">type</span>() != AttrType::VECTORS) &#123;<br>    <span class="hljs-built_in">memcpy</span>(old_data + field_offset, value-&gt;<span class="hljs-built_in">data</span>(), field_length);<br>  &#125;<br>  ...<br>  <span class="hljs-comment">// 对于 CHARS</span><br>  <span class="hljs-comment">// 这种不定长的记录，如果更新的元素小于原来的长度，需要额外抹去原有元素</span><br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">memcpy</span>(old_data + field_offset, value-&gt;<span class="hljs-built_in">data</span>(), value-&gt;<span class="hljs-built_in">length</span>());<br>    <span class="hljs-built_in">memset</span>(old_data + field_offset + value-&gt;<span class="hljs-built_in">length</span>(), <span class="hljs-number">0</span>, field_length - value-&gt;<span class="hljs-built_in">length</span>());<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (value-&gt;<span class="hljs-built_in">get_null</span>()) &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *flag = <span class="hljs-string">&quot;ÿÿÿÿ&quot;</span>;<br>    <span class="hljs-built_in">memcpy</span>(old_data + field_offset, flag, std::<span class="hljs-built_in">min</span>(<span class="hljs-number">4</span>, field_length));<br>  &#125;<br><br>  record.<span class="hljs-built_in">set_data</span>(old_data);<br><br>  Index *index = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">find_index_by_field</span>(targetFiled-&gt;<span class="hljs-built_in">name</span>());<br><br>  <span class="hljs-comment">// 单字段索引更新和检查</span><br>  <span class="hljs-keyword">if</span> (index != <span class="hljs-literal">nullptr</span>) &#123;<br>    RC rc = index-&gt;<span class="hljs-built_in">insert_entry</span>(record.<span class="hljs-built_in">data</span>(), &amp;record.<span class="hljs-built_in">rid</span>());<br>    <span class="hljs-keyword">if</span> (rc != RC::SUCCESS &amp;&amp; <span class="hljs-built_in">strcmp</span>(old_data, backup_data) != <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;Failed to update data, recovering. table=%s, rc=%d:%s&quot;</span>, <span class="hljs-built_in">name</span>(), rc, <span class="hljs-built_in">strrc</span>(rc));<br>      <span class="hljs-keyword">return</span> rc;<br>    &#125;<br>  &#125;<br><br>  record_handler_-&gt;<span class="hljs-built_in">update_record</span>(&amp;record);<br>  <span class="hljs-comment">// delete old_data;</span><br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="支持谓词逻辑普通运算符对-NULL-计算，以及谓词逻辑新增运算-IS-NULL-and-IS-NOT-NULL"><a href="#支持谓词逻辑普通运算符对-NULL-计算，以及谓词逻辑新增运算-IS-NULL-and-IS-NOT-NULL" class="headerlink" title="支持谓词逻辑普通运算符对 NULL 计算，以及谓词逻辑新增运算 IS NULL and IS NOT NULL"></a>支持谓词逻辑普通运算符对 NULL 计算，以及谓词逻辑新增运算 IS NULL and IS NOT NULL</h4><p>由于 Compare 部分我们写的比较复杂，这边只展示有关 IS NULL and IS NOT NULL 的函数，对于普通运算符，只需要在最上方判断：如果为 NULL，直接返回 false。不过需要注意，后面涉及到排序题目的时候，不能无脑返回 false，需要特殊考虑 NULL 和 NULL 的比较。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IS_NULL_Compare</span><span class="hljs-params">(CompType type_, <span class="hljs-type">const</span> Value &amp;left, <span class="hljs-type">const</span> Value &amp;right, <span class="hljs-type">const</span> std::vector&lt;Value&gt; left_list, <span class="hljs-type">const</span> std::vector&lt;Value&gt; right_list,</span></span><br><span class="hljs-params"><span class="hljs-function">                     <span class="hljs-type">const</span> std::vector&lt;std::vector&lt;Value&gt;&gt; left_tuple_list, <span class="hljs-type">const</span> std::vector&lt;std::vector&lt;Value&gt;&gt; right_tuple_list)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (type_ == CompType::VAL_LIST || type_ == CompType::VAL_VAL || type_ == CompType::VAL_TUPLES) &#123;<br>    <span class="hljs-keyword">return</span> left.<span class="hljs-built_in">get_null</span>();<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!left_list.<span class="hljs-built_in">empty</span>() &amp;&amp; type_ == CompType::LIST_VAL) &#123;<br>    <span class="hljs-keyword">return</span> left_list[<span class="hljs-number">0</span>].<span class="hljs-built_in">get_null</span>();<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!left_tuple_list.<span class="hljs-built_in">empty</span>() &amp;&amp; type_ == CompType::TUPLES_VAL) &#123;<br>    <span class="hljs-keyword">return</span> left_tuple_list[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].<span class="hljs-built_in">get_null</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="update-select"><a href="#update-select" class="headerlink" title="update-select"></a>update-select</h3><p><img src="/img/update_select.png"></p><p>本题要求 update 的更新目标值可以通过子查询得出，子查询第一版本是我的队友完成的，但是在写复杂子查询的时候将整个框架重构了一下。因为在看代码框架的时候发现，用于生成算子的部分是完全独立的，所以完全可以将生成算子的部分改成静态的，从而可以 : “随时随地，STNT -&gt; 算子 -&gt; 结果”。这样设计完之后，想要获取子查询的结果只需要一个 STMT，极大的简化了代码，甚至 update-select 并没有新增什么内容，只是在收集更新的 Value 时，多增一步，如果 Value 是子查询需要转化一下。</p><p>需要注意的是，准确说当时因为这个 debug 了好久，where 子句筛选出来的元组集合为空集时，即便子查询搜出来的结果不合法，也算 SUCCESS。<br>对于子查询，能当作 update 的 Value 的充分必要条件是搜出来的元组数组，或者二维数组，只能是一个元素。如果搜出来是空集，等同于插入 NULL。</p><h4 id="STMT-vector-vector-Value"><a href="#STMT-vector-vector-Value" class="headerlink" title="STMT -&gt; vector&lt; vector&lt; Value&gt;&gt;"></a>STMT -&gt; vector&lt; vector&lt; Value&gt;&gt;</h4><p>更近一步，设计一个函数，输入 STMT，输出为二维 Value 数组，省去中间的部分。函数设计如下：输入 STMT，输出 数据 + 表头信息。其中 main_tuple 为复杂子查询的内容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">RC <span class="hljs-title">OptimizeStage::handle_sub_stmt</span><span class="hljs-params">(Stmt *stmt, std::vector&lt;std::vector&lt;Value&gt;&gt; &amp;tuple_list, TupleSchema &amp;tuple_schema, <span class="hljs-type">const</span> Tuple *main_tuple)</span> </span>&#123;<br>  SelectStmt *select_stmt = <span class="hljs-built_in">static_cast</span>&lt;SelectStmt *&gt;(stmt);<br>  vector&lt;Table *&gt; tables = select_stmt-&gt;<span class="hljs-built_in">tables</span>();<br>  string table_names;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : tables) table_names += it-&gt;<span class="hljs-built_in">name</span>();<br><br>  RC rc = RC::SUCCESS;<br><br>  <span class="hljs-comment">// ? 不存在创建好的逻辑算子</span><br>  <span class="hljs-keyword">if</span> (!sub_expr_and_logical_oper.<span class="hljs-built_in">contains</span>(table_names)) &#123;<br>    unique_ptr&lt;LogicalOperator&gt; logical_oper;<br>    rc = <span class="hljs-built_in">create_logical_plan</span>(stmt, logical_oper);<br><br>    <span class="hljs-keyword">if</span> (rc != RC::SUCCESS &amp;&amp; rc != RC::UNIMPLEMENTED) <span class="hljs-keyword">return</span> rc;<br>    <span class="hljs-built_in">ASSERT</span>(logical_oper, <span class="hljs-string">&quot;logical operator is null&quot;</span>);<br><br>    sub_expr_and_logical_oper.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(table_names, std::<span class="hljs-built_in">move</span>(logical_oper)));<br>  &#125;<br><br>  <span class="hljs-comment">// ? 不存在创建好的物理算子</span><br>  <span class="hljs-keyword">if</span> (!sub_expr_and_physical_oper.<span class="hljs-built_in">contains</span>(table_names)) &#123;<br>    unique_ptr&lt;PhysicalOperator&gt; physical_oper;<br>    rc = <span class="hljs-built_in">generate_physical_plan</span>(sub_expr_and_logical_oper[table_names], physical_oper);<br><br>    <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br><br>    sub_expr_and_physical_oper.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(table_names, std::<span class="hljs-built_in">move</span>(physical_oper)));<br>  &#125;<br><br>  PhysicalOperator *physical_oper = sub_expr_and_physical_oper[table_names].<span class="hljs-built_in">get</span>();<br>  rc = <span class="hljs-built_in">get_tuple_schema</span>(physical_oper, tuple_schema);<br>  <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br><br>  rc = <span class="hljs-built_in">get_tuple_list</span>(physical_oper, tuple_list, main_tuple);<br>  <span class="hljs-keyword">return</span> rc;<br>&#125;<br><br><span class="hljs-function">RC <span class="hljs-title">OptimizeStage::create_logical_plan</span><span class="hljs-params">(Stmt *stmt, unique_ptr&lt;LogicalOperator&gt; &amp;logical_operator)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == stmt) &#123;<br>    <span class="hljs-keyword">return</span> RC::UNIMPLEMENTED;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> LogicalPlanGenerator::<span class="hljs-built_in">create</span>(stmt, logical_operator);<br>&#125;<br><br><span class="hljs-function">RC <span class="hljs-title">OptimizeStage::generate_physical_plan</span><span class="hljs-params">(unique_ptr&lt;LogicalOperator&gt; &amp;logical_operator, unique_ptr&lt;PhysicalOperator&gt; &amp;physical_operator)</span> </span>&#123;<br>  RC rc = PhysicalPlanGenerator::<span class="hljs-built_in">create</span>(*logical_operator, physical_operator);<br><br>  <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to create physical operator. rc=%s&quot;</span>, <span class="hljs-built_in">strrc</span>(rc));<br>  &#125;<br>  <span class="hljs-keyword">return</span> rc;<br>&#125;<br><br><span class="hljs-function">RC <span class="hljs-title">OptimizeStage::get_tuple_schema</span><span class="hljs-params">(PhysicalOperator *physical_operator, TupleSchema &amp;tuple_schema)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> physical_operator-&gt;<span class="hljs-built_in">tuple_schema</span>(tuple_schema);<br>&#125;<br><br><span class="hljs-function">RC <span class="hljs-title">OptimizeStage::get_tuple_list</span><span class="hljs-params">(PhysicalOperator *physical_operator, std::vector&lt;std::vector&lt;Value&gt;&gt; &amp;tuple_list, <span class="hljs-type">const</span> Tuple *main_tuple)</span> </span>&#123;<br>  RC rc = physical_operator-&gt;<span class="hljs-built_in">open</span>(<span class="hljs-literal">nullptr</span>, main_tuple);<br>  <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to open sub physical operator. rc=%s&quot;</span>, <span class="hljs-built_in">strrc</span>(rc));<br>    <span class="hljs-keyword">return</span> rc;<br>  &#125;<br><br>  <span class="hljs-comment">// 将查表结果放入value_list</span><br>  <span class="hljs-keyword">while</span> (RC::SUCCESS == (rc = physical_operator-&gt;<span class="hljs-built_in">next</span>(main_tuple))) &#123;<br>    Tuple *tuple = physical_operator-&gt;<span class="hljs-built_in">current_tuple</span>();<br>    std::vector&lt;Value&gt; single_tuple;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tuple-&gt;<span class="hljs-built_in">cell_num</span>(); i++) &#123;<br>      Value value;<br>      tuple-&gt;<span class="hljs-built_in">cell_at</span>(i, value);<br>      single_tuple.<span class="hljs-built_in">push_back</span>(value);<br>    &#125;<br>    tuple_list.<span class="hljs-built_in">push_back</span>(single_tuple);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (rc != RC::RECORD_EOF) <span class="hljs-keyword">return</span> rc;<br><br>  rc = physical_operator-&gt;<span class="hljs-built_in">close</span>();<br>  <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br><br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="update-中添加有关子查询的部分"><a href="#update-中添加有关子查询的部分" class="headerlink" title="update 中添加有关子查询的部分"></a>update 中添加有关子查询的部分</h4><p>如果发现有子查询，通过函数将其转化为二维 Value 数组，如果数组只有一个元素则合法，拿出来；如果数组为空，则等同于 NULL；如果数组不为空，等同一个非法的 Value，注意这里并没有直接返回 FAILURE，因为如果 where 子句筛选集为空集，即便子查询有误也返回 SUCCESS，所以这里通过特意构造非法 Value，如果 where 子句筛选集不为空集，则会识别非法 Value 并返回 FAILURE；如果 where 子句筛选集为空集，则不会有识别环节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">RC <span class="hljs-title">UpdateStmt::create</span><span class="hljs-params">(Db *db, UpdateSqlNode &amp;update, Stmt *&amp;stmt)</span> </span>&#123;<br>  <span class="hljs-comment">// 拿到目标表格以及名称以及修改域</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *table_name = update.relation_name.<span class="hljs-built_in">c_str</span>();<br>  Table *table = db-&gt;<span class="hljs-built_in">find_table</span>(table_name);<br><br>  <span class="hljs-comment">// 目标表格不存在检查</span><br>  <span class="hljs-keyword">if</span> (table == <span class="hljs-literal">nullptr</span>) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;no such table. db=%s, table_name=%s&quot;</span>, db-&gt;<span class="hljs-built_in">name</span>(), table_name);<br>    <span class="hljs-keyword">return</span> RC::SCHEMA_TABLE_NOT_EXIST;<br>  &#125;<br>  <span class="hljs-comment">// 参数非法检查</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == db || <span class="hljs-literal">nullptr</span> == table_name) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;invalid argument. db=%p, table_name=%p&quot;</span>, db, table_name);<br>    <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>  &#125;<br><br>  <span class="hljs-comment">// 拿到全部修改域</span><br>  std::vector&lt;FieldMeta&gt; field_metas;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : update.update_targets) &#123;<br>    FieldMeta *field_meta = (FieldMeta *)table-&gt;<span class="hljs-built_in">table_meta</span>().<span class="hljs-built_in">field</span>(it.attribute_name.<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-comment">// 修改域检查</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == field_meta) &#123;<br>      <span class="hljs-keyword">return</span> RC::SCHEMA_FIELD_NOT_EXIST;<br>    &#125;<br>    field_metas.<span class="hljs-built_in">push_back</span>(*field_meta);<br>  &#125;<br><br>  <span class="hljs-comment">// 创建筛选 STMT 对象</span><br>  std::unordered_map&lt;std::string, Table *&gt; table_map;<br>  table_map.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">pair</span>&lt;std::string, Table *&gt;(std::<span class="hljs-built_in">string</span>(table_name), table));<br>  FilterStmt *filter_stmt = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-type">bool</span> flag;<br>  RC rc = FilterStmt::<span class="hljs-built_in">create</span>(db, table, &amp;table_map, update.conditions.<span class="hljs-built_in">data</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(update.conditions.<span class="hljs-built_in">size</span>()), filter_stmt, flag);<br><br>  <span class="hljs-comment">// 谓词语句合法检查</span><br>  <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) &#123;<br>    <span class="hljs-built_in">LOG_WARN</span>(<span class="hljs-string">&quot;failed to create filter statement. rc=%d:%s&quot;</span>, rc, <span class="hljs-built_in">strrc</span>(rc));<br>    <span class="hljs-keyword">return</span> rc;<br>  &#125;<br><br>  <span class="hljs-comment">// 创建子查询的 STMT 对象</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">int</span>)update.update_targets.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span> (update.update_targets[i].is_value == <span class="hljs-literal">false</span>) &#123;<br>      Stmt *temp;<br>      rc = SelectStmt::<span class="hljs-built_in">create</span>(db, update.update_targets[i].sub_select-&gt;selection, temp, flag);<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> rc;<br>      vector&lt;vector&lt;Value&gt;&gt; tuple_list;<br>      TupleSchema tuple_schema;<br>      OptimizeStage::<span class="hljs-built_in">reset</span>();<br>      RC rc = OptimizeStage::<span class="hljs-built_in">handle_sub_stmt</span>(temp, tuple_list, tuple_schema);<br>      <span class="hljs-keyword">if</span> (rc != RC::SUCCESS) <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>      <span class="hljs-comment">// 子查询为空值，等同于插入 NULL</span><br>      <span class="hljs-keyword">if</span> (tuple_list.<span class="hljs-built_in">empty</span>()) &#123;<br>        update.update_targets[i].value.<span class="hljs-built_in">set_null</span>(<span class="hljs-literal">true</span>);<br>      &#125;<br>      <span class="hljs-comment">// 子查询非法，等同于插入非法 Value，如果筛选出来没有更新目标，则无视，否则报错</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tuple_list.<span class="hljs-built_in">size</span>() != <span class="hljs-number">1</span> || tuple_list[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() != <span class="hljs-number">1</span>) &#123;<br>        update.update_targets[i].value.<span class="hljs-built_in">set_type</span>(AttrType::UNDEFINED);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        update.update_targets[i].value = tuple_list[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>      &#125;<br>      update.update_targets[i].is_value = <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// check date validity</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : update.update_targets) &#123;<br>    Value value = it.value;<br>    <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">attr_type</span>() == AttrType::DATE) &#123;<br>      <span class="hljs-keyword">if</span> (!DateType::<span class="hljs-built_in">check_date</span>(value.<span class="hljs-built_in">get_date</span>())) &#123;<br>        <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">attr_type</span>() == AttrType::CHARS) &#123;<br>      <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">get_string</span>().<span class="hljs-built_in">size</span>() &gt; BP_MAX_TEXT_SIZE) &#123;<br>        <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">attr_type</span>() == AttrType::VECTORS) &#123;<br>      <span class="hljs-keyword">if</span> (value.<span class="hljs-built_in">get_vector_size</span>() &gt; BP_MAX_VECTOR_SIZE) &#123;<br>        <span class="hljs-keyword">return</span> RC::INVALID_ARGUMENT;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 创建 update 的 STMT 对象</span><br>  stmt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">UpdateStmt</span>(table, filter_stmt, field_metas, update.update_targets);<br>  <span class="hljs-keyword">return</span> RC::SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p><img src="/img/alias.png"></p><h3 id="order-by"><a href="#order-by" class="headerlink" title="order-by"></a>order-by</h3><p><img src="/img/order_by.png"></p><h3 id="aggregation-and-groupby"><a href="#aggregation-and-groupby" class="headerlink" title="aggregation_and_groupby"></a>aggregation_and_groupby</h3><p><img src="/img/aggregation_and_groupby.png"></p><h3 id="create-table-select"><a href="#create-table-select" class="headerlink" title="create-table-select"></a>create-table-select</h3><p><img src="/img/create_table_select.png"></p><h3 id="vector-rewrite"><a href="#vector-rewrite" class="headerlink" title="vector_rewrite"></a>vector_rewrite</h3><p><img src="/img/vector_rewrite.png"></p><h3 id="vector-search"><a href="#vector-search" class="headerlink" title="vector_search"></a>vector_search</h3><p><img src="/img/vector_search.png"></p><h3 id="complex-sub-query"><a href="#complex-sub-query" class="headerlink" title="complex-sub-query"></a>complex-sub-query</h3><p><img src="/img/complex_sub_query.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Competition</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
