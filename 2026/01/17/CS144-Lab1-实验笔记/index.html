<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  
  
    <meta name="description" content="Lab 1">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
  <title>CS144-Lab1-实验笔记 |  Hexo</title>
  
    <link rel="apple-touch-icon" sizes="57x57" href="/images/DMX_cat.jpg/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/DMX_cat.jpg/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/DMX_cat.jpg/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/DMX_cat.jpg/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/DMX_cat.jpg/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/DMX_cat.jpg/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/DMX_cat.jpg/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/DMX_cat.jpg/apple-touch-icon-180x180.png">
    <link rel="apple-touch-icon" sizes="167x167" href="/images/DMX_cat.jpg/apple-touch-icon-167x167.png">
  
  
    <link rel="shortcut icon" href="/images/DMX_cat.jpg">
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <main class="main">
    
	<header id="header" class="header">

	<div class="container">
		<nav class="navbar d-flex align-items-center">
			<a class="brand" href="/">
				<img class="logo lazyload" data-src="/images/DMX_cat.jpg" alt="Hexo" role="img">
			</a>
			<ul class="main-nav">
  
    
  <li class="nav-item ">
    <a class="nav-item-link" href="/">首页</a>
  </li>
  
    
  <li class="nav-item ">
    <a class="nav-item-link" href="/stories">故事</a>
  </li>
  
    
  <li class="nav-item ">
    <a class="nav-item-link" href="/archives">博客</a>
  </li>
  
    
  <li class="nav-item ">
    <a class="nav-item-link" href="/about">关于</a>
  </li>
  
</ul>
		</nav>
		<a id="mobile-nav-toggle">
			<span class="mobile-nav-toggle-bar"></span>
			<span class="mobile-nav-toggle-bar"></span>
			<span class="mobile-nav-toggle-bar"></span>
		</a>
	</div>
</header>

    <section>
      <div class="container">
  <article id="post-CS144-Lab1-实验笔记" class="article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  
  <div class="article-cover mb-5">
    
  </div>
  
  <div class="article-inner">
    
    <header class="article-header">
      
      
  
    <h1 class="article-title" itemprop="name">
      CS144-Lab1-实验笔记
    </h1>
  

      <div class="article-meta">
        <time class="text-gray" datetime="2026-01-16T16:00:00.000Z" itemprop="datePublished">
  2026-01-17
</time>
        
      </div>
      
    </header>
    
    <div class="article-entry" itemprop="articleBody">
      <p>Lab 1</p>
<span id="more"></span>

<hr>
<link rel="stylesheet" href="/css/CS144.css">

<div class="all">

<h2 id="0x00-Overview"><a href="#0x00-Overview" class="headerlink" title="0x00 Overview"></a>0x00 Overview</h2><p>checkpoint 0 中使用 Linux 内置的 TCP 协议 通过互联网套接字访问网站和发送邮件，体验了 TCP 提供的可靠、有序的双向字节流服务。但底层网络 (IP) 实际只提供“尽力而为”的数据报服务，即数据包可能丢失、乱序、篡改或重复。接下来的实验任务是：自己实现 TCP 协议，在不可靠的数据报网络之上，实现两台计算机之间的可靠字节流抽象。</p>
<p>本实验要求实现两个跨网络的字节流：</p>
<ol>
<li>“出站”字节流：本地应用写入套接字，由你的 TCP 发送给对端。</li>
<li>“入站”字节流：从对端接收数据，供本地应用读取。</li>
</ol>
<h2 id="0x01-Implementation-putting-substrings-in-sequence"><a href="#0x01-Implementation-putting-substrings-in-sequence" class="headerlink" title="0x01 Implementation: putting substrings in sequence"></a>0x01 Implementation: putting substrings in sequence</h2><p>TCP 发送方将其字节流分割成较短的段 (每个子串不超过约 1,460 字节)，以便每个段都能放入一个数据报中。但网络可能会重新排序这些数据报、丢弃它们或多次传递它们。接收器必须将这些段重新组装成它们最初的连续字节流。</p>
<p>在本实验中，需要编写负责这种重装的数据结构：一个重装器 (Reassembler)。它将接收子串，每个子串包含一串字节，以及该字符串在更大流中的起始字节索引。流的每个字节都有其唯一的索引，从零开始向上计数。一旦重装器知道流的下一个字节，就会将其写入 ByteStream 的写入端——也就是在 checkpoint0 中实现的相同 ByteStream。重装器的“客户”可以从同一 ByteStream 的读取端读取数据。</p>
<p>实验要求实现 Reassembler 类 (在文件 <code>reassembler.hh</code> 和 <code>reassembler.cc</code> 中)，其公共接口如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Insert a new substring to be reassembled into a ByteStream.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">( <span class="type">uint64_t</span> first_index, std::string data, <span class="type">bool</span> is_last_substring )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// How many bytes are stored in the Reassembler itself?</span></span><br><span class="line"><span class="comment">// This function is for testing only; don&#x27;t add extra state to support it.</span></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">count_bytes_pending</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Access output stream reader</span></span><br><span class="line"><span class="function">Reader&amp; <span class="title">reader</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> output_.<span class="built_in">reader</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> Reader&amp; <span class="title">reader</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> output_.<span class="built_in">reader</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Access output stream writer, but const-only (can&#x27;t write from outside)</span></span><br><span class="line"><span class="function"><span class="type">const</span> Writer&amp; <span class="title">writer</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> output_.<span class="built_in">writer</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p>插入子串时，遵循的逻辑如下：</p>
<img src="/images/Network/LAB1_01.png">

<p>我们首先用一个 <code>map</code> 数据结构来记录所有红色的片段 (<code>std::map&lt;std::pair&lt;uint64_t, uint64_t&gt;, std::string&gt; storage_</code>)。在 <code>insert</code> 函数中，实现逻辑如下：</p>
<p><strong>识别 <code>first_unassembled_idx</code> 和 <code>first_unacceptable_idx</code></strong></p>
<p>首先拿到 <code>Writer</code> 变量，<code>first_unassembled_idx</code> 是第一个没有写入 <code>ByteStream</code> 的字节索引，<code>first_unacceptable_idx</code> 是第一个不被接受的字节索引：因此，<code>first_unassembled_idx</code> 是 <code>Writer</code> 已经写入的字节数，而 <code>first_unacceptable_idx</code> 是 <code>Writer</code> 可用容量加上 <code>first_unassembled_idx</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Writer &amp;writer = output_.<span class="built_in">writer</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> first_unassembled_idx = writer.<span class="built_in">bytes_pushed</span>();</span><br><span class="line"><span class="type">uint64_t</span> first_unacceptable_idx = writer.<span class="built_in">available_capacity</span>() + first_unassembled_idx;</span><br></pre></td></tr></table></figure>

<p><strong>记录流结束下标</strong></p>
<p>如果 <code>is_last_substring</code> 为真，说明这是流的最后一个子串，我们需要记录流的结束下标 <code>last_index_</code>，它是 <code>first_index + data.size()</code> 和当前 <code>last_index_</code> 的最小值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_last_substring)</span><br><span class="line">    last_index_ = std::<span class="built_in">min</span>(last_index_, first_index + data.<span class="built_in">size</span>());</span><br></pre></td></tr></table></figure>

<p><strong>丢弃超出容量的数据或空数据</strong></p>
<p>如果 <code>first_index</code> 大于等于 <code>first_unacceptable_idx</code>，说明该子串的起始下标已经超出接收窗口，或者数据为空字符串，我们就直接丢弃该子串。如果已经接收到了流的最后一个子串，并且所有数据都已经写入 <code>ByteStream</code>，则关闭写入端：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (first_index &gt;= first_unacceptable_idx || data.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (last_index_ != UINT64_MAX &amp;&amp; writer.<span class="built_in">bytes_pushed</span>() == last_index_)</span><br><span class="line">        writer.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>截断超出容量的数据和已写入部分</strong></p>
<p>如果 <code>first_index + data.size()</code> 超过了 <code>first_unacceptable_idx</code>，说明该子串的一部分数据超出了接收窗口，我们需要截断该子串，只保留在接收窗口内的数据。如果 <code>first_index + data.size()</code> 小于等于 <code>first_unassembled_idx</code>，说明该子串的所有数据都已经写入 <code>ByteStream</code>，我们直接返回即可。如果 <code>first_index</code> 小于 <code>first_unassembled_idx</code>，说明该子串的前面一部分数据已经写入 <code>ByteStream</code>，我们需要截断该子串，只保留未写入的数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 截断超出容量的数据</span></span><br><span class="line"><span class="keyword">if</span> (first_index + data.<span class="built_in">size</span>() &gt; first_unacceptable_idx)</span><br><span class="line">    data = data.<span class="built_in">substr</span>(<span class="number">0</span>, first_unacceptable_idx - first_index);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 截断已写入部分</span></span><br><span class="line"><span class="keyword">if</span> (first_index + data.<span class="built_in">size</span>() &lt;= first_unassembled_idx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (last_index_ != UINT64_MAX &amp;&amp; writer.<span class="built_in">bytes_pushed</span>() == last_index_)</span><br><span class="line">        writer.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (first_index &lt; first_unassembled_idx)</span><br><span class="line">&#123;</span><br><span class="line">    data = data.<span class="built_in">substr</span>(first_unassembled_idx - first_index);</span><br><span class="line">    first_index = first_unassembled_idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>合并重叠区间</strong></p>
<p>首先，插入新的子串到 <code>storage_</code> 中，然后遍历 <code>storage_</code>，检查相邻的区间是否有重叠，如果有重叠则合并它们：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> seg_start = first_index;</span><br><span class="line"><span class="type">uint64_t</span> seg_end = first_index + data.<span class="built_in">size</span>();</span><br><span class="line">storage_.<span class="built_in">insert</span>(&#123;&#123;seg_start, seg_end&#125;, data&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = storage_.<span class="built_in">begin</span>(); it != storage_.<span class="built_in">end</span>();)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> next_it = <span class="built_in">next</span>(it);</span><br><span class="line">    <span class="keyword">if</span> (next_it == storage_.<span class="built_in">end</span>())</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="type">uint64_t</span> exist_start = it-&gt;first.first, exist_end = it-&gt;first.second;</span><br><span class="line">    <span class="type">uint64_t</span> next_start = next_it-&gt;first.first, next_end = next_it-&gt;first.second;</span><br><span class="line">    std::string &amp;exist_data = it-&gt;second, &amp;next_data = next_it-&gt;second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next_it-&gt;first.first &lt;= it-&gt;first.second)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (next_end &gt; exist_end)</span><br><span class="line">        &#123;</span><br><span class="line">            exist_data += next_data.<span class="built_in">substr</span>(exist_end - next_start);</span><br><span class="line">            exist_end = next_end;</span><br><span class="line">        &#125;</span><br><span class="line">        pair&lt;pair&lt;<span class="type">uint64_t</span>, <span class="type">uint64_t</span>&gt;, string&gt; new_data = &#123;&#123;exist_start, exist_end&#125;, exist_data&#125;;</span><br><span class="line">        storage_.<span class="built_in">erase</span>(it);</span><br><span class="line">        storage_.<span class="built_in">erase</span>(next_it);</span><br><span class="line">        storage_.<span class="built_in">insert</span>(new_data);</span><br><span class="line">        it = storage_.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>尝试写入连续数据</strong></p>
<p>此时，如果有数据可以写入，一定是第一个数据，且起点一定等于 <code>first_unassembled_idx</code>，我们就将这个连续的数据写入 <code>ByteStream</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (storage_.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (storage_.<span class="built_in">begin</span>()-&gt;first.first == first_unassembled_idx)</span><br><span class="line">&#123;</span><br><span class="line">    writer.<span class="built_in">push</span>(storage_.<span class="built_in">begin</span>()-&gt;second);</span><br><span class="line">    storage_.<span class="built_in">erase</span>(storage_.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>处理流结束</strong></p>
<p>如果已经接收到了流的最后一个子串，并且所有数据都已经写入 <code>ByteStream</code>，则关闭写入端：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (last_index_ != UINT64_MAX &amp;&amp; writer.<span class="built_in">bytes_pushed</span>() == last_index_)</span><br><span class="line">    writer.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<p><strong>计数当前缓存的字节数</strong></p>
<p>记录在重装器中但尚未写入 <code>ByteStream</code> 的字节数，可以通过遍历 <code>storage_</code> 中的所有区间，计算它们的长度之和来实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">Reassembler::count_bytes_pending</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint64_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;kv : storage_)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt += kv.first.second - kv.first.first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div>
    </div>
    <footer class="article-footer">
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a></li></ul>

    </footer>
  </div>
  
  
    
<nav class="article-nav pt-4 mt-3" id="article-nav">
  
  
    <a href="/2026/01/05/CS144-Lab0-%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">CS144-Lab0-实验笔记</div>
    </a>
  
</nav>


  
</article>
</div>
    </section>
    <footer class="footer pt-5 mt-5">
  <div class="container">
    <div class="py-3">
      <div class="row justify-content-between">
        <div class="col-6">
          <img class="filter-gray mb-3 lazyload" height="40" data-src="/images/DMX_cat.jpg" alt="Hexo" role="img">
          <p class="mb-4"></p>
          <ul class="list-inline">
            
              <li class="list-inline-item">
                <a target="_blank" rel="noopener" href="https://zhwangart.com">
                  <img 0="微博" src="/images/icons/contact_weibo.svg">
                </a>
              </li>
            
              <li class="list-inline-item">
                <a href="javascript:;">
                  <img 0="微信" src="/images/icons/contact_wechat.svg">
                </a>
              </li>
            
              <li class="list-inline-item">
                <a href="mailto:a@abc.com">
                  <img 0="邮箱" src="/images/icons/contact_email.svg">
                </a>
              </li>
            
          </ul>
        </div>
        <div class="col-4">
          <h5>友情链接</h5>
          <ul class="list-inline">
            
              <li class="list-inline-item">
                <a href="https://acorn.imaging.xin/" title="Acorn" target="_blank" rel="noopener">Acorn</a>
              </li>
            
              <li class="list-inline-item">
                <a href="https://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a>
              </li>
            
              <li class="list-inline-item">
                <a href="https://github.com/" title="GitHub" target="_blank" rel="noopener">GitHub</a>
              </li>
            
              <li class="list-inline-item">
                <a href="https://duoyu.wang/" title="To Base64" target="_blank" rel="noopener">To Base64</a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
    <hr class="hr" style="opacity: .25;">
    <div class="pt-3 pb-5">
      <ul class="list-inline mb-0 text-center">
        <li class="list-inline-item">&copy; 2026 Hexo</li>
        
        <li class="list-inline-item">Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
        <li class="list-inline-item">Designer <a href="https://acorn.imaging.xin/" target="_blank">DM-X~X~X</a></li>
      </ul>
    </div>
  </div>
</footer>
  </main>
  <div id="mobile-nav-dimmer"></div>
<div id="mobile-nav">
	<div id="mobile-nav-inner">
		<ul class="mobile-nav">
  
    
  <li class="nav-item ">
    <a class="nav-item-link" href="/">首页</a>
  </li>
  
    
  <li class="nav-item ">
    <a class="nav-item-link" href="/stories">故事</a>
  </li>
  
    
  <li class="nav-item ">
    <a class="nav-item-link" href="/archives">博客</a>
  </li>
  
    
  <li class="nav-item ">
    <a class="nav-item-link" href="/about">关于</a>
  </li>
  
</ul>
		
	</div>
</div>

  <script src="/libs/feather/feather.min.js"></script>
<script src="/libs/lazysizes/lazysizes.min.js"></script>

	<script src="/libs/tocbot/tocbot.min.js"></script>
	<script>
    tocbot.init({
      // Where to render the table of contents.
      tocSelector: '.js-toc',
      // Where to grab the headings to build the table of contents.
      contentSelector: '.js-toc-content',
      // Which headings to grab inside of the contentSelector element.
      headingSelector: 'h2, h3',
      // For headings inside relative or absolute positioned containers within content.
      hasInnerContainers: true,
    });
	</script>





<script src="/js/mobile-nav.js"></script>


<script src="/js/script.js"></script>


</body>
</html>